  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://firebaseinstallations.googleapis.com" crossorigin>
  <!-- Extra Firebase endpoints we touch early -->
  <link rel="preconnect" href="https://www.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://identitytoolkit.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://securetoken.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://firebasestorage.googleapis.com" crossorigin>

  <!-- Low-cost DNS prefetch fallbacks (in case preconnect is ignored) -->
  <link rel="dns-prefetch" href="https://www.gstatic.com">
  <link rel="dns-prefetch" href="https://firestore.googleapis.com">
  <link rel="dns-prefetch" href="https://firebaseinstallations.googleapis.com">
  <link rel="dns-prefetch" href="https://www.googleapis.com">
  <link rel="dns-prefetch" href="https://identitytoolkit.googleapis.com">
  <link rel="dns-prefetch" href="https://securetoken.googleapis.com">
  <link rel="dns-prefetch" href="https://firebasestorage.googleapis.com">

    <title>Kaufland Route List</title>
  <style>
  /* =========================================================
    NEON DARK THEME (with light variant)
    - Accent: hot pink
    - Dark-first design; soft glass, rounded, high contrast
    - Force theme by adding data-theme="dark" | "light" to <html>
    ========================================================= */

  /* ---------- Shared tokens ---------- */
  :root{
    --radius: 16px;
    --pad: 14px;

    --primary: #ff007f;          /* hot pink */
    --on-primary: #ffffff;

    /* defaults = LIGHT; overridden below for dark/auto-dark */
    --bg: #f7f7fb;
    --surface: #ffffff;
    --text: #111318;

    --muted: #5f6675;
    --border: #e5e7eb;
    --chip: #f2f3f6;
    --chip-border: #e6e7ef;

    --hover: rgba(0,0,0,.04);
    --press: rgba(0,0,0,.08);

    --shadow-sm: 0 6px 18px rgba(0,0,0,.06);
    --shadow-md: 0 12px 36px rgba(0,0,0,.12);

    /* focus */
    --ring: 0 0 0 3px color-mix(in oklab, var(--primary) 32%, transparent);
  }

  /* ---------- Auto dark (when you don't force a theme) ---------- */
  @media (prefers-color-scheme: dark){
    :root:not([data-theme]){
      --bg: #0f0f12;
      --surface: #17171c;
      --text: #e8e9ee;

      --muted: #a5adbb;
      --border: #2a2a33;
      --chip: #1f1f25;
      --chip-border: #2a2a33;

      --hover: rgba(255,255,255,.06);
      --press: rgba(255,255,255,.10);

      --shadow-sm: 0 10px 28px rgba(0,0,0,.35);
      --shadow-md: 0 18px 48px rgba(0,0,0,.45);
    }
  }

  /* ---------- Manual overrides ---------- */
  :root[data-theme="light"]{
    --bg: #f7f7fb;
    --surface: #ffffff;
    --text: #111318;

    --muted: #5f6675;
    --border: #e5e7eb;
    --chip: #f2f3f6;
    --chip-border: #e6e7ef;

    --hover: rgba(0,0,0,.04);
    --press: rgba(0,0,0,.08);

    --shadow-sm: 0 6px 18px rgba(0,0,0,.06);
    --shadow-md: 0 12px 36px rgba(0,0,0,.12);
  }
  :root[data-theme="dark"]{
    --bg: #0f0f12;
    --surface: #17171c;
    --text: #e8e9ee;

    --muted: #a5adbb;
    --border: #2a2a33;
    --chip: #1f1f25;
    --chip-border: #2a2a33;

    --hover: rgba(255,255,255,.06);
    --press: rgba(255,255,255,.10);

    --shadow-sm: 0 10px 28px rgba(0,0,0,.35);
    --shadow-md: 0 18px 48px rgba(0,0,0,.45);
  }

  /* =========================================================
    Base
    ========================================================= */
  *{ box-sizing: border-box; }
  :root{ color-scheme: light dark; }

  body{
    margin:0;
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans';
  }

  .wrap{ max-width: 900px; margin: 0 auto; padding: 14px; }
  h1{ font-size: 20px; margin: 6px 0 2px; }

  header{
    position: sticky; top: 0; z-index: 5;
    background: color-mix(in oklab, var(--surface) 90%, transparent);
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border);
  }

  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:end; }

  /* =========================================================
    Controls
    ========================================================= */
  input[type="text"], input[type="number"], input[type="file"], select{
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    outline: none;
    transition: border-color .12s ease, box-shadow .12s ease, background .12s ease;
  }
  input[type="text"]:focus, input[type="number"]:focus, select:focus{
    border-color: color-mix(in oklab, var(--primary) 55%, var(--border));
    box-shadow: var(--ring);
  }
  input[type="number"]{ width: 110px; }

  button{
    padding: 10px 14px;
    border-radius: 14px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    cursor: pointer;
    box-shadow: var(--shadow-sm);
    transition: background .12s ease, transform .06s ease, border-color .12s ease, box-shadow .12s ease;
  }

  button.primary{
    background: var(--primary);
    color: var(--on-primary);
    border-color: var(--primary);
    box-shadow: 0 12px 30px color-mix(in oklab, var(--primary) 30%, transparent);
  }

  /* Pills / chips */
  .pill{
    padding: 6px 12px; border-radius: 999px;
    background: var(--chip);
    border: 1px solid var(--chip-border);
    font-size: 12px;
    color: var(--text);
  }
  .muted{ color: var(--muted); font-size: 13px; }

  /* =========================================================
    Cards, toolbars, tabs
    ========================================================= */
  .card{
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: var(--pad);
    box-shadow: var(--shadow-md);
  }

  .toolbar{ display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; }
  .toolbar .group{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  .card > .toolbar{
    position: static;          /* was: sticky */
    top: auto;                 /* no offset */
    z-index: auto;             /* no stacking above content */
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 8px 0;
  }


  /* Tabs */
  .tabs{ display:flex; gap:10px; }
  .tab{
    padding: 8px 16px;
    border-radius: 999px;
    border: 1px solid var(--chip-border);
    background: var(--chip);
    color: var(--text);
    transition: background .12s ease, box-shadow .12s ease, border-color .12s ease, transform .06s ease;
  }
  .tab:hover{ background: color-mix(in oklab, var(--chip), var(--hover)); }
  .tab.active{
    background: var(--primary);
    border-color: var(--primary);
    color: var(--on-primary);
    box-shadow: 0 14px 36px color-mix(in oklab, var(--primary) 30%, transparent);
  }
  /* =========================================================
    Bottom Navigation
    ========================================================= */
  .bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    display: flex;
    gap: 8px;
    padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
    background: var(--surface);
    border-top: 1px solid var(--border);
    box-shadow: 0 -8px 24px rgba(0,0,0,.12);
    z-index: 9999;           /* ↑ ensure it sits on top of footer/overlays */
    pointer-events: auto;
  }
  /* ===== Modal-open UI lock (prevent background interaction) ===== */
  body.modal-open { overflow: hidden; }
  /* Disable nav while modal is open, but keep the Weekly Items FAB clickable */
  body.modal-open .bottom-nav {
    pointer-events: none !important;
  }


  .bottom-nav .tab {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    border-radius: 0;
    border: none;
    background: transparent;
    font-weight: 600;
  }
  .bottom-nav .tab.active {
    background: var(--primary);
    color: var(--on-primary);
    border-radius: 12px;
    margin: 0 4px;
  }

  /* =========================================================
    List + groups
    ========================================================= */
  /* Animated show/hide for List tab content (scoped to #listSection ONLY) */
  #listSection #list,
  #listSection #empty{
    /* Transitionable properties */
    transition:
      max-height 220ms ease,
      opacity 180ms ease,
      transform 220ms ease;
    /* Expanded defaults */
    max-height: none;       /* large enough to fit typical lists */
    opacity: 1;
    transform: translateY(0);
    overflow: hidden;         /* enables height animation without layout spill */
  }

  /* Collapsed state (driven by data-list-collapsed on #listSection) */
  #listSection[data-list-collapsed="true"] #list,
  #listSection[data-list-collapsed="true"] #empty{
    max-height: 0;
    opacity: 0;
    transform: translateY(-6px);
    pointer-events: none;     /* make content non-interactive while hidden */
  }

  /* Respect reduced-motion preferences */
  @media (prefers-reduced-motion: reduce){
    #listSection #list,
    #listSection #empty{
      transition: none !important;
    }
  }

  .list{ margin-top:10px; display:grid; gap:12px; }
  .groupHeader{ display:flex; align-items:center; gap:10px; font-weight:700; padding:4px 2px 0; }
  .groupHeader .dot{ width:8px; height:8px; border-radius:999px; background:#9aa3b2; }
  .groupBox{ display:grid; gap:8px; }

  /* =========================================================
    Item row
    ========================================================= */
  .item{
    display:grid;
    grid-template-columns: 28px 1fr auto;
    grid-template-rows: auto auto auto;  /* title / qty+size+actions / photo+notes */
    gap:10px 10px;
    align-items:center;
    padding:10px 12px;
    border:1px solid var(--border);
    border-radius:14px;
    background: var(--surface);
    transition: transform .06s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease;
  }

  .item.is-pressed{ transform: scale(.995); box-shadow: 0 8px 24px rgba(0,0,0,.25); }

  .left{ grid-column:1; grid-row:1; display:flex; align-items:center; justify-content:center; }
.item input[type="checkbox"] {
  margin-right: 8px;
  width: 18px;
  height: 18px;
}

.md-task {
  vertical-align: middle;
  margin-right: 6px;
}

  .line1{
    grid-column:2; grid-row:1;
    font-size:16px; font-weight:800; line-height:1.25;
    overflow:hidden; white-space:nowrap; text-overflow:ellipsis; min-width:0;
  }
    /* second line under the name (qty + size) */
 .line1 .meta{
    margin-top:6px;
    display:flex;
    align-items:center;
    gap:30px;                  /* ↑ increased gap for easier tapping */
    flex-wrap:wrap;
    font-weight:600;
}

  .line1 .meta .muted{ font-weight:500; }  /* keep size text lighter */

  .line1 .sep{ opacity:.7; font-weight:600; }

  .actions{ grid-column:3; grid-row:2; display:flex; gap:8px; align-items:center; justify-self:end; }

  .editbtn, .btn-icon{
    height:36px; padding:0 12px; border-radius:10px;
    border:1px solid var(--border);
    background: var(--surface);
    display:grid; place-items:center;
  }

  .icon{ width:18px; height:18px; display:inline-block; }

  /* Below row (photo + notes) */
  .below{
    grid-column:2; grid-row:2;

    display:grid; grid-template-columns:48px 1fr;
    align-items:center; column-gap:10px;
  }
  .below.hidden{ display:none; }

  .thumb{
    width:44px; height:44px; border-radius:12px; object-fit:cover;
    border:1px solid var(--border); background:#2a2a33; display:block; cursor:pointer;
  }
  .camBtn{
    width:44px; height:44px; border-radius:12px;
    border:1px dashed var(--border);
    display:flex; align-items:center; justify-content:center;
    background: var(--surface);
    cursor:pointer; padding:0;
  }

  .line2{ color: var(--muted); font-size:14px; line-height:1.35; white-space:normal; overflow-wrap:anywhere; }
  .line2:empty{ display:none; }

  /* Category dots (kept from your schema) */
  .catdot{ width:8px; height:8px; border-radius:999px; display:inline-block; margin-right:8px; background:#7b8497; vertical-align:middle; }
  .item[data-cat="produce"] .catdot{ background:#2fb344; }
  .item[data-cat="meat-poultry"] .catdot{ background:#d7263d; }
  .item[data-cat="fish-seafood"] .catdot{ background:#2a9df4; }
  .item[data-cat="dairy-eggs"] .catdot{ background:#51b3ff; }
  .item[data-cat="bakery"] .catdot{ background:#f08c2f; }
  .item[data-cat="pantry"] .catdot{ background:#a1765c; }
  .item[data-cat="frozen"] .catdot{ background:#27c3d6; }
  .item[data-cat="beverages"] .catdot{ background:#7b61ff; }
  .item[data-cat="snacks-confectionery"] .catdot{ background:#ffd43b; }
  .item[data-cat="household-cleaning"] .catdot{ background:#8795a1; }
  .item[data-cat="personal-care-health"] .catdot{ background:#ff6fa3; }
  .item[data-cat="other"] .catdot{ background:#c0c4cc; }

  /* Inline qty box inside title */
  .qty-inline {
    min-width: 7ch;              /* at least space for 10 characters */
    width: auto;                 /* let it grow */
    padding: 6px 8px;
    border: 1px solid var(--border);
    border-radius: 10px;
    font: inherit;
    background: var(--surface);
    color: var(--text);
  }


  /* Editor row (expanded) */
  .item .editor{ 
    display:none; 
    grid-column:1 / -1; 
    grid-row:4;              /* 🔴 always sits below photo/notes */
  }
  .item.editing .editor{
    display:grid;
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap:8px; 
    padding-top:8px;
  }
  .qty, .size, .notes, .route, .category{ width:100%; }


  @media (max-width:560px){
    .item.editing .editor{ grid-template-columns:1fr; }
    button, input, select{ min-height:44px; }
  }

  /* Checked effect */
  .item:has(input[type="checkbox"]:checked){
    background:
      linear-gradient(0deg, color-mix(in oklab, var(--surface) 75%, var(--hover)), color-mix(in oklab, var(--surface) 75%, var(--hover))),
      var(--surface);
    opacity:.92;
  }
  .item:has(input[type="checkbox"]:checked) .line1{ text-decoration:line-through; color: color-mix(in oklab, var(--text) 60%, #888); }

  /* =========================================================
    Autocomplete / Toast / Popups / Modals / Lightbox
    (restyled to match neon-dark)
    ========================================================= */
  .ac-list{
    position:absolute; left:0; right:0; top:100%; margin-top:6px;
    background: var(--surface);
    border:1px solid var(--border);
    border-radius:14px; box-shadow: var(--shadow-md);
    max-height:280px; overflow:auto; z-index:6;
  }
  .ac-item{ display:flex; flex-direction:column; gap:2px; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border); }
  .ac-item:last-child{ border-bottom:none; }
  .ac-item:hover{ background: color-mix(in oklab, var(--surface), var(--hover)); }
  .ac-title{ font-weight:700; }
  .ac-meta{ color: var(--muted); font-size:12px; }
/* Keyboard highlight for active suggestion */
.ac-item.active{
  background: color-mix(in oklab, var(--surface), var(--hover));
}

  .toast{
    position: fixed;
    left: 50%;
    bottom: calc(70px + env(safe-area-inset-bottom, 0px) + 18px);
    transform: translateX(-50%) translateY(14px);
    opacity: 0;
    transition:
      transform 240ms cubic-bezier(.22,1,.36,1),
      opacity 240ms cubic-bezier(.22,1,.36,1);
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 14px;
    box-shadow: var(--shadow-md);
    padding: 10px 14px;
    font-size: 14px;
    pointer-events: auto;   /* tap to dismiss */
    z-index: 20000;
  }
  .toast.show{
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }



  .popup-backdrop{ position:fixed; inset:0; background: rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:11000; }
  .popup-backdrop.show{ display:flex; }
  .popup{
    background: var(--surface);
    border:1px solid var(--chip-border);
    border-radius:16px; width:300px; padding:12px; box-shadow: var(--shadow-md);
  }
  .popup h3{ margin:6px 8px 10px; font-size:15px; }
  .popup .choices{ display:grid; gap:8px; }
  .popup .choices button{ width:100%; }

  /* Full-screen modal overlay */
  /* Full-screen modal overlay */
  .modal{
    position:fixed; inset:0;
    background: rgba(0,0,0,.4);
    display:none;
    /* Stretch child to full viewport instead of centering a box */
    align-items:stretch; justify-content:stretch;
    z-index:12000; /* above bottom nav and other overlays */
  }

  .modal.show{ display:flex; }
/* Extra bottom padding so last item never hides behind device safe area or nav height */
#addToListModal .modal-body{
  padding-bottom: calc(90px + env(safe-area-inset-bottom));
}


  /* Card fills the viewport; column layout for head/body/foot */
  .modal-card{
    width:100vw; height:100dvh;
    background: var(--surface);
    border:1px solid var(--border);
    border-radius:0;                     /* no rounded corners in full-screen */
    box-shadow: var(--shadow-md);
    display:flex; flex-direction:column; /* header, body, footer stack vertically */
  }

  /* Header stays at the top; body scrolls beneath */
  .modal-head{
    display:flex; align-items:center; justify-content:space-between;
    padding:14px 16px;
    border-bottom:1px solid var(--border);
    position:sticky; top:0; z-index:1;   /* keep close/delete visible */
    background: var(--surface);
  }

  /* Body takes remaining space and scrolls if long */
  .modal-body{
    flex:1 1 auto; min-height:0;
    padding:14px 16px;
    overflow:auto;
    display:flex; flex-direction:column; gap:16px;  /* ← add vertical spacing */
    max-height:none;
  }




  /* Footer is pinned to bottom of the card */
  .modal-foot{
    flex:0 0 auto;
    padding:12px 16px;
    border-top:1px solid var(--border);
    display:flex; gap:8px;
  }

  .input-row{ display:grid; gap:8px; grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
  /* — Prevent any image in the modal from overflowing horizontally — */
  .modal-body img{
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Extra safety: children can shrink within the modal body */
  .modal-body > * { min-width: 0; }

    .input-row > * { min-width: 0; }

    @media (max-width:560px){ .input-row{ grid-template-columns:1fr; } }

  .tag-row{ display:flex; flex-wrap:wrap; gap:8px; }
  .tagchip{
    padding:6px 10px; border:1px solid var(--chip-border); border-radius:999px; cursor:pointer; user-select:none;
    background: var(--chip); color: var(--text);
  }
  .tagchip.active{ background: var(--primary); color: var(--on-primary); border-color: var(--primary); }
  /* Prevent tag chips from causing horizontal overflow */
  #rmTags { max-width: 100%; }
  .tagchip{
    display: inline-flex;
    align-items: center;
    white-space: normal;         /* allow wrapping */
    overflow-wrap: anywhere;     /* break long words/strings */
    word-break: break-word;      /* extra safety for long tokens */
    max-width: 100%;
  }

  .preset-row{ display:flex; gap:8px; flex-wrap:wrap; }
  .preset{ padding:6px 10px; border:1px solid var(--chip-border); border-radius:999px; background: var(--chip); }
  .preset.active{ background: var(--primary); color: var(--on-primary); border-color: var(--primary); }
  /* Recipes search layout helpers */
  .rc-search { display:flex; flex-direction:column; gap:6px; }
  #rcSelected { max-width:100%; }
  #rcTopTags { max-width:100%; }
  #rcTagInput { max-width:100%; }

  .checklist{ display:grid; gap:8px; }
  .checkrow{
    display:grid; grid-template-columns:24px 1fr auto; align-items:center; gap:10px;
    border:1px solid var(--border); border-radius:12px; padding:8px 10px; background: var(--surface);
  }



    /* Reserve space so content isn't hidden behind the bottom nav */
  body { padding-bottom: calc(70px + env(safe-area-inset-bottom)); }

  /* =========================================================
    Bottom Navigation
    ========================================================= */
 
  .bottom-nav .tab {
    flex: 1;
    padding: 12px 0;
    border-radius: 12px;
    border: 1px solid var(--chip-border);
    background: var(--chip);
    font-weight: 700;
  }
  .bottom-nav .tab:hover { background: color-mix(in oklab, var(--chip), var(--hover)); }
  .bottom-nav .tab.active {
    background: var(--primary);
    border-color: var(--primary);
    color: var(--on-primary);
    box-shadow: 0 10px 24px color-mix(in oklab, var(--primary) 30%, transparent);
  }

  /* =========================================================
    Floating Theme Toggle (FAB)
    ========================================================= */
 .theme-fab {
    position: fixed;
    right: 16px;
    bottom: calc(70px + 16px + env(safe-area-inset-bottom)); /* sits above the nav */
    border-radius: 999px;
    padding: 10px 12px;
    border: 1px solid var(--border);
    background: var(--surface);
    box-shadow: var(--shadow-md);
    cursor: pointer;
}

/* Let .btn-pink control the color; only add stack/weight here */
#weeklyItemsFab {
  z-index: 15000;     /* on top of the bottom nav */
  border: none;       /* keep the pill clean */
  font-weight: 600;
}





  .theme-fab:hover  { background: color-mix(in oklab, var(--surface), var(--hover)); }
  .theme-fab:active { background: color-mix(in oklab, var(--surface), var(--press)); transform: translateY(1px); }
  .lightbox {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.8);
    display: none;              /* hidden by default */
    align-items: center;
    justify-content: center;
    z-index: 20000;
  }
  .lightbox.show {
    display: flex;              /* only visible when .show is applied */
  }
  .lightbox img {
    max-width: 90%;
    max-height: 80%;
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0,0,0,.6);
  }
  .lightbox .close {
    position: absolute;
    top: 20px;
    right: 20px;
    font-size: 28px;
    background: transparent;
    border: none;
    color: white;
    cursor: pointer;
  }
 /* Weekly Items modal */
#weeklyItemsModal {
  position: fixed;
  inset: 0;
  display: none;
  align-items: stretch;   /* let the sheet span full width */
  justify-content: flex-start; /* stick to the top */
  z-index: 12000;
}


#weeklyItemsModal.show {
  display: flex;
}
#weeklyItemsModal .backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.5);
}
#weeklyItemsModal .sheet {
  position: relative;
  width: 100%;
  height: calc(100vh - (var(--bottom-nav-height, 64px) + env(safe-area-inset-bottom)));
  background: var(--surface, #fff);
  color: inherit;
  border-radius: 0;           /* full-bleed */
  box-shadow: none;           /* no floating shadow for full-screen sheet */
  display: flex;
  flex-direction: column;
}

#weeklyItemsModal .header {
  padding: 12px;
  border-bottom: 1px solid var(--border, #ccc);
  font-size: 1.2em;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#weeklyItemsModal .body {
  flex: 1;
  overflow: auto;
  padding: 16px;
  position: relative; /* anchor for full-width suggestions */
}

#weeklyItemsModal .close {
  background: transparent;
  border: none;
  font-size: 1.5em;
  cursor: pointer;
}
/* Weekly Items modal: do not cross out checked items */
#weeklyItemsModal .item:has(input[type="checkbox"]:checked) .line1 {
  text-decoration: none !important;
  /* If you also want to keep the original text color, uncomment the next line */
  /* color: inherit !important; */
}

/* Floating action button for Weekly Items */
.fab {
  position: fixed;
  right: 16px;
  bottom: calc(var(--bottom-nav-height, 64px) + 16px);
  z-index: 20010;

  /* was: width:56px; height:56px; padding:0; line-height:56px; */
  height: 48px;
  padding: 0 16px;
  width: auto;
  border-radius: 999px;

  display: none;           /* JS controls visibility */
  align-items: center;
  justify-content: center;
  white-space: nowrap;     /* keep "Weekly Items" on one line */

  font-weight: 600;
  box-shadow: 0 10px 24px rgba(0,0,0,.25);
}

.fab.btn {
  line-height: normal;     /* don't force 56px line-height */
}

/* Full-width overlay suggestions in Weekly Items modal */
#wiAutoList {
  position: absolute;                 /* anchor to .body (which is position:relative) */
  left: 16px;                         /* match #weeklyItemsModal .body padding */
  right: 16px;                        /* match #weeklyItemsModal .body padding */
  top: 0;                             /* JS sets exact offset under the input */
  z-index: 20050;

  background: var(--modal-bg, #1a1a1a);
  border: 1px solid var(--border-color, #444);
  border-radius: 0.5rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  max-height: 240px;
  overflow-y: auto;
}
#wiAutoList .ac-item { padding: 8px 12px; cursor: pointer; }
#wiAutoList .ac-item:hover,
#wiAutoList .ac-item.active { background: var(--accent-bg, #ff0077); color: #fff; }




  </style>




    <!-- Firebase SDKs from CDN -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>


    <meta name="theme-color" content="#111"/>
    <link rel="manifest" href="manifest.webmanifest"/>
    <style id="step-autocomplete-css">
  .stepAutoList {
    position: absolute;
    z-index: 9999;
    max-height: 220px;
    overflow-y: auto;
    border: 1px solid var(--border-color, #444);
    background: var(--panel-bg, #111);
    color: var(--fg, #eee);
    border-radius: 10px;
    box-shadow: 0 10px 28px rgba(0,0,0,.35);
    width: 100%;
    padding: 6px 0;
    display: none;
  }
  .stepAutoItem {
    padding: 8px 12px;
    cursor: pointer;
    line-height: 1.2;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.95rem;
  }
  .stepAutoItem[aria-selected="true"] {
    background: rgba(255, 105, 180, .18); /* matches your neon/pink vibe */
    outline: 1px solid rgba(255, 105, 180, .35);
  }
</style>

  </head>
  <body>
    <!-- SVG sprite -->
    <svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden">
      <symbol id="i-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 7h16"/><path d="M9 7V5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/><path d="M6 7l1 12a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2l1-12"/><path d="M10 11v6M14 11v6"/>
      </symbol>
      <symbol id="i-cart" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 12.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/>
      </symbol>
      <symbol id="i-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3l2-3h8l2 3h3a2 2 0 0 1 2 2z"/>
        <circle cx="12" cy="13" r="4"/>
      </symbol>
    </svg>




    <main class="wrap">
      <div id="status" class="status"></div>

      <section id="listSection" class="card" data-list-collapsed="true">

        <div id="addRow" class="row">

                  <div style="flex:2; min-width:220px; position:relative;">

            <label>Item</label>
            <input id="itemName" type="text" placeholder="e.g., Milch, Bananen" />
                              <div id="autoList" class="ac-list" role="listbox" aria-label="Suggestions" style="display:none"></div>
            <div id="updateTag" class="updateTag" style="display:none"></div>

          </div>
          
          <div>
            <label>Qty</label>
            <input id="itemQty" class="qty" type="text" placeholder="e.g., 2, 500g" />
          </div>
          <div style="min-width:120px;">
            <label>Size</label>
            <input id="itemSize" class="size" type="text" placeholder="e.g., 500g, 1L" />
          </div>
          <div style="min-width:180px;">
            <label>Category</label>
            <select id="itemCategory" class="category">
              <option value="">— Select —</option>
              <option>Produce</option><option>Meat & Poultry</option><option>Fish & Seafood</option>
              <option>Dairy & Eggs</option><option>Bakery</option><option>Pantry</option>
              <option>Frozen</option><option>Beverages</option><option>Snacks & Confectionery</option>
              <option>Household & Cleaning</option><option>Personal Care & Health</option><option>Other</option>
            </select>
          </div>
          <div style="min-width:120px;">
            <label>Route</label>
            <input id="itemRoute" class="route" type="number" step="0.1" placeholder="e.g., 12" />
          </div>
          <div style="flex:1; min-width:200px;">
            <label>Notes</label>
            <input id="itemNotes" class="notes" type="text" placeholder="e.g., brand, ripeness" />
          </div>

          <!-- ONE Add photo button + filename (new-item form) -->
          <div style="min-width:220px;">
            <label>Photo</label>
            <div class="row" style="gap:8px; align-items:center;">
              <button id="newItemAddPhoto" type="button">Add photo</button>
              <span id="photoName" class="muted"></span>
                          <img id="photoPreview" class="thumb" style="display:none" alt="Preview">

            </div>
          </div>

          <div><button id="add" class="primary">Add</button></div>
        </div>

      <div id="toggleListItemsRow" class="row" style="justify-content: flex-end; margin-top: 6px;">
    <button id="toggleListItemsButton" class="pill" type="button" aria-pressed="false">🔽 Show items</button>
  </div>


        <div id="list" class="list" aria-live="polite"></div>
        <div id="empty" class="empty" style="display:none">
          <svg class="icon" aria-hidden="true"><use href="#i-cart"></use></svg>
          <div class="headline">Your list is empty</div>
          <div class="muted">Add your first item above.</div>
        </div>
      </section>
  <!-- ==================== Recipes View (shell) ==================== -->
  <section id="recipesView" class="card" style="display:none; margin-top:14px;">
    <div class="toolbar">
      <div class="group">
        <h2 style="margin:0">Recipes</h2>
        <span id="recipesCount" class="pill muted">0 recipes</span>
      </div>
          <div class="group" style="flex:1; min-width:260px;">
        <div id="rcSearchWrap" class="rc-search">
          <label for="rcTagInput" class="muted" style="font-size:12px;">Search by tags</label>

          <div class="rc-input-row" style="position:relative;">
            <input
              id="rcTagInput"
              type="text"
              placeholder="Start typing a tag or recipe name…"
              maxlength="24"
              enterkeyhint="done"
              style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--chip-border); background:var(--surface); color:var(--text);"
            />
            <button id="rcClearBtn" type="button" title="Clear filters" style="margin-left:8px; white-space:nowrap;">Clear</button>

            <div id="rcTagAC" class="ac-list" role="listbox" aria-label="Tag suggestions" style="display:none;"></div>
          </div>

          <div id="rcSelected" class="tag-row" style="margin-top:6px;"></div>

          <div class="muted" style="margin-top:6px; font-size:12px;">Common tags</div>
          <div id="rcTopTags" class="preset-row"></div>
        </div>
      </div>

<div class="group">
<button id="btnOpenAddRecipe" class="primary" type="button">Add Recipe</button>
<button id="importRecipe" class="primary" type="button" title="Import Recipe">Import Recipe</button>


</div>

    </div>

    <div id="recipeList" class="list" style="margin-top:12px;"></div>
  </section>



    </main>

    

    <!-- Global hidden file inputs (reused everywhere) -->
    <input id="fileChooser" type="file" accept="image/*" style="display:none" />
    <input id="fileCamera"  type="file" accept="image/*" capture="environment" style="display:none" />

    <!-- Small popup for photo choices -->
    <div id="photoPopup" class="popup-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="popup" role="document">
        <h3>Add a photo</h3>
        <div class="choices">
          <button id="ppTake"   type="button">📷 Take photo</button>
          <button id="ppChoose" type="button">🖼️ Choose photo</button>
          <button id="ppCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>
  <!-- ==================== Recipe Editor Modal (full-screen shell) ==================== -->
  <div id="recipeModal" class="modal" aria-hidden="true" style="position:fixed; inset:0; margin:0; padding:0; z-index:12000;">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="rmTitle"
        style="position:fixed; inset:0; margin:0; border-radius:0; display:flex; flex-direction:column; width:auto; height:auto;">
      
      <!-- Header stays at the very top -->
      <div class="modal-head"
          style="flex:0 0 auto; display:flex; justify-content:space-between; align-items:center; padding:12px; border-bottom:1px solid var(--border); position:sticky; top:0; background:var(--surface, #111); z-index:1;">
        <h3 id="rmTitle" style="margin:0;">Add Recipe</h3>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="rmDelete" class="danger" type="button" style="display:none">Delete</button>
          <button id="rmClose" type="button">✕</button>
        </div>
      </div>

      <!-- Body fills the rest and scrolls if needed -->
      <div class="modal-body" style="flex:1 1 auto; min-height:0; overflow:auto; padding:16px;">
        <!-- Meta -->
        <label>
          <div>Name</div>
          <input id="rmName" placeholder="e.g., Chicken Tikka" />
        </label>

        <div class="input-row">
          <label>
            <div>Base portions</div>
            <input id="rmBasePortions" type="number" min="1" value="2" />
          </label>



    <!-- Tags section (collapsible) -->
    <details id="rmTagsWrap" style="margin:0; width:100%;" data-collapsible="tags">
      <summary id="rmTagsSummary" style="list-style:none; cursor:pointer; display:flex; align-items:center; gap:8px;">
        <span style="font-weight:600; font-size:1.1rem;">Tags</span>
        <span id="rmTagsCaret" aria-hidden="true" style="margin-left:auto; transition:transform .2s;">▾</span>
      </summary>

      <div id="rmTagsBody" style="margin-top:8px;">
        <!-- Selected tags + Top 10 most-used tags will be rendered here -->
        <div id="rmTags" class="tag-row"></div>

        <!-- Add Tag control (inline input with autocomplete) -->
        <div id="rmTagAdderRow" style="margin-top:8px; position:relative;">
          <button id="rmAddTag" type="button">+ Add tag</button>
          <div id="rmTagAdderWrap" style="display:none; margin-top:8px; position:relative;">
      <input
    id="rmTagInput"
    type="text"
    placeholder="Start typing…"
    maxlength="24"
    enterkeyhint="done"
    style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--chip-border); background:var(--surface); color:var(--text);"
  />

            <div id="rmTagAC" class="ac-list" role="listbox" aria-label="Tag suggestions" style="display:none;"></div>
            <div class="muted" style="margin-top:6px; font-size:12px;">
              Press Enter to add. Up to 10 tags. New tags are created if no match.
            </div>
          </div>
        </div>
      </div>
    </details>
  </div>

  <script>
  (function(){
    const wrap  = document.getElementById('rmTagsWrap');
    if (!wrap || wrap._collapsibleInit) return;
    wrap._collapsibleInit = true;

    const caret = document.getElementById('rmTagsCaret');
    const KEY   = 'rmTags.open';

    // Restore last-open state
    try {
      const saved = localStorage.getItem(KEY);
      if (saved === '0') wrap.removeAttribute('open');
      if (saved === '1') wrap.setAttribute('open','');
    } catch(e){}

    const updateCaret = () => {
      if (!caret) return;
      caret.style.transform = wrap.hasAttribute('open') ? 'rotate(0deg)' : 'rotate(-90deg)';
    };

    updateCaret();

    wrap.addEventListener('toggle', () => {
      updateCaret();
      try { localStorage.setItem(KEY, wrap.hasAttribute('open') ? '1' : '0'); } catch(e){}
    });
  })();
  </script>



        <!-- Cover photo -->
        <div>
          <div>Cover photo</div>
          <div class="row" style="gap:8px; align-items:center;">
            <button id="rmCoverBtn" type="button">Add/Change cover</button>
            <span id="rmCoverName" class="muted"></span>
            <img id="rmCoverPreview" class="thumb" style="display:none" alt="Cover preview">
            <button id="rmCoverRemove" type="button" style="display:none">Remove</button>
          </div>
        </div>
  <!-- Ingredients section (collapsible) -->
  <details id="rmIngredientsWrap" style="margin:0; width:100%;" data-collapsible="ingredients">
    <summary id="rmIngredientsSummary" style="list-style:none; cursor:pointer; display:flex; align-items:center; gap:8px;">
      <span style="font-weight:600; font-size:1.1rem;">Ingredients</span>
      <span id="rmIngredientsCaret" aria-hidden="true" style="margin-left:auto; transition:transform .2s;">▾</span>
    </summary>

    <div id="rmIngredientsBody" style="margin-top:0;">
      <!-- Ingredient list container -->
      <div id="rmIngredients">
        <!-- Ingredient Row -->
        <div class="ing-row">
          <!-- Row 1 -->
          <div class="ing-name-wrap" style="position:relative;">
            <textarea class="ing-name" placeholder="Ingredient name"></textarea>
            <div class="ac-list ing-ac" role="listbox" aria-label="Suggestions" style="display:none"></div>
          </div>
          <input class="ing-qty" type="text" placeholder="Qty" />
          <input class="ing-size" type="text" placeholder="Size" />

          <!-- Row 2 -->
          <div></div> <!-- empty space under Name -->
          <textarea class="ing-notes" placeholder="Notes"></textarea>
          <button class="ing-del" type="button" title="Remove">✕</button>
        </div>
      </div>

      <!-- Add Ingredient button (now below all rows) -->
      <div style="margin-top:12px;">
        <button id="rmAddIngredient" type="button">+ Add Ingredient</button>
      </div>
    </div>
  </details>

  <script>
  (function(){
    const wrap = document.getElementById('rmIngredientsWrap');
    if (!wrap || wrap._collapsibleInit) return;
    wrap._collapsibleInit = true;

    const caret = document.getElementById('rmIngredientsCaret');
    const KEY = 'rmIngredients.open';

    // Restore last-open state for this editor session
    try {
      const saved = localStorage.getItem(KEY);
      if (saved === '0') wrap.removeAttribute('open');
      if (saved === '1') wrap.setAttribute('open','');
    } catch(e){}

    const updateCaret = () => {
      if (!caret) return;
      caret.style.transform = wrap.hasAttribute('open') ? 'rotate(0deg)' : 'rotate(-90deg)';
    };

    updateCaret();

    // Persist and update ARIA/visuals on toggle
    wrap.addEventListener('toggle', () => {
      updateCaret();
      try { localStorage.setItem(KEY, wrap.hasAttribute('open') ? '1' : '0'); } catch(e){}
    });
  })();
  </script>


  <!-- Steps section (collapsible) -->
  <details id="rmSteps" style="margin:0; width:100%;" data-collapsible="steps">
    <summary id="rmStepsSummary" style="list-style:none; cursor:pointer; display:flex; align-items:center; gap:8px;">
      <span style="font-weight:600; font-size:1.1rem;">Steps</span>
      <span id="rmStepsCaret" aria-hidden="true" style="margin-left:auto; transition:transform .2s;">▾</span>
    </summary>

    <div id="rmStepsBody" style="margin-top:8px;">
      <div id="rmStepsList"></div>
      <div style="margin-top:12px;">
        <button id="rmAddStep" type="button">+ Add Step</button>
      </div>
    </div>
  </details>

  <script>
  (function(){
    const wrap = document.getElementById('rmSteps');
    if (!wrap || wrap._collapsibleInit) return;
    wrap._collapsibleInit = true;

    const caret = document.getElementById('rmStepsCaret');
    const KEY = 'rmSteps.open';

    // Restore last-open state for this editor session
    try {
      const saved = localStorage.getItem(KEY);
      if (saved === '0') wrap.removeAttribute('open');
      if (saved === '1') wrap.setAttribute('open','');
    } catch(e){}

    const updateCaret = () => {
      if (!caret) return;
      caret.style.transform = wrap.hasAttribute('open') ? 'rotate(0deg)' : 'rotate(-90deg)';
    };

    updateCaret();

    // Persist and update ARIA/visuals on toggle
    wrap.addEventListener('toggle', () => {
      updateCaret();
      try { localStorage.setItem(KEY, wrap.hasAttribute('open') ? '1' : '0'); } catch(e){}
    });
  })();
  </script>


      </div>
      <div class="modal-foot">

        <div style="flex:1"></div>
        <button id="rmSave" class="primary" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- ==================== Add Recipe to List Modal (shell) ==================== -->
  <div id="addToListModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="atlTitle">
      <div class="modal-head">
  <h3 id="atlTitle" style="margin:0;">Add Recipe to List</h3>
  <div style="display:flex; gap:8px; align-items:center;">
    <button id="atlAdd" class="primary" type="button" title="Add all selected to shopping list">Add to Shopping List</button>
    <button id="atlClose" type="button">✕</button>
  </div>
</div>

      <div class="modal-body">
        <div>
          <div>Portions</div>
          <div class="row" style="gap:8px; align-items:center;">
            <button id="atlDec" type="button">–</button>
            <input id="atlServings" type="number" min="1" value="2" style="width:90px; text-align:center;">
            <button id="atlInc" type="button">+</button>
          </div>
          <div class="preset-row" style="margin-top:8px;">
            <button class="preset" data-x="1">1×</button>
            <button class="preset" data-x="1.5">1.5×</button>
            <button class="preset" data-x="2">2×</button>
          </div>
        </div>

        <label style="margin-top:8px;">
          <input type="checkbox" id="atlSelectAll" checked> Select/Deselect all
        </label>

        <div id="atlList" class="checklist"></div>
      </div>
  <div class="modal-foot" style="display:none"></div>

    </div>
  </div>


  
  <script>
      // Register service worker for PWA installability
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js').catch(()=>{});
        });
      }
    </script>
    <script>
      // === Firebase ===
      const firebaseConfig = {
        apiKey: "AIzaSyAljIHyxs-pvJRi2pRzs2fsPARCQLFQ2Kg",
        authDomain: "grocery-list-77298.firebaseapp.com",
        projectId: "grocery-list-77298",
        storageBucket: "grocery-list-77298.firebasestorage.app", // If uploads fail, set to YOUR_PROJECT_ID.appspot.com
        messagingSenderId: "1089310382899",
        appId: "1:1089310382899:web:03b24e12f3a9e5c6d63c46"
      };

      let app, auth, db, storage;
      try {
        app = firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        db = firebase.firestore();
        storage = firebase.storage();
        db.enablePersistence({ synchronizeTabs: true }).catch(()=>{});
      } catch (e) { console.error(e); }

      const $ = id => document.getElementById(id);
      const listEl = $('list');
      const emptyEl = $('empty');
      // ——— skeleton placeholders for first paint ———
  let _listHasFirstSnapshot = false;
  let _recipesHasFirstSnapshot = false;

  function showListSkeleton(){
    if (!listEl) return;
    if (listEl._skeletonMounted) return;
    listEl._skeletonMounted = true;
    const frag = document.createDocumentFragment();
    for (let i=0;i<4;i++){
      const sk = document.createElement('div');
      sk.className = 'item skeleton';
      sk.innerHTML = `
        <div class="left"><div class="sk-box" style="width:18px;height:18px;border-radius:4px;"></div></div>
        <div class="line1">
          <div class="sk-line" style="width:60%;height:14px;"></div>
          <div class="meta" style="margin-top:8px;">
            <div class="sk-chip" style="width:72px;height:12px;"></div>
            <div class="sk-chip" style="width:48px;height:12px;"></div>
          </div>
        </div>
        <div class="actions"><div class="sk-btn" style="width:56px;height:28px;border-radius:8px;"></div></div>
      `;
      frag.appendChild(sk);
    }
    listEl.innerHTML = '';
    listEl.appendChild(frag);
    if (emptyEl) emptyEl.style.display = 'none';
  }
  function hideListSkeleton(){
    if (!listEl || !listEl._skeletonMounted) return;
    listEl._skeletonMounted = false;
    listEl.innerHTML = '';
  }

      // ——— micro-debounced renderers ———
  let _rafItems = 0, _rafRecipes = 0, _pendingItems = null, _pendingRecipes = null;
  function scheduleRenderItems(items){
    _pendingItems = items;
    if (_rafItems) return;
    _rafItems = requestAnimationFrame(() => {
      _rafItems = 0;
      const data = _pendingItems; _pendingItems = null;
      render(data);
    });
  }
  function scheduleRenderRecipes(arr){
    _pendingRecipes = arr;
    if (_rafRecipes) return;
    _rafRecipes = requestAnimationFrame(() => {
      _rafRecipes = 0;
      const data = _pendingRecipes; _pendingRecipes = null;
      renderRecipes(data);
    });
  }

    let sortModeEl = null;
  let filterModeEl = null;

      const statusEl = $('status');
  // Tabs + filter group
  const tabListBtn = $('tabList');
  const tabShoppingBtn = $('tabShopping');
  const tabRecipesBtn = $('tabRecipes');
  const filterGroup = $('filterGroup');

  // Tab state
  let activeTab = 'list';




      // Preferences

      // Preferences

      let user = null;
      let household = localStorage.getItem('household') || '';
      let unsubList = null;
      let lastSnapshotItems = [];
let liveListQuery = ''; // live filter typed in the Item box
let catalogCache = new Map();

// ===== List row edit session tracking (persists through re-renders) =====
window.currentEditingId = window.currentEditingId || null;   // id of the row in edit mode
window.editDirty       = window.editDirty       || new Set(); // set of ids that have unsaved edits (UI label shows “Save”)

      let lastAddedId = null;
  let unsubRecipes = null;
  let lastSnapshotRecipes = [];


      // ==== Recipes search state and helpers ====
  let rcQuery = { tagsMode: 'AND', tags: [], name: '' };
      try {
    const saved = JSON.parse(localStorage.getItem('recipes_query') || '{}');
    if (saved && Array.isArray(saved.tags)) {
      rcQuery.tags = saved.tags.map(rcNormTag);
    }
    if (saved && typeof saved.name === 'string') {
      rcQuery.name = rcNormTag(saved.name);
    }
  } catch {}

  function saveRcQuery(){
    try { localStorage.setItem('recipes_query', JSON.stringify({ tagsMode: rcQuery.tagsMode, tags: rcQuery.tags, name: rcQuery.name || '' })); } catch {}
  }

  let rcTagIndex = [];


  // Normalize tag text
  function rcNormTag(s){
    return String(s || '').trim().toLowerCase();
  }

  // Build {tag,count} list across recipes
  function buildRecipeTagIndex(arr){
    const counts = {};
    for (const r of (arr || [])){
      if (Array.isArray(r.tags)){
        for (const t of r.tags){
          const k = rcNormTag(t);
          if (!k) continue;
          counts[k] = (counts[k] || 0) + 1;
        }
      }
    }
    const list = Object.entries(counts).map(([tag, count]) => ({ tag, count }));
    list.sort((a,b) => (b.count - a.count) || a.tag.localeCompare(b.tag));
    return list;
  }

  // Render the search UI (chips, suggestions) and wire events once
  function renderRecipeSearchUI(){
    const selectedRow = $('rcSelected');
    const topRow = $('rcTopTags');
    const input = $('rcTagInput');
    const ac = $('rcTagAC');
    const clear = $('rcClearBtn');

    if (!selectedRow || !topRow || !input || !ac || !clear) return;

    // Selected tag chips
    selectedRow.innerHTML = '';
    for (const t of rcQuery.tags){
      const chip = document.createElement('div');
      chip.className = 'tagchip active';
      chip.textContent = t;
      chip.title = 'Remove';
      chip.onclick = () => {
    rcQuery.tags = rcQuery.tags.filter(x => x !== t);
  saveRcQuery();
  renderRecipeSearchUI();
  applyRecipeFilter();

      };
      selectedRow.appendChild(chip);
    }

    // Top 10 common tags
    topRow.innerHTML = '';
    for (const { tag, count } of rcTagIndex.slice(0, 10)){
      const chip = document.createElement('div');
      chip.className = 'preset' + (rcQuery.tags.includes(tag) ? ' active' : '');
      chip.textContent = `${tag} (${count})`;
      chip.title = 'Add filter';
   chip.onclick = () => {
        const i = rcQuery.tags.indexOf(tag);
        if (i >= 0) {
          rcQuery.tags.splice(i, 1);
        } else {
          rcQuery.tags.push(tag);
        }
        saveRcQuery();
        renderRecipeSearchUI();
        applyRecipeFilter();
      };
      topRow.appendChild(chip);
    }

    // Wire input and AC once
    if (!input._wired){
      input._wired = true;

      input.addEventListener('input', () => {
        const qRaw = input.value || '';
        const q = rcNormTag(qRaw);

        // Live name query (persist & filter)
        rcQuery.name = q;
        saveRcQuery();
        applyRecipeFilter();

        // Tag suggestions (same as before)
        const tagSugs = q
          ? rcTagIndex.map(x => x.tag).filter(t => t.startsWith(q) && !rcQuery.tags.includes(t)).slice(0, 8)
          : [];

        // Recipe name suggestions (by contains)
        const nameSugs = q && Array.isArray(lastSnapshotRecipes)
          ? Array.from(new Set(
              lastSnapshotRecipes
                .map(r => (r && r.name) ? String(r.name) : '')
                .filter(n => n && n.toLowerCase().includes(q))
            )).slice(0, 8)
          : [];

        // Build AC list (tags first, then names)
        const parts = [];
        tagSugs.forEach(s => parts.push(`<div class="ac-item" role="option" data-tag="${s}"><div>${s}</div></div>`));
        nameSugs.forEach(n => parts.push(`<div class="ac-item" role="option" data-name="${n}"><div>🔎 ${n}</div></div>`));

        ac.innerHTML = parts.join('');
        ac.style.display = parts.length ? 'block' : 'none';
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter'){
          e.preventDefault();
          const v = rcNormTag(input.value);
          if (v){
            // Keep existing behavior: Enter adds a tag (name filtering already happens live)
            if (!rcQuery.tags.includes(v)) rcQuery.tags.push(v);
  saveRcQuery();
  input.value = '';
  const q = '';
  rcQuery.name = q;
  saveRcQuery();
  const acList = $('rcTagAC');
  if (acList){ acList.style.display = 'none'; acList.innerHTML = ''; }

            renderRecipeSearchUI();
            applyRecipeFilter();
          }
        }
        if (e.key === 'Escape'){
          input.value = '';
          rcQuery.name = '';
          saveRcQuery();
          ac.style.display = 'none';
          ac.innerHTML = '';
          applyRecipeFilter();
        }
      });

      ac.addEventListener('click', (e) => {
        const el = e.target.closest('.ac-item');
        if (!el) return;
        const t = el.getAttribute('data-tag');
        const n = el.getAttribute('data-name');

        if (t && !rcQuery.tags.includes(t)){
        rcQuery.tags.push(t);
  saveRcQuery();
  input.value = '';
  rcQuery.name = '';
  saveRcQuery();
  ac.style.display = 'none';

          ac.innerHTML = '';
          renderRecipeSearchUI();
          applyRecipeFilter();
          return;
        }

        if (n){
          // Click on a name suggestion: set input to that name and filter by it
          input.value = n;
          rcQuery.name = rcNormTag(n);
          saveRcQuery();
          ac.style.display = 'none';
          ac.innerHTML = '';
          applyRecipeFilter();
          return;
        }
      });

      clear.addEventListener('click', () => {
      rcQuery.tags = [];
  saveRcQuery();
  input.value = '';
  rcQuery.name = '';
  saveRcQuery();
  const acList = $('rcTagAC');

        if (acList){
          acList.style.display = 'none';
          acList.innerHTML = '';
        }
        renderRecipeSearchUI();
        applyRecipeFilter();
      });
    }
  }


  // Apply filters to recipes and call the existing renderer
  function applyRecipeFilter(){
    const source = Array.isArray(lastSnapshotRecipes) ? lastSnapshotRecipes : [];
    const tags = rcQuery.tags || [];
    const nameQ = rcQuery.name ? rcQuery.name : '';

    let filtered = source;

    // Tag filter (AND/OR)
    if (tags.length){
      if (rcQuery.tagsMode === 'AND'){
        filtered = filtered.filter(r => {
          const rt = Array.isArray(r.tags) ? r.tags.map(rcNormTag) : [];
          return tags.every(t => rt.includes(t));
        });
      } else {
        filtered = filtered.filter(r => {
          const rt = Array.isArray(r.tags) ? r.tags.map(rcNormTag) : [];
          return tags.some(t => rt.includes(t));
        });
      }
    }

    // Name filter (contains, case-insensitive)
    if (nameQ){
      filtered = filtered.filter(r => {
        const nl = (r && (r.nameLower || (r.name || '').toLowerCase())) || '';
        return nl.includes(nameQ);
      });
    }

    renderRecipes(filtered);
  }


  // Entry point used by subscribeRecipes and by guards
  function setRecipesAndRepaint(arr){
    lastSnapshotRecipes = Array.isArray(arr) ? arr : [];
    rcTagIndex = buildRecipeTagIndex(lastSnapshotRecipes);
    renderRecipeSearchUI();
    applyRecipeFilter();
  }


      // New-item pending photo
      let newItemPhotoFile = null;
          // === Autocomplete / Update mode state ===
      let selectedItemId = null;
      let selectedItemInitialChecked = false;
      let selectedItemPhotoPath = null;

      const nameInput = $('itemName');
const autoList = $('autoList');
// Keyboard highlight index for Lists AC
let listAcActiveIndex = -1;


      function escapeHtml(s){ 
        return (s||'').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[c]));
      }

      function suggestionMeta(it){
        const parts = [];
        if (it.category) parts.push(it.category);
        if (it.size) parts.push(it.size);
        if (it.routeOrder !== '' && !isNaN(parseFloat(it.routeOrder))) parts.push('Route ' + it.routeOrder);
        return parts.join(' • ');
      }

  function showSuggestions(q){
  if (!autoList) return;
  q = (q||'').trim().toLowerCase();
  if (!q){ autoList.style.display='none'; autoList.innerHTML=''; return; }

  // Only show items that START with the typed letters
  const matches = lastSnapshotItems
    .filter(it => (it.name||'').toLowerCase().startsWith(q))
    .sort((a,b)=> (a.name||'').localeCompare(b.name||''))
    .slice(0,8);

  if (!matches.length){ autoList.style.display='none'; autoList.innerHTML=''; return; }

  autoList.innerHTML = '';
  for (const it of matches){
    const row = document.createElement('div');
    row.className = 'ac-item';
    row.setAttribute('role','option');
    row.dataset.id = it.id;
    row._item = it;

    const safe = (s) => (s||'').replace(/[&<>\"']/g, c => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));

    const photoHtml = it.photoUrl
      ? `<img src="${safe(it.photoUrl)}" alt="" class="thumb" style="width:38px;height:38px;border-radius:6px;object-fit:cover;margin-right:8px;">`
      : '';

    const qtyTxt = safe(it.qty || '');
    const sizeTxt = safe(it.size || '');
    const notesTxt = safe(it.notes || '');
    const metaTxt = [qtyTxt, sizeTxt].filter(Boolean).join(' • ');
    const catTxt = safe(it.category || '');

    row.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;">
        ${photoHtml}
        <div style="flex:1;overflow:hidden;">
          <div style="font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${safe(it.name||'')}</div>
          <div class="muted" style="font-size:0.85em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
            ${metaTxt ? metaTxt + (catTxt ? ' • '+catTxt : '') : (catTxt || '')}
          </div>
          ${notesTxt ? `<div class="muted" style="font-size:0.8em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${notesTxt}</div>` : ''}
        </div>
      </div>
    `;

    autoList.appendChild(row);
  }

  autoList.style.display = 'block';
}

      
  // ===== Recipe Modal Ingredient Name Autocomplete =====
  // Uses the already-available lastSnapshotItems[] as the suggestion source.

  function buildIngMatches(q){
    q = (q||'').trim().toLowerCase();
    if (!q) return [];
    // same matching rules as list tab: starts-with first, then includes
    const matches = lastSnapshotItems
      .filter(it => (it.name||'').toLowerCase().includes(q))
      .sort((a,b)=>{
        const an=(a.name||'').toLowerCase(), bn=(b.name||'').toLowerCase();
        const as = an.startsWith(q) ? 0 : 1;
        const bs = bn.startsWith(q) ? 0 : 1;
        if (as !== bs) return as - bs;
        return an.localeCompare(bn);
      })
      .slice(0,8);
    return matches;
  }

  function renderIngAC(listEl, matches, activeIndex = -1){
  listEl.innerHTML = '';
  if (!matches || !matches.length){
    listEl.style.display = 'none';
    return;
  }
  matches.forEach((it, i) => {
    const row = document.createElement('div');
    row.className = 'ac-item' + (i === activeIndex ? ' active' : '');
    row.setAttribute('role','option');
    row.setAttribute('aria-selected', i === activeIndex ? 'true' : 'false');
    row._item = it;
    row.innerHTML =
      '<div class="ac-title">'+escapeHtml(it.name||'')+'</div>' +
      '<div class="ac-meta">'+escapeHtml(suggestionMeta(it))+'</div>';
    listEl.appendChild(row);
  });
  listEl.style.display = 'block';
}


  function applyIngSuggestion(row, it){
    // Fill this ingredient row with the selected item's known data
    const name  = row.querySelector('.ing-name');
    const size  = row.querySelector('.ing-size');
    // Leave qty/notes alone; user-specific
    if (name) name.value = it.name || '';
    if (size && !size.value) size.value = it.size || '';
  }

  function bindIngredientAC(row){
  const wrap   = row.querySelector('.ing-name-wrap');
  const input  = row.querySelector('.ing-name');
  const acList = row.querySelector('.ing-ac');
  if (!input || !acList || !wrap) return;

  let activeIndex = -1;
  let activeMatches = [];

  const closeAC = () => { acList.style.display = 'none'; acList.innerHTML = ''; activeIndex = -1; activeMatches = []; };

  const ensureVisible = () => {
    const items = acList.querySelectorAll('.ac-item');
    if (activeIndex < 0 || activeIndex >= items.length) return;
    const el = items[activeIndex];
    el?.scrollIntoView({ block: 'nearest' });
  };

  input.addEventListener('input', () => {
    const q = input.value;
    activeMatches = buildIngMatches(q);
    // Default to first item highlighted when there are results
    activeIndex = activeMatches.length ? 0 : -1;
    renderIngAC(acList, activeMatches, activeIndex);
    ensureVisible();
  });


    // Click on a suggestion → apply to this row
  acList.addEventListener('mousedown', (e) => {
    const el = e.target.closest('.ac-item');
    if (!el || !el._item) return;
    applyIngSuggestion(row, el._item);
    closeAC();
    e.preventDefault(); // keep focus in the textarea
  });

  // Close when clicking outside this wrapper
  document.addEventListener('click', (e) => {
    if (!wrap.contains(e.target)) closeAC();
  });

  // Keyboard controls: Esc / ArrowUp / ArrowDown / Enter
  input.addEventListener('keydown', (e) => {
    const open = acList.style.display === 'block';
    if (e.key === 'Escape'){
      closeAC();
      return;
    }
    if (!open || !activeMatches.length) return;

    if (e.key === 'ArrowDown'){
      e.preventDefault();
      activeIndex = (activeIndex + 1) % activeMatches.length;
      renderIngAC(acList, activeMatches, activeIndex);
      ensureVisible();
    } else if (e.key === 'ArrowUp'){
      e.preventDefault();
      activeIndex = (activeIndex - 1 + activeMatches.length) % activeMatches.length;
      renderIngAC(acList, activeMatches, activeIndex);
      ensureVisible();
    } else if (e.key === 'Enter'){
      if (activeIndex >= 0){
        e.preventDefault();
        applyIngSuggestion(row, activeMatches[activeIndex]);
        closeAC();
      }
    }
  });

  }

  // Bind AC to the initial static row present in HTML (inside #rmIngredients)
  (function bindInitialIngredientRows(){
    const container = document.getElementById('rmIngredients');
    if (!container) return;
    container.querySelectorAll('.ing-row').forEach(row => bindIngredientAC(row));
  })();

      function clearUpdateMode(){
        selectedItemId = null;
        selectedItemInitialChecked = false;
        selectedItemPhotoPath = null;
        const tag = $('updateTag'); if (tag){ tag.style.display='none'; tag.innerHTML=''; }
        setPhotoPreview('');
      }

      function applySuggestion(item){
        selectedItemId = item.id;
        selectedItemInitialChecked = !!item.checked;
        selectedItemPhotoPath = item.photoPath || null;

        $('itemName').value = item.name || '';
        $('itemQty').value = item.qty || '';
        $('itemSize').value = item.size || '';
        $('itemNotes').value = item.notes || '';
        $('itemCategory').value = item.category || '';
        $('itemRoute').value = (item.routeOrder === '' || item.routeOrder === undefined || item.routeOrder === null) ? '' : item.routeOrder;

        setNewPhotoFile(null);
        setPhotoPreview(item.photoUrl || '');

        const tag = $('updateTag');
        if (tag){
          tag.innerHTML = 'Updating: <strong>'+escapeHtml(item.name||'')+'</strong> <button type="button" id="cancelUpdate" aria-label="Cancel">×</button>';
          tag.style.display = 'inline-flex';
          const cancel = $('cancelUpdate'); if (cancel) cancel.onclick = () => clearUpdateMode();
        }

        if (autoList){ autoList.style.display='none'; autoList.innerHTML=''; }
        const qtyField = $('itemQty'); if (qtyField) qtyField.focus();
      }

     // Wire events
      if (nameInput){
        nameInput.addEventListener('input', () => {
          const v = nameInput.value || '';
          showSuggestions(v);                     // existing autocomplete
          liveListQuery = v;                      // update live filter
          scheduleRenderItems(lastSnapshotItems || []); // re-render list with live filter
          // reset keyboard highlight whenever the list refreshes
          listAcActiveIndex = -1;
          const items = autoList ? autoList.querySelectorAll('.ac-item') : [];
          items.forEach((it) => it.classList.remove('active'));
        });

        // Click outside → hide
        document.addEventListener('click', (e) => {
          if (!autoList) return;
          if (e.target === nameInput || (e.target.closest && e.target.closest('#autoList'))) return;
          autoList.style.display='none';
          autoList.innerHTML='';
          listAcActiveIndex = -1;
        });
// // Click/press on a suggestion → apply
// if (autoList){
//   autoList.addEventListener('mousedown', (e) => {
//     const row = e.target.closest('.ac-item');
//     if (!row || !row._item) return;
//     e.preventDefault();
//     applySuggestion(row._item);
//     listAcActiveIndex = -1;
//   });
// }
// ✅ Fixed version – waits for DOM before wiring
document.addEventListener('DOMContentLoaded', () => {
  const autoList = document.getElementById('autoList');
  if (autoList){
    autoList.addEventListener('mousedown', (e) => {
      const row = e.target.closest('.ac-item');
      if (!row || !row._item) return;
      e.preventDefault();
      applySuggestion(row._item);
      listAcActiveIndex = -1;
    });
  }
});


        // Keyboard: ArrowUp/Down to move, Enter to pick
        nameInput.addEventListener('keydown', (e) => {
          if (!autoList || autoList.style.display !== 'block') return;
          const items = autoList.querySelectorAll('.ac-item');
          if (!items.length) return;

          if (e.key === 'ArrowDown'){
            e.preventDefault();
            listAcActiveIndex = (listAcActiveIndex + 1) % items.length;
          } else if (e.key === 'ArrowUp'){
            e.preventDefault();
            listAcActiveIndex = (listAcActiveIndex - 1 + items.length) % items.length;
          } else if (e.key === 'Enter'){
            if (listAcActiveIndex >= 0){
              e.preventDefault();
              const chosen = items[listAcActiveIndex];
              if (chosen && chosen._item){
                applySuggestion(chosen._item);
                listAcActiveIndex = -1;
              }
            }
            return;
          } else {
            return; // ignore other keys
          }

          // update visual focus
          items.forEach((it, i) => it.classList.toggle('active', i === listAcActiveIndex));
          items[listAcActiveIndex]?.scrollIntoView({ block: 'nearest' });
        });
      }

     








    function setHouseholdUI() {
    const householdInput = $('household');
    const householdView  = $('householdView');

    if (householdInput) householdInput.value = household;
    if (householdView)  householdView.textContent = household || '–';
  }

      setHouseholdUI();

      function setControlsEnabled(enabled){
        ['add','clearChecked','sortMode','filterMode','itemName','itemQty','itemCategory','itemRoute','itemSize','itemNotes','newItemAddPhoto']
          .forEach(id => { const n = $(id); if (!n) return; n.disabled = !enabled; n.classList.toggle('disabled', !enabled); });
      }

      function updateStatus(){
    // Clear safely
    statusEl.textContent = '';
    const add = (txt) => {
      const s = document.createElement('span');
      s.innerText = txt;
      if (statusEl.childNodes.length) statusEl.append(' • ');
      statusEl.append(s);
    };

    if (!auth || !db) add('SDK not loaded');
    add(auth && auth.currentUser ? 'Signed in' : 'Not signed in');
    add('household: ' + (household || '—'));

    const ready = !!auth && !!db && !!auth.currentUser && !!household;
    setControlsEnabled(ready);
  }




      auth && auth.onAuthStateChanged(u => {
    user = u;
        
  const _si = $('signIn');
    const _so = $('signOut');
    if (_si) _si.style.display = u ? 'none' : 'inline-block';
    if (_so) _so.style.display = u ? 'inline-block' : 'none';

    // Subscribe immediately (renders from cache fast)
    subscribeList();
    subscribeRecipes();

    // Push non-critical warming to idle so it never blocks initial render
    (window.requestIdleCallback || function(cb){ return setTimeout(cb, 0); })(() => {
      try { warmCatalog(); } catch {}
    });

    updateStatus();
  });

  // === ensure parent /lists/{household} exists and is owned by current user ===
  // Ensure /lists/{household} exists and add current user to members
  async function ensureHouseholdDoc(hId) {
  const hid = String(hId || household || '').trim();
  if (!auth || !auth.currentUser || !hid) return;

  try {
    const uid = auth.currentUser.uid;

    // Data structure: members is a map of uid:true
    const data = {
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      members: {}
    };
    data.members[uid] = true;

    // Merge so it adds the user without overwriting existing members
    await db.collection('lists').doc(hid).set(data, { merge: true });
  } catch (e) {
    console.error('ensureHouseholdDoc failed', e);
  }
}


  async function subscribeList(){
    if (unsubList) { unsubList(); unsubList = null; }
    if (!auth || !auth.currentUser || !household) { render([]); return; }

    try {
      // Make sure the household doc exists and includes this user BEFORE any read
      await ensureHouseholdDoc();

      // Now it is safe to subscribe
      unsubList = db.collection('lists').doc(household).collection('items')
        .onSnapshot((snap) => {
          const items = [];
          snap.forEach(d => items.push({ id: d.id, ...d.data() }));
          lastSnapshotItems = items;
          hideListSkeleton();
          scheduleRenderItems(items);
        }, (err) => {
          console.error(err);
          alert('Cannot read list. Check Firestore rules and that Firestore is enabled.');
        });

    } catch (e) {
      console.error('subscribeList bootstrap failed', e);
      alert('Cannot read list. Check Firestore rules and that Firestore is enabled.');
    }
  }


async function subscribeRecipes(){
    if (unsubRecipes) { unsubRecipes(); unsubRecipes = null; }
    if (!auth || !auth.currentUser || !household) { setRecipesAndRepaint([]); return; }

    try {
      // Make sure the household doc exists and includes this user BEFORE any read
      await ensureHouseholdDoc();

      // Now it is safe to subscribe
      unsubRecipes = db.collection('recipes').doc(household).collection('recipes')
        .where('deletedAt','==', null)
        .onSnapshot((snap) => {
          const arr = [];
          snap.forEach(d => arr.push({ id: d.id, ...d.data() }));
          arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
          // This already updates lastSnapshotRecipes, rebuilds tags, and reapplies filters.
          setRecipesAndRepaint(arr);
        }, (err) => {
          console.error(err);
          alert('Cannot read recipes. Check Firestore rules.');
        });

    } catch (e) {
      console.error('subscribeRecipes bootstrap failed', e);
      alert('Cannot read recipes. Check Firestore rules.');
    }
  }







      function warmCatalog(){
        if (!auth || !auth.currentUser || !household) return;
        db.collection('catalog').doc(household).collection('items').get().then(qs => {
          catalogCache.clear();
          qs.forEach(doc => {
            const d = doc.data();
            catalogCache.set((d.name||'').toLowerCase(), { category: d.category||'', routeOrder: d.routeOrder ?? '' });
          });
        }).catch(()=>{});
      }


  function render(items){
    // Start from all items
    let filtered = items;

    // Cache latest full items snapshot for instant startup
  const _ric = window.requestIdleCallback || function(cb){ return setTimeout(cb, 0); };
  _ric(() => {
    try { localStorage.setItem('cache_items', JSON.stringify(items || [])); } catch {}
  });


    if (activeTab === 'shopping') {
      // Shopping tab: ONLY unchecked items
      filtered = items.filter(i => !i.checked);
    } else {
      // List tab: obey the dropdown filter (only all / checked / unchecked)
      const fm = (filterModeEl && filterModeEl.value) || 'all';
      if (fm === 'unchecked') {
        filtered = items.filter(i => !i.checked);
      } else if (fm === 'checked') {
        filtered = items.filter(i => !!i.checked);
      }
      // Apply live query from the Item input (case-insensitive STARTS-WITH match)
      const q = (liveListQuery || '').trim().toLowerCase();
      if (q) {
        filtered = filtered.filter(i => (i.name || '').toLowerCase().startsWith(q));
      }

    }


    // Render by chosen sort mode
const mode = (activeTab === 'shopping')
  ? (localStorage.getItem('sortMode_shopping') || 'route')
  : (localStorage.getItem('sortMode_list')     || 'route');
    if (mode === 'category') {
      renderGroupedByCategory(filtered);
    } else if (mode === 'name') {
      // Flat list sorted by name (A→Z)
      const byName = [...filtered].sort((a,b)=> (a.name||'').localeCompare(b.name||''));
      listEl.innerHTML = '';
      if (!byName.length){ emptyEl.style.display = 'block'; return; }
      emptyEl.style.display = 'none';
      for (const it of byName) listEl.appendChild(renderRow(it));
    } else {
      renderFlatByRoute(filtered);
    }
  }




      function renderFlatByRoute(items){
        const sorted = [...items].sort((a,b)=>{
          const ra = isNaN(parseFloat(a.routeOrder)) ? -1 : parseFloat(a.routeOrder);
          const rb = isNaN(parseFloat(b.routeOrder)) ? -1 : parseFloat(b.routeOrder);
          if (ra !== rb) return ra - rb;
          return (a.name||'').localeCompare(b.name||'');
        });

        listEl.innerHTML = '';
        if (!sorted.length){ emptyEl.style.display = 'block'; return; }
        emptyEl.style.display = 'none';
        for (const it of sorted) listEl.appendChild(renderRow(it));
      }

      function renderGroupedByCategory(items){
        const groups = new Map();
        for (const it of items){
          const key = (it.category || '').trim() || 'Uncategorized';
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(it);
        }
        const catNames = [...groups.keys()].sort((a,b)=>a.localeCompare(b));
        listEl.innerHTML = '';
        if (!catNames.length){ emptyEl.style.display = 'block'; return; }
        emptyEl.style.display = 'none';

        for (const cat of catNames){
          const header = document.createElement('div');
          header.className = 'groupHeader';
          const dot = document.createElement('div'); dot.className='dot';
          const label = document.createElement('div'); label.textContent = cat;
          header.append(dot,label);
          listEl.appendChild(header);

          const box = document.createElement('div'); box.className = 'groupBox';
          const rows = groups.get(cat).sort((a,b)=>{
            const an = (a.name||''), bn = (b.name||'');
            const cmp = an.localeCompare(bn); if (cmp !== 0) return cmp;
            const ra = isNaN(parseFloat(a.routeOrder)) ? -1 : parseFloat(a.routeOrder);
            const rb = isNaN(parseFloat(b.routeOrder)) ? -1 : parseFloat(b.routeOrder);
            return ra - rb;
          });
          for (const it of rows) box.appendChild(renderRow(it));
          listEl.appendChild(box);
        }
      }
  function renderRecipes(arr){
    const list = $('recipeList');
    const count = $('recipesCount'); // optional
    if (!list) return;
    list.innerHTML = '';

    // Cache latest recipes snapshot for instant startup
    const _ric = window.requestIdleCallback || function(cb){ return setTimeout(cb, 0); };
    _ric(() => {
      try { localStorage.setItem('cache_recipes', JSON.stringify(arr || [])); } catch {}
    });

    if (count) {
      count.textContent = `${arr.length} recipe${arr.length===1?'':'s'}`;
    }

    if (!arr.length){
      const empty = document.createElement('div');
      empty.className = 'muted';
      empty.textContent = 'No recipes yet. Click "Add Recipe".';
      list.appendChild(empty);
      return;
    }

    for (const r of arr){
      const row = document.createElement('div');
      row.className = 'recipeRow';
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.maxWidth = '100%';
      row.style.gap = '8px';

      const left = document.createElement('div');
      left.innerHTML = `<strong>${escapeHtml(r.name||'Untitled')}</strong> 
        <span class="muted">(${r.basePortions||1} portions)</span>`;

      if (r.tags && r.tags.length){
        const tags = document.createElement('span');
        tags.className = 'muted';
        tags.textContent = ' ' + r.tags.join(', ');
        left.appendChild(tags);
      }

      // Helper to inject the full-overlay pink "Cook Mode" button into a hover target
        // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (2-tap flow)
      // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (true 2-tap flow)
      // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (true 2-tap flow; no auto-hide)
        // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (true 2-tap flow; stays visible)
    function attachCookOverlay(hoverTarget){
  hoverTarget.style.position = hoverTarget.style.position || 'relative';

  const isCoarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;

  // Create the overlay button (kept for desktop hover use)
  const cookBtn = document.createElement('button');
  cookBtn.type = 'button';
  cookBtn.textContent = 'Cook Mode';
  cookBtn.setAttribute('aria-label', 'Open Cook Mode for ' + (r.name||'Recipe'));
  cookBtn.className = 'btn-pink';
  Object.assign(cookBtn.style, {
    position:'absolute', inset:'0', width:'100%', height:'100%',
    display:'none', opacity:'0', transition:'opacity 200ms ease',
    borderRadius:'10px', fontSize:'14px', fontWeight:'600', zIndex:'2',
    alignItems:'center', justifyContent:'center', textAlign:'center', cursor:'pointer'
  });
  hoverTarget.appendChild(cookBtn);

  // Touch (phones/tablets): single tap opens immediately
  if (isCoarse) {
    hoverTarget.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (window.cookMode && typeof window.cookMode.open === 'function') {
        window.cookMode.open(r, 0);
      }
    }, { passive:true });
    return; // skip the desktop two-step overlay
  }

  // Desktop (mouse): keep your existing 2-step “reveal then click” behavior
  let hideTimer=null, fadeTimer=null, ignoreNext=false;

  const showBtn = () => {
    ignoreNext = true;
    if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
    if (fadeTimer) { clearTimeout(fadeTimer); fadeTimer = null; }
    cookBtn.style.display = 'flex';
    requestAnimationFrame(() => { cookBtn.style.opacity = '1'; });
    hideTimer = setTimeout(() => hideBtn(), 1200); // a bit longer than 1s
  };
  const hideBtn = () => {
    ignoreNext = false;
    if (hideTimer) { clearTimeout(hideTimer); hideTimer=null; }
    cookBtn.style.opacity = '0';
    fadeTimer = setTimeout(() => { cookBtn.style.display='none'; fadeTimer=null; }, 220);
  };

  hoverTarget.addEventListener('pointerdown', () => {
    if (cookBtn.style.display === 'none') showBtn();
  });

  cookBtn.addEventListener('click', (ev) => {
    ev.stopPropagation();
    if (ignoreNext) { ignoreNext=false; return; }
    if (window.cookMode && typeof window.cookMode.open === 'function') {
      window.cookMode.open(r, 0);
      hideBtn();
    } else {
      alert('Cook Mode module is not available.');
    }
  });
}







      // If the recipe has a cover image, prepend a thumbnail and use the text box as hover target
      if (r.coverUrl){
        left.style.display = 'flex';
        left.style.alignItems = 'center';
        left.style.gap = '10px';

        const img = document.createElement('img');
img.className = 'thumb recipeThumb';
        img.loading = 'lazy';
        img.decoding = 'async';
        img.src = r.coverUrl;
        img.alt = (r.name || 'Recipe') + ' cover';
        img.style.cursor = 'pointer';
        img.onclick = () => openLightbox(r.coverUrl);

        // Move existing text nodes into a wrapper so image sits to the left
        const textBox = document.createElement('div');
        while (left.firstChild) textBox.appendChild(left.firstChild);
        left.append(img, textBox);

        // FULL-OVERLAY Cook Mode button on text area
        attachCookOverlay(textBox);
      } else {
        // No cover image: use the whole left block as the hover target
        attachCookOverlay(left);
      }

      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.gap = '6px';

      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openRecipeModal('edit', r);

      const addBtn = document.createElement('button');
      addBtn.textContent = 'Add to List';
      addBtn.onclick = () => openAddToListModal(r);

      // Inline Cook button removed — overlay Cook Mode button remains on the text area
      right.append(editBtn, addBtn);

      row.append(left, right);
      list.appendChild(row);


    }
  }





      // ==== PHOTO: shared popup + global inputs ====
      const fileChooser = $('fileChooser');
      const fileCamera  = $('fileCamera');
      const popupEl = $('photoPopup');
      const btnTake = $('ppTake');
      const btnChoose = $('ppChoose');
      const btnCancel = $('ppCancel');

      // openPhotoPicker({ onFile: (File)=>void })
      function openPhotoPicker(ctx){
        if (!ctx || typeof ctx.onFile !== 'function') return;
        popupEl.classList.add('show');
        popupEl.setAttribute('aria-hidden','false');

        const cleanup = () => {
          popupEl.classList.remove('show');
          popupEl.setAttribute('aria-hidden','true');
          btnTake.onclick = btnChoose.onclick = btnCancel.onclick = null;
          document.removeEventListener('keydown', onEsc);
          fileChooser.onchange = null; fileCamera.onchange = null;
        };
        const onEsc = e => { if (e.key === 'Escape') cleanup(); };
        document.addEventListener('keydown', onEsc);
        popupEl.onclick = (e)=>{ if (e.target === popupEl) cleanup(); };

        const attachAndClick = (inputEl) => {
          inputEl.onchange = () => {
            const f = inputEl.files && inputEl.files[0];
            cleanup();
            if (f) ctx.onFile(f);
            inputEl.value = ''; // reset for next time
          };
          // On some browsers, must be inside a user gesture: use setTimeout 0
          setTimeout(()=> inputEl.click(), 0);
        };

        btnTake.onclick = () => attachAndClick(fileCamera);
        btnChoose.onclick = () => attachAndClick(fileChooser);
        btnCancel.onclick = cleanup;
      }

        function setNewPhotoFile(f){
        newItemPhotoFile = f || null;
        const photoName = $('photoName');
        if (photoName) photoName.textContent = f ? (f.name || '1 image selected') : '';
        if (f) setPhotoPreview(''); // hide existing preview if choosing a new file
      }
      function setPhotoPreview(url){
        const img = $('photoPreview'); if (!img) return;
        if (url){ img.src = url; img.style.display = 'block'; }
        else { img.removeAttribute('src'); img.style.display = 'none'; }
      }

    

      // Photo upload helpers for items
      async function uploadItemPhoto(file, itemId, prevPath){
        if (!auth || !auth.currentUser || !household) throw new Error('Sign in and set household first.');
        const clean = (file.name || 'photo').replace(/[^a-zA-Z0-9._-]/g,'_');
        const path = `${household}/${itemId}/${Date.now()}-${clean}`;
        const ref = storage.ref().child(path);
        const metadata = { contentType: file.type || 'image/jpeg', customMetadata: { uid: auth.currentUser.uid, itemId } };
        const snap = await ref.put(file, metadata);
        const url = await snap.ref.getDownloadURL();
        await db.collection('lists').doc(household).collection('items').doc(itemId).set({
          photoUrl: url, photoPath: path, photoUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
        if (prevPath && prevPath !== path) { try { await storage.ref().child(prevPath).delete(); } catch(e){} }
        return { url, path };
      }

      async function removeItemPhoto(itemId, photoPath){
        if (!auth || !auth.currentUser || !household) throw new Error('Sign in and set household first.');
        if (photoPath) { try { await storage.ref().child(photoPath).delete(); } catch(e){} }
        await db.collection('lists').doc(household).collection('items').doc(itemId).set({
          photoUrl: firebase.firestore.FieldValue.delete(),
          photoPath: firebase.firestore.FieldValue.delete(),
          photoUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      }
    // Photo upload helper for RECIPE cover
  async function uploadRecipeCover(file, recipeId, prevPath){
    if (!auth || !auth.currentUser || !household || !recipeId) throw new Error('Not ready');
    const clean = (file.name || 'cover').replace(/[^a-zA-Z0-9._-]/g,'_');
    const path = `${household}/recipes/${recipeId}/cover-${Date.now()}-${clean}`;
    const ref = storage.ref().child(path);
    const metadata = { contentType: file.type || 'image/jpeg', customMetadata: { uid: auth.currentUser.uid, recipeId } };
    const snap = await ref.put(file, metadata);
    const url = await snap.ref.getDownloadURL();

    await db.collection('recipes').doc(household).collection('recipes').doc(recipeId)
      .set({
        coverUrl: url,
        coverPath: path,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
      }, { merge: true });

    if (prevPath && prevPath !== path) { try { await storage.ref().child(prevPath).delete(); } catch(e){} }
    return { url, path };
  }

  /** Upload a single STEP photo to Storage; return { url, path }.
   *  Does NOT write Firestore directly — caller merges into the steps[] array. */
  async function uploadStepPhoto(file, recipeId, stepId, prevPath){
    if (!auth || !auth.currentUser || !household || !recipeId || !stepId) throw new Error('Not ready');
    const clean = (file.name || 'step').replace(/[^a-zA-Z0-9._-]/g,'_');
    const path = `${household}/recipes/${recipeId}/steps/${stepId}-${Date.now()}-${clean}`;
    const ref = storage.ref().child(path);
    const metadata = { contentType: file.type || 'image/jpeg', customMetadata: { uid: auth.currentUser.uid, recipeId, stepId } };
    const snap = await ref.put(file, metadata);
    const url = await snap.ref.getDownloadURL();

    // Remove the old file if changing photo
    if (prevPath && prevPath !== path) { try { await storage.ref().child(prevPath).delete(); } catch(e){} }

    return { url, path };
  }

// === Utility: Capitalize at start of string or after spaces only ===
function capitalizeWords(str){
  if (!str) return '';
  // Uppercase only the first letter after start/space (handles umlauts properly)
  return String(str).replace(/(^|\s)([a-z\u00C0-\u024F])/g, function(_, pre, ch){
    return pre + ch.toUpperCase();
  });
}


const editingOpen = new Set();

      function renderRow(it){
        const row = document.createElement('div');
        row.className = 'item';
        row.dataset.cat = ((it.category || '').trim().toLowerCase().replace(/[^a-z0-9]+/g, '-'));

        /* 1) Checkbox */
        const left = document.createElement('div');
        left.className = 'left';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = !!it.checked;
  cb.onchange = async () => {
    const isChecked = !!cb.checked;
    const patch = {
      checked: isChecked,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    // If the user checks the box, zero the qty
    if (isChecked) {
      patch.qty = '0';
    }

    try {
      await updateItem(it.id, patch);

      // reflect local state
      it.checked = isChecked;
      if (isChecked) {
        it.qty = '0';
        // Update the inline qty input on this row (if present)
        const qi = row.querySelector('.qty-inline');
        if (qi) qi.value = '0';
      }
    } catch (e) {
      console.error('Checkbox update failed:', e);
      showToast('Failed to update item');
    }
  };




        left.appendChild(cb);

        /* 2) Title */
        const line1 = document.createElement('div');
        line1.className = 'line1';
        const catdot = document.createElement('span'); catdot.className = 'catdot';
        const nameEl = document.createElement('span');
  nameEl.className = 'name';
nameEl.textContent = capitalizeWords(it.name || '');


  // Show red flag if routeOrder is missing or invalid
  const routeMissing = (
    it.routeOrder === undefined ||
    it.routeOrder === null ||
    it.routeOrder === '' ||
    isNaN(parseFloat(it.routeOrder))
  );
  if (routeMissing) {
    const flag = document.createElement('span');
    flag.textContent = ' 🚩';
    flag.title = 'No route number set';
    flag.style.color = 'red';
    nameEl.appendChild(flag);
  }

  line1.append(catdot, nameEl);
    // Second line under the name: Qty input + optional Size text
  const meta = document.createElement('div');
  meta.className = 'meta';

 // Qty (click-to-edit; shows placeholder when empty)
const qtySpan = document.createElement('span');
qtySpan.className = 'muted';
qtySpan.title = 'Click to edit qty';
qtySpan.style.cursor = 'text';

const setQtyDisplay = (val) => {
  const hasVal = !!(val && val.trim());
  qtySpan.textContent = hasVal ? val.trim() : 'Add qty';
  qtySpan.classList.toggle('muted', true);
  qtySpan.style.fontStyle = hasVal ? 'normal' : 'italic';
};
setQtyDisplay(it.qty || '');

qtySpan.addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'text';
  input.inputMode = 'decimal';
  input.placeholder = 'Qty';
  input.className = 'qty-inline';
  input.value = it.qty || '';
  qtySpan.replaceWith(input);
  input.focus();
  try { input.select(); } catch {}

  autoSize(input);
  input.addEventListener('input', () => autoSize(input));

  const finish = async (commit) => {
    const newQty = commit ? (input.value || '').trim() : (it.qty || '');

    // Uncheck if moving from "0"/empty → positive (keep original logic)
    const asNum = (s) => (typeof parseNum === 'function' ? parseNum(s) : NaN);
    const wasZeroish = !it.qty || asNum(it.qty) === 0;
    const n = asNum(newQty);
    const nowPositive = (Number.isFinite(n) && n > 0) || (!Number.isFinite(n) && newQty !== '');
    const shouldUncheck = !!it.checked && wasZeroish && nowPositive;

    if (commit && newQty !== (it.qty || '')) {
      try {
        const patch = {
          qty: newQty,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        if (shouldUncheck) patch.checked = false;
        await updateItem(it.id, patch);
        it.qty = newQty;

        if (shouldUncheck) {
          cb.checked = false;
          it.checked = false;
          showToast('Moved back to Shopping');
        }
      } catch (e) {
        console.error('Qty inline update failed:', e);
        showToast('Failed to update qty');
      }
    }

    // Restore display node (with placeholder if empty)
    setQtyDisplay(newQty);
    input.replaceWith(qtySpan);
  };

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); finish(true); }
    if (e.key === 'Escape') { e.preventDefault(); finish(false); }
  });
  input.addEventListener('blur', () => finish(true));
});

meta.appendChild(qtySpan);


 // Size (click-to-edit; shows placeholder when empty)
const sizeSpan = document.createElement('span');
sizeSpan.className = 'muted';
sizeSpan.title = 'Click to edit size';
sizeSpan.style.cursor = 'text';

const setSizeDisplay = (val) => {
  const hasVal = !!(val && val.trim());
  sizeSpan.textContent = hasVal ? val.trim() : 'Add size';
  sizeSpan.classList.toggle('muted', true);
  sizeSpan.style.fontStyle = hasVal ? 'normal' : 'italic';
};
setSizeDisplay(it.size || '');

sizeSpan.addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'qty-inline'; // reuse existing inline styling
  input.value = it.size || '';
  sizeSpan.replaceWith(input);
  input.focus();
  try { input.select(); } catch {}

  const finish = async (commit) => {
    const newVal = commit ? (input.value || '').trim() : (it.size || '');
    if (commit && newVal !== (it.size || '')) {
      try {
        await updateItem(it.id, {
          size: newVal,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        it.size = newVal;
      } catch (e) {
        console.error('Size inline update failed:', e);
        showToast('Failed to update size');
      }
    }
    setSizeDisplay(newVal);
    input.replaceWith(sizeSpan);
  };

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); finish(true); }
    if (e.key === 'Escape') { e.preventDefault(); finish(false); }
  });
  input.addEventListener('blur', () => finish(true));
});

meta.appendChild(sizeSpan);


  // attach the second line under the name
  line1.append(meta);



      /* 3) Actions */
  let actions = null;

  // Only show Edit/Delete on LIST tab (hide on SHOPPING tab)
  if (activeTab !== 'shopping') {
    actions = document.createElement('div');
    actions.className = 'actions';

    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'editbtn';
    editBtn.textContent = 'Edit';

    const delBtn = document.createElement('button');
    delBtn.type = 'button';
    delBtn.className = 'btn-icon';
    delBtn.title = 'Delete item';
    delBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-trash"></use></svg>';
    delBtn.style.display = 'none';   // hidden unless editing
    delBtn.onclick = () => removeItem(it.id);

    actions.append(editBtn, delBtn);

 // Helper to refresh the button label while this row is editing
function refreshEditBtnLabel(){
  const isDirty = window.editDirty && window.editDirty.has(it.id);
  editBtn.textContent = isDirty ? 'Save' : 'Close';
  editBtn.classList.toggle('btn-pink', !!isDirty);
}


    // Click handler: enter/exit edit mode
    editBtn.onclick = (ev) => {
      ev.stopPropagation();
      const isEditing = row.classList.contains('editing');

      if (!isEditing) {
        // ENTER edit mode for this row
        window.currentEditingId = it.id;
        row.classList.add('editing');
        delBtn.style.display = '';
        // If already marked dirty (e.g., from a quick change), show Save, else Close
        refreshEditBtnLabel();
      } else {
    // EXIT edit mode (treat as "Save" if dirty — changes already persisted by onchange)
row.classList.remove('editing');
delBtn.style.display = 'none';
if (window.editDirty) window.editDirty.delete(it.id);
window.currentEditingId = null;
editBtn.textContent = 'Edit';
editBtn.classList.remove('btn-pink');

      }
    };

    // If this row is the one currently being edited, restore that state after re-render
    if (window.currentEditingId === it.id) {
      row.classList.add('editing');
      delBtn.style.display = '';
      refreshEditBtnLabel();
    }
  }


        /* 4) Below row: media + notes */
        const below = document.createElement('div');
        below.className = 'below';

        const mediaCell = document.createElement('div');

        const mountCameraBtn = () => {
          mediaCell.innerHTML = '';
          const camBtn = document.createElement('button');
          camBtn.type = 'button';
          camBtn.className = 'camBtn';
          camBtn.title = 'Add photo';
          camBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-camera"></use></svg>';
          camBtn.onclick = () => {
            openPhotoPicker({
              onFile: async (file) => {
                if (!file) return;
                try {
                showToast('Uploading photo in background…');

(async () => {
  try {
    const { url, path } = await uploadItemPhoto(file, it.id, it.photoPath || null);
    it.photoUrl = url; it.photoPath = path;
    mountThumb(url);
    below.classList.remove('hidden');
    removePhotoBtn.disabled = false;
    showToast('Photo uploaded');
  } catch (e) {
    console.error(e);
    showToast('Photo upload failed');
  }
})();


                } catch(e){ alert('Upload failed: ' + (e.message || e)); }
              }
            });
          };
          mediaCell.appendChild(camBtn);
        };

        const mountThumb = (url) => {
          mediaCell.innerHTML = '';
          const thumb = document.createElement('img');
          thumb.className = 'thumb';
          thumb.src = url;
          thumb.alt = it.name || 'photo';
          thumb.onclick = () => openLightbox(url);
          mediaCell.appendChild(thumb);
        };

        if (it.photoUrl) mountThumb(it.photoUrl); else mountCameraBtn();

        const line2 = document.createElement('div');
line2.className = 'line2';
line2.title = 'Click to edit notes';
line2.style.cursor = 'text';

// If no notes on the Shopping tab, show a clickable placeholder
if (!it.notes && activeTab === 'shopping') {
  line2.textContent = 'Add note';
  line2.classList.add('muted');
  line2.style.fontStyle = 'italic';
} else {
  line2.textContent = it.notes || '';
}


// Click-to-edit: swap display div → auto-growing textarea
line2.addEventListener('click', () => {
  // Build textarea
  const ta = document.createElement('textarea');
  ta.value = it.notes || '';
  ta.setAttribute('rows', '1');
  ta.style.width = '100%';
  ta.style.font = 'inherit';
  ta.style.color = 'inherit';
  ta.style.background = 'var(--surface)';
  ta.style.border = '1px solid var(--border)';
  ta.style.borderRadius = '10px';
  ta.style.padding = '8px 10px';
  ta.style.resize = 'none';
  ta.style.lineHeight = '1.35';
  ta.style.boxSizing = 'border-box';

  // Auto-grow helper
  const autoGrow = () => {
    ta.style.height = 'auto';
    ta.style.height = (ta.scrollHeight + 2) + 'px';
  };

  line2.replaceWith(ta);
  ta.focus();
  try { ta.select(); } catch {}

  autoGrow();
  ta.addEventListener('input', autoGrow);

  const finish = async (commit) => {
    const newVal = commit ? (ta.value || '').trim() : (it.notes || '');

    if (commit && newVal !== (it.notes || '')) {
      try {
        await updateItem(it.id, {
          notes: newVal,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        it.notes = newVal;
        showToast('Notes updated');
      } catch (e) {
        console.error('Notes inline update failed:', e);
        showToast('Failed to update notes');
      }
    }

    // Restore display node (or hide below row if now empty and no photo)
if (newVal) {
  line2.textContent = newVal;
  line2.classList.remove('muted');
  line2.style.fontStyle = '';
  ta.replaceWith(line2);
  below.classList.remove('hidden');
} else {
  if (activeTab === 'shopping') {
    // Keep a clickable placeholder on Shopping tab
    line2.textContent = 'Add note';
    line2.classList.add('muted');
    line2.style.fontStyle = 'italic';
    ta.replaceWith(line2);
    below.classList.remove('hidden');
  } else {
    // Non-Shopping: remove the line and (if no photo) hide the below row
    ta.remove();
    if (!it.photoUrl) {
      below.classList.add('hidden');
    }
  }
}


  };

  ta.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finish(true); }
    if (e.key === 'Escape') { e.preventDefault(); finish(false); }
  });
  ta.addEventListener('blur', () => finish(true));
});

below.append(mediaCell, line2);

/* Keep the below row visible on the Shopping tab so the camera button is available
   even when there are no notes yet. Hide elsewhere if empty. */
if (!it.photoUrl && !it.notes && activeTab !== 'shopping') {
  below.classList.add('hidden');
}

        /* 5) Editor row */
        const editor = document.createElement('div');
        editor.className = 'editor';

        const qty = document.createElement('input');
        qty.className = 'qty'; qty.placeholder = 'Qty'; qty.value = it.qty || '';
qty.onchange = () => { 
  window.currentEditingId = it.id; (window.editDirty||=new Set()).add(it.id);
const eb = row.querySelector('.editbtn');  
if (eb) {    
  eb.textContent = 'Save';    
  eb.classList.add('btn-pink');  
}
  updateItem(it.id, { qty: qty.value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
};

        const size = document.createElement('input');
        size.className = 'size'; size.placeholder = 'Size'; size.value = it.size || '';
size.onchange = () => { 
  window.currentEditingId = it.id; (window.editDirty||=new Set()).add(it.id);
const eb = row.querySelector('.editbtn');  
if (eb) {    
  eb.textContent = 'Save';    
  eb.classList.add('btn-pink');  
}
  updateItem(it.id, { size: size.value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
};

        const notes = document.createElement('input');
        notes.className = 'notes'; notes.placeholder = 'Notes'; notes.value = it.notes || '';
notes.onchange = () => { 
  window.currentEditingId = it.id; (window.editDirty||=new Set()).add(it.id);
const eb = row.querySelector('.editbtn');  
if (eb) {    
  eb.textContent = 'Save';    
  eb.classList.add('btn-pink');  
}
  updateItem(it.id, { notes: notes.value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
};

        const cat  = document.createElement('select'); cat.className = 'category';
        ["", "Produce", "Meat & Poultry", "Fish & Seafood", "Dairy & Eggs", "Bakery", "Pantry", "Frozen", "Beverages", "Snacks & Confectionery", "Household & Cleaning", "Personal Care & Health", "Other"].forEach(opt => {
          const o = document.createElement('option'); o.value = opt; o.textContent = opt || '— Select —';
          if ((it.category||'') === opt) o.selected = true; cat.appendChild(o);
        });
cat.onchange = () => { 
  window.currentEditingId = it.id; (window.editDirty||=new Set()).add(it.id);
const eb = row.querySelector('.editbtn');  
if (eb) {    
  eb.textContent = 'Save';    
  eb.classList.add('btn-pink');  
}
  updateItemAndCatalog(it, { category: cat.value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
};

        const route = document.createElement('input');
        route.className = 'route'; route.type = 'number'; route.step = '0.1'; route.placeholder = 'Route'; route.value = it.routeOrder ?? '';
route.onchange = () => { 
  window.currentEditingId = it.id; (window.editDirty||=new Set()).add(it.id);
const eb = row.querySelector('.editbtn');  
if (eb) {    
  eb.textContent = 'Save';    
  eb.classList.add('btn-pink');  
}
  updateItemAndCatalog(it, { routeOrder: route.value ? Number(route.value) : '', updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
};

        const changePhoto = document.createElement('button');
        changePhoto.type = 'button'; changePhoto.textContent = it.photoUrl ? 'Change photo' : 'Add photo';
       changePhoto.onclick = () => {
  openPhotoPicker({
    onFile: async (file) => {
      if (!file) return;
      try {
      // flip button state immediately
window.currentEditingId = it.id; (window.editDirty ||= new Set()).add(it.id);
if (typeof refreshEditBtnLabel === 'function') refreshEditBtnLabel();
const eb = row.querySelector('.editbtn');  if (eb) { eb.textContent = 'Save'; eb.classList.add('btn-pink'); }

// start upload in background (non-blocking)
showToast('Uploading photo in background…');

(async () => {
  try {
    const { url, path } = await uploadItemPhoto(file, it.id, it.photoPath || null);

    it.photoUrl = url; it.photoPath = path;
    mountThumb(url);
    below.classList.remove('hidden');
    removePhotoBtn.disabled = false;

    showToast('Photo uploaded');
  } catch (e) {
    console.error(e);
    showToast('Photo upload failed');
  }
})();

      } catch (e) {
        alert('Upload failed: ' + (e.message || e));
      }
    }
  });
};


        const removePhotoBtn = document.createElement('button');
        removePhotoBtn.type = 'button'; removePhotoBtn.textContent = 'Remove photo';
        removePhotoBtn.disabled = !it.photoPath;
       removePhotoBtn.onclick = async () => {
  // Flip to “Save” + pink immediately
  window.currentEditingId = it.id; (window.editDirty ||= new Set()).add(it.id);
  if (typeof refreshEditBtnLabel === 'function') refreshEditBtnLabel();
  const eb = row.querySelector('.editbtn');
  if (eb) { eb.textContent = 'Save'; eb.classList.add('btn-pink'); }

  try {
    await removeItemPhoto(it.id, it.photoPath || null);
    it.photoUrl = ''; it.photoPath = '';

    // Reflect UI
    mountCameraBtn();
    if (typeof changePhoto !== 'undefined') changePhoto.textContent = 'Add photo';
    removePhotoBtn.disabled = true;
/* On Shopping tab, keep below visible so the camera button remains accessible. */
below.classList.toggle('hidden', (!it.notes && activeTab !== 'shopping'));
    showToast('Photo removed');
  } catch(e){
    alert('Failed to remove photo: ' + (e.message || e));
  }
};


        editor.append(qty, size, notes, cat, route, changePhoto, removePhotoBtn);

        /* Assemble row */
      // Assemble row (omit actions on Shopping tab)
  if (actions) {
    row.append(left, line1, actions, below, editor);
  } else {
    row.append(left, line1, below, editor);
  }


        // Flash if just added
        if (it.id === lastAddedId) {
          requestAnimationFrame(() => {
            row.classList.add('flash');
            row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            setTimeout(() => row.classList.remove('flash'), 900);
            lastAddedId = null;
          });
        }

        return row;
      }

      async function updateItem(id, patch){
        if (!auth || !auth.currentUser || !household) return alert('Sign in and set household first.');
        const ref = db.collection('lists').doc(household).collection('items').doc(id);
        await ref.set(patch, { merge: true });
      }

      async function updateItemAndCatalog(it, patch){
        await updateItem(it.id, patch);
        const name = (it.name||'').trim(); if (!name) return;
        const key = name.toLowerCase();
        const catRef = db.collection('catalog').doc(household).collection('items').doc(key);
        const data = { name, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
        if (patch.category !== undefined) data.category = patch.category || '';
        if (patch.routeOrder !== undefined) data.routeOrder = (patch.routeOrder === '' ? '' : Number(patch.routeOrder));
        await catRef.set(data, { merge: true });
        catalogCache.set(key, { category: data.category ?? '', routeOrder: data.routeOrder ?? '' });
      }

      async function removeItem(id){
        if (!auth || !auth.currentUser || !household) return;
        // best-effort: delete attached photo too
        try{
          const doc = await db.collection('lists').doc(household).collection('items').doc(id).get();
          const d = doc.exists ? doc.data() : null;
          if (d && d.photoPath) { try { await storage.ref().child(d.photoPath).delete(); } catch(e){} }
        }catch(e){}
        await db.collection('lists').doc(household).collection('items').doc(id).delete();
      }

  const _clearBtn = $('clearChecked'); if (_clearBtn) _clearBtn.onclick = async () => {
    if (!auth || !auth.currentUser || !household) return alert('Sign in and set household first.');

    // Uncheck all checked items; do NOT delete docs or photos.
    const qs = await db.collection('lists').doc(household).collection('items')
      .where('checked','==',true).get();

    if (qs.empty) { showToast('Nothing to clear'); return; }

    const batch = db.batch();
    qs.forEach(doc => {
      batch.set(doc.ref, { checked: false, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
    });

    await batch.commit();
    showToast('Unchecked all items');
  };


      // === Add new item ===
      $('newItemAddPhoto').onclick = () => {
        openPhotoPicker({
          onFile: (file) => {
            setNewPhotoFile(file);
            showToast('Photo selected');
          }
        });
      };

          $('add').onclick = async () => {
        if (!auth || !auth.currentUser || !household) return alert('Click Sign in, then set the household code.');
        const name = capitalizeWords($('itemName').value.trim()); if (!name) return alert('Type an item name.');
        const qty = $('itemQty').value.trim();
        const size = $('itemSize').value.trim();
        let category = $('itemCategory').value.trim ? $('itemCategory').value.trim() : $('itemCategory').value;
        let routeOrder = $('itemRoute').value ? Number($('itemRoute').value) : '';
        const notes = $('itemNotes').value.trim();
        const photoFile = newItemPhotoFile || null;

        const known = catalogCache.get(name.toLowerCase());
        if (known){
          if (!category && known.category) category = known.category;
          if ((routeOrder === '' || isNaN(routeOrder)) && (known.routeOrder || known.routeOrder===0)) routeOrder = known.routeOrder;
        }

        // === UPDATE existing item if a suggestion was selected ===
        if (selectedItemId){
          try{
            await updateItem(selectedItemId, {
              name,
              qty,
              size,
              notes,
              category: category || '',
              routeOrder: routeOrder === '' ? '' : Number(routeOrder),
              checked: false, // force unchecked so it shows on the active list
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            if (photoFile){
              try {
                await uploadItemPhoto(photoFile, selectedItemId, selectedItemPhotoPath || null);
              } catch(e){ console.warn('Photo upload during update failed:', e.message); }
            }

            // Update catalog (same as create path)
            try{
              await db.collection('catalog').doc(household).collection('items')
                .doc(name.toLowerCase())
                .set({
                  name,
                  category: category || '',
                  routeOrder: routeOrder === '' ? '' : Number(routeOrder),
                  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
              catalogCache.set(name.toLowerCase(), {
                category: category || '',
                routeOrder: routeOrder === '' ? '' : Number(routeOrder)
              });
            } catch(e){ console.warn('Catalog save failed:', e.message); }

            showToast(selectedItemInitialChecked ? `Unchecked and updated '${name}'.` : `Updated '${name}'.`);
          } catch(e){
            alert('Failed to update: ' + (e.message || e));
            return;
          }

                   // Clear form + state
          $('itemName').value=''; $('itemQty').value=''; $('itemSize').value='';
          $('itemCategory').value=''; $('itemRoute').value=''; $('itemNotes').value='';
          
          liveListQuery = '';                          // reset live filter
          scheduleRenderItems(lastSnapshotItems || []); // re-render full list

          newItemPhotoFile = null;
          const pn = $('photoName'); if (pn) pn.textContent = '';
          setPhotoPreview('');
          clearUpdateMode();
          return;

        }

        // === CREATE new item (optimistic, non-blocking) ===
        // 1) Prepare a client-id and optimistic payload
        const itemsCol = db.collection('lists').doc(String(household)).collection('items');
        const ref      = itemsCol.doc();                // create a doc ref now to get an id
        const newId    = ref.id;
        const now      = Date.now();

        const optimistic = {
          id: newId,                                     // for local render
          name, qty, size, notes,
          category: category || '',
          routeOrder: routeOrder === '' ? '' : Number(routeOrder),
          checked: false,
          photoUrl: '',                                  // filled after upload (background)
          photoPath: '',
          // server will overwrite these with serverTimestamp()
          createdAt: { _client: now },
          updatedAt: { _client: now },
          _pending: true                                 // local hint (optional)
        };

        // 2) Inject into local cache and repaint immediately (no await)
        try {
          (lastSnapshotItems ||= []);
          lastSnapshotItems = [...lastSnapshotItems, optimistic];
          lastAddedId = newId;
          scheduleRenderItems(lastSnapshotItems);        // instant row
        } catch (_) {}

        // 3) Clear form/UI right away so the user can keep typing
        $('itemName').value=''; $('itemQty').value=''; $('itemSize').value='';
        $('itemCategory').value=''; $('itemRoute').value=''; $('itemNotes').value='';
        liveListQuery = '';
        scheduleRenderItems(lastSnapshotItems || []);

        const pn = $('photoName'); if (pn) pn.textContent = '';
        setPhotoPreview('');
        const photoFileToUpload = newItemPhotoFile || null;
        newItemPhotoFile = null;

        // 4) Firestore writes in background (do not block UI)
        (async () => {
          try {
            // Ensure parent doc exists (best-effort)
            try { if (typeof ensureHouseholdDoc === 'function') { await ensureHouseholdDoc(household); } } catch (_) {}

            // Commit the item
            await ref.set({
              name, qty, size, notes,
              category: category || '',
              routeOrder: routeOrder === '' ? '' : Number(routeOrder),
              checked: false,
              createdAt: firebase.firestore.FieldValue.serverTimestamp(),
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Optional: background photo upload
            if (photoFileToUpload){
              try {
                await uploadItemPhoto(photoFileToUpload, newId, null);
              } catch (e) {
                console.warn('Photo upload failed:', e.message);
                showToast('Photo upload failed');
              }
            }

            // Save to catalog (best-effort) in background
            if (name){
              try{
                await db.collection('catalog').doc(household).collection('items')
                  .doc(name.toLowerCase())
                  .set({
                    name,
                    category: category || '',
                    routeOrder: routeOrder === '' ? '' : Number(routeOrder),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                  }, { merge: true });
                catalogCache.set(name.toLowerCase(), {
                  category: category || '',
                  routeOrder: routeOrder === '' ? '' : Number(routeOrder)
                });
              } catch(e){ console.warn('Catalog save failed:', e.message); }
            }

            // Success: let onSnapshot bring the canonical doc; nothing else to do.

          } catch (e) {
            console.error('Background add failed:', e);
            showToast('Add failed — check connection');

            // Roll back optimistic row if the snapshot doesn’t arrive shortly.
            // (We also rely on onSnapshot to self-correct when it resumes.)
            try {
              lastSnapshotItems = (lastSnapshotItems || []).filter(it => it.id !== newId);
              scheduleRenderItems(lastSnapshotItems);
            } catch (_) {}
          }
        })();
      };


      

  function setActiveTab(tab){ // 'list' | 'shopping' | 'recipes'
    activeTab = tab;
    const isShopping = tab === 'shopping';
    const isRecipes  = tab === 'recipes';
     const fab = document.getElementById('weeklyItemsFab');
  if (fab) fab.style.display = isShopping ? 'block' : 'none';

    // Re-query the buttons NOW (they didn’t exist when the first consts ran)
    const tList     = document.getElementById('tabList');
    const tShopping = document.getElementById('tabShopping');
    const tRecipes  = document.getElementById('tabRecipes');

    // Clear all, then set the active one
    [tList, tShopping, tRecipes].forEach(b => b && b.classList.remove('active'));
    if (tList)     tList.classList.toggle('active', tab === 'list');
    if (tShopping) tShopping.classList.toggle('active', isShopping);
    if (tRecipes)  tRecipes.classList.toggle('active', isRecipes);

    // Sections
    const listSection = $('listSection');
    const recipesView = $('recipesView');
    if (listSection) listSection.style.display = isRecipes ? 'none' : '';
    if (recipesView) recipesView.style.display = isRecipes ? '' : 'none';

    // List-only controls
    const addRow   = $('addRow');
    const clearBtn = $('clearChecked');
    if (addRow)   addRow.style.display   = (tab === 'list') ? '' : 'none';
    if (clearBtn) clearBtn.style.display = (tab === 'list') ? '' : 'none';
    // Ensure the "hide items" state only applies on the List tab

  if (listSection){
    if (tab === 'list'){
      // Re-apply the saved preference when entering the List tab
      const saved = localStorage.getItem('listCollapsed'); // "true" | "false" | null
      if (saved === 'false') {
        listSection.removeAttribute('data-list-collapsed');
      } else {
        // default hidden if missing or "true"
        listSection.setAttribute('data-list-collapsed', 'true');
      }
    } else {
      // Leaving the List tab: clear the attribute so Shopping/Recipes are never affected
      listSection.removeAttribute('data-list-collapsed');
    }
  }

  const toggleRow = $('toggleListItemsRow');
  if (toggleRow) toggleRow.style.display = (tab === 'list') ? '' : 'none';

    // Filters & “how it works”
  if (filterGroup) {
    filterGroup.style.display = (tab === 'list' || tab === 'shopping') ? '' : 'none';
  }

    const how = $('howItWorks');
    if (how) how.style.display = (tab === 'list') ? '' : 'none';

    // Persist + re-render list view
    localStorage.setItem('activeTab', tab);
    render(lastSnapshotItems || []);
  }



    
    
  // ==== Recipes: modal wiring (shell only) ====
      let editingRecipeId = null; // null = add mode, otherwise recipeId
  // Cover state + elements
  let rmCoverFile = null;
  let rmRemoveCover = false;
  let rmExistingCoverPath = null;

  const rmCoverBtn       = document.getElementById('rmCoverBtn');
  const rmCoverName      = document.getElementById('rmCoverName');
  const rmCoverPreview   = document.getElementById('rmCoverPreview');
  const rmCoverRemoveBtn = document.getElementById('rmCoverRemove');
  // === INGREDIENTS: Add Ingredient button ===
  const rmAddIngredientBtn = document.getElementById('rmAddIngredient');
  const rmIngredients = document.getElementById('rmIngredients');
  if (rmIngredients) {
  rmIngredients.addEventListener('click', (e) => {
    const delBtn = e.target.closest('.ing-del');
    if (!delBtn) return;
    const row = delBtn.closest('.ing-row');
    if (row) {
      row.remove();
      markRecipeDirty();
    }
  });
}


  // Factory: build one ingredient row
  function createIngRow(prefill=null){
    const row = document.createElement('div');
    row.className = 'ing-row';

    row.innerHTML = `
      <!-- Row 1 -->
      <div class="ing-name-wrap" style="position:relative;">
        <textarea class="ing-name" placeholder="Ingredient name"></textarea>
        <div class="ac-list ing-ac" role="listbox" aria-label="Suggestions" style="display:none"></div>
      </div>
      <input class="ing-qty" type="text" placeholder="Qty" />
      <input class="ing-size" type="text" placeholder="Size" />

      <!-- Row 2 -->
      <div></div> <!-- empty space under Name -->
      <textarea class="ing-notes" placeholder="Notes"></textarea>
      <button class="ing-del" type="button" title="Remove">✕</button>
    `;

    // Prefill if provided
    if (prefill){
      if (typeof prefill.name  === 'string') row.querySelector('.ing-name').value  = prefill.name;
      if (typeof prefill.qty   === 'string') row.querySelector('.ing-qty').value   = prefill.qty;
      if (typeof prefill.size  === 'string') row.querySelector('.ing-size').value  = prefill.size;
      if (typeof prefill.notes === 'string') row.querySelector('.ing-notes').value = prefill.notes;
    }

    // Wire delete button
    row.querySelector('.ing-del').onclick = () => { row.remove(); markRecipeDirty(); };

    // Bind autocomplete to this row
    bindIngredientAC(row);

    return row;
  }

  if (rmAddIngredientBtn) {
  rmAddIngredientBtn.onclick = () => {
    if (!rmIngredients){
      alert('Missing #rmIngredients container in the modal.');
      return;
    }
    const row = createIngRow();
    rmIngredients.appendChild(row);
    markRecipeDirty();
    const name = row.querySelector('.ing-name');
    if (name) name.focus();
  };
}




  if (rmCoverBtn) {
    rmCoverBtn.onclick = () => {
      openPhotoPicker({
        onFile: (file) => {
          rmCoverFile = file;
          rmRemoveCover = false;
          if (rmCoverName) rmCoverName.textContent = file.name || '1 image selected';
          if (rmCoverPreview) {
            rmCoverPreview.src = URL.createObjectURL(file);
            rmCoverPreview.style.display = 'block';
          }
          if (rmCoverRemoveBtn) rmCoverRemoveBtn.style.display = '';
          showToast('Cover selected');
          markRecipeDirty();
        }
      });
    };
  }

  if (rmCoverRemoveBtn) {
    rmCoverRemoveBtn.onclick = () => {
      rmCoverFile = null;
      rmRemoveCover = true;
      if (rmCoverPreview) { rmCoverPreview.removeAttribute('src'); rmCoverPreview.style.display = 'none'; }
      if (rmCoverName) rmCoverName.textContent = '';
      showToast('Cover will be removed');
      markRecipeDirty();
    };
  }

  // ===== TAGS: Top-10 + Add with autocomplete =====
  const rmTagsEl        = $('rmTags');
  const rmAddTagBtn     = $('rmAddTag');
  const rmTagAdderWrap  = $('rmTagAdderWrap');
  const rmTagInput      = $('rmTagInput');
  const rmTagAC         = $('rmTagAC');

  const MAX_TAGS_PER_RECIPE = 10;
  const TAG_MAXLEN = 24;
  // allowed chars: letters, numbers, space, dash, ampersand
  const TAG_OK = /^[A-Za-z0-9 \-&]{1,24}$/;

  // Fallback suggestions if you have <10 tags in your data
  const DEFAULT_TAGS = [
    'vegan', 'vegetarian', 'gluten-free', 'dairy-free', 'quick',
    'dessert', 'breakfast', 'dinner', 'spicy', 'kid-friendly'
  ];

  // Small helper (self-contained so we don’t depend on global one)
  function escapeHtml(str){
    return String(str)
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#39;");
  }

  // Build a map of all tags across loaded recipes
  function getAllTagStats(){
    const map = new Map(); // key = lower, val = {nameSample, count}
    (lastSnapshotRecipes || []).forEach(r => {
      const arr = Array.isArray(r.tags) ? r.tags : [];
      arr.forEach(t => {
        if (!t) return;
        const lower = t.toLowerCase();
        const prev = map.get(lower) || { nameSample: t, count: 0 };
        prev.count += 1;
        if (!map.has(lower)) prev.nameSample = t;
        map.set(lower, prev);
      });
    });
    return map;
  }

  function computeTopTags(limit=10){
    const stats = getAllTagStats();

    // Start with real usage, sorted by count desc then alpha
    const used = Array.from(stats.entries())
      .map(([lower, obj]) => ({ lower, label: obj.nameSample, count: obj.count }))
      .sort((a,b) => b.count - a.count || a.label.localeCompare(b.label));

    // If fewer than 'limit', pad with DEFAULT_TAGS (no duplicates)
    const haveLow = new Set(used.map(t => t.lower));
    for (const d of DEFAULT_TAGS){
      if (used.length >= limit) break;
      const low = d.toLowerCase();
      if (!haveLow.has(low)){
        used.push({ lower: low, label: d, count: 0 });
        haveLow.add(low);
      }
    }

    return used.slice(0, limit);
  }

  // Render the chip row: selected first, then top tags (non-duplicates)
  function renderTagsUI(selectedTags){
    if (!rmTagsEl) return;
    rmTagsEl.innerHTML = '';

    const sel = Array.isArray(selectedTags) ? selectedTags.slice(0, MAX_TAGS_PER_RECIPE) : [];
    const selLow = new Set(sel.map(s => s.toLowerCase()));

    // Header badge
    const hdr = document.createElement('span');
    hdr.className = 'tag-badge';
    hdr.textContent = 'Top tags';
    rmTagsEl.appendChild(hdr);

    // Selected chips first (active)
    sel.forEach(t => rmTagsEl.appendChild(makeTagChip(t, true)));

    // Then top tags (skip those already selected)
    const top = computeTopTags(10);
    top.forEach(t => {
      if (!selLow.has(t.lower)) rmTagsEl.appendChild(makeTagChip(t.label, false));
    });
  }

  function makeTagChip(label, active){
    const chip = document.createElement('span');
    chip.className = 'tagchip' + (active ? ' active' : '');
    chip.dataset.tag = label;
    chip.textContent = label;

    // small “x” to remove if active
    if (active){
      const x = document.createElement('span');
      x.className = 'x';
      x.textContent = '×';
      x.title = 'Remove';
      chip.appendChild(x);
    }

    chip.onclick = (e) => {
      const isClose = e.target.classList.contains('x');
      if (isClose){
        chip.remove();
        markRecipeDirty(); 
        return;
      }
      // toggle selection
      chip.classList.toggle('active');
      enforceTagLimit();
      markRecipeDirty();  
    };

    return chip;
  }

  function enforceTagLimit(){
    // if more than MAX_TAGS_PER_RECIPE active, turn off extras (keep earliest)
    const act = Array.from(document.querySelectorAll('#rmTags .tagchip.active'));
    if (act.length <= MAX_TAGS_PER_RECIPE) return;
    act.slice(MAX_TAGS_PER_RECIPE).forEach(el => el.classList.remove('active'));
  }

  // Public helpers used by Save
  function getActiveTags(){
    const chips = document.querySelectorAll('#rmTags .tagchip.active');
    return Array.from(chips).map(el => el.dataset.tag).filter(Boolean);
  }
  function clearActiveTags(){
    document.querySelectorAll('#rmTags .tagchip.active').forEach(el => el.classList.remove('active'));
  }

  // ——— Add Tag input / autocomplete ———
  if (rmAddTagBtn){
    rmAddTagBtn.onclick = () => {
      rmTagAdderWrap.style.display = '';
      rmTagInput.value = '';
      rmTagAC.style.display = 'none';
      rmTagAC.innerHTML = '';
      rmTagInput.focus();
    };
  }

  if (rmTagInput){
    const closeAC = () => { rmTagAC.style.display = 'none'; rmTagAC.innerHTML = ''; };

    rmTagInput.addEventListener('input', () => {
      const q = (rmTagInput.value || '').trim().toLowerCase();
      const stats = getAllTagStats();
      const all = Array.from(stats.values()).map(v => v.nameSample);

      // filter not already active
      const selectedLow = new Set(getActiveTags().map(t => t.toLowerCase()));
      const matches = all
        .filter(t => t.toLowerCase().includes(q))
        .filter(t => !selectedLow.has(t.toLowerCase()))
        .sort((a,b) => a.localeCompare(b))
        .slice(0, 8);

      if (!q && !matches.length){ closeAC(); return; }

      rmTagAC.innerHTML = '';
      matches.forEach(m => {
        const row = document.createElement('div');
        row.className = 'ac-item';
        row.textContent = m;
        row.onclick = () => { addTagToSelection(m); closeAC(); };
        rmTagAC.appendChild(row);
      });

      // Offer to create a new tag if no exact match
      if (q && !all.some(t => t.toLowerCase() === q) && TAG_OK.test(rmTagInput.value)){
        const createRow = document.createElement('div');
        createRow.className = 'ac-item';
        createRow.innerHTML = `Create “${escapeHtml(rmTagInput.value.trim())}”`;
        createRow.onclick = () => { addTagToSelection(rmTagInput.value.trim()); closeAC(); };
        rmTagAC.appendChild(createRow);
      }

      rmTagAC.style.display = rmTagAC.childElementCount ? 'block' : 'none';
    });

  rmTagInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === 'Done' || e.keyCode === 13){
      e.preventDefault();
      const txt = (rmTagInput.value || '').trim();
      if (!txt) return;
      addTagToSelection(txt);
      rmTagInput.value = '';
      rmTagAC.style.display = 'none';
      rmTagAC.innerHTML = '';
      return;
    }
    if (e.key === 'Escape'){
      rmTagAdderWrap.style.display = 'none';
      rmTagAC.style.display = 'none';
    }
  });


    document.addEventListener('click', (e) => {
      if (!rmTagAdderWrap.contains(e.target) && e.target !== rmAddTagBtn){
        rmTagAC.style.display = 'none';
      }
    });
  }

  function addTagToSelection(raw){
    let label = (raw || '').trim().toLowerCase();
    if (!label) return;
    if (!TAG_OK.test(label)){
      alert('Tag can only use lowercase letters, numbers, spaces, “-”, “&” and up to 24 characters.');
      return;
    }

    // de-duplicate (case-insensitive)
    const current = getActiveTags();
    const lowSet = new Set(current.map(t => t.toLowerCase()));
    if (lowSet.has(label)) return;

    // create chip as active (selected)
    rmTagsEl.insertBefore(
      makeTagChip(label, true),
      rmTagsEl.firstChild ? rmTagsEl.firstChild.nextSibling : null /* after badge */
    );
    enforceTagLimit();
    markRecipeDirty();
  }



  const recipesView = $('recipesView');
  const btnOpenAddRecipe = $('btnOpenAddRecipe');

  const recipeModal = $('recipeModal');
  const rmClose = $('rmClose');
  const rmSave = $('rmSave');
  const rmDelete = $('rmDelete');
    // === Dirty state for Recipe Modal ===
  let recipeDirty = false;

  function updateRecipeSaveButton(){
    if (!rmSave) return;
    if (recipeDirty){
      rmSave.textContent = 'Save';
      rmSave.classList.add('btn-pink');
    } else {
      rmSave.textContent = 'Close';
      rmSave.classList.remove('btn-pink');
    }

  }


  function markRecipeDirty(){
    if (!recipeDirty){
      recipeDirty = true;
      updateRecipeSaveButton();
    }
  }

  // Any user edits inside the recipe modal will mark it dirty
  if (recipeModal){
    recipeModal.addEventListener('input', markRecipeDirty, true);
    recipeModal.addEventListener('change', markRecipeDirty, true);
  }

      // Add-step button
  const rmAddStepBtn = $('rmAddStep');
if (rmAddStepBtn) rmAddStepBtn.onclick = () => { addStepRow(); markRecipeDirty(); };




  function openRecipeModal(mode='add', data=null){
      // defensive: deep-clone so we never mutate the original recipe object used elsewhere
    data = data ? JSON.parse(JSON.stringify(data)) : null;

    $('rmTitle').textContent = mode === 'edit' ? 'Edit Recipe' : 'Add Recipe';
    editingRecipeId = (mode === 'edit' && data && data.id) ? data.id : null;
    // Show Delete only in edit mode
  if (rmDelete) {
    rmDelete.style.display = editingRecipeId ? '' : 'none';
      // Reset dirty state after initial field population
    recipeDirty = false;
    // Ensure modal buttons are pink-styled
  const rmSaveBtn  = document.getElementById('rmSaveBtn')  || recipeModal.querySelector('.rm-save')  || recipeModal.querySelector('.modal-footer button:last-child');
  const rmCloseBtn = document.getElementById('rmCloseBtn') || recipeModal.querySelector('.rm-close') || recipeModal.querySelector('.modal-footer button:first-child');

  [rmSaveBtn, rmCloseBtn].forEach(b => b && b.classList.add('btn-pink'));

    updateRecipeSaveButton();

  }


    // reset fields
    $('rmName').value = (data && data.name) || '';
    $('rmBasePortions').value = (data && data.basePortions) || 2;

  // tags (render top + preselect from recipe)
  const preset = (data && Array.isArray(data.tags)) ? data.tags : [];
  renderTagsUI(preset);

  // Cover: reset state + preview
  rmCoverFile = null;
  rmRemoveCover = false;
  rmExistingCoverPath = (data && data.coverPath) ? data.coverPath : null;

  const p = $('rmCoverPreview');
  const rmRemoveBtn = $('rmCoverRemove');
  const rmNameLbl  = $('rmCoverName');

  if (p){
    if (data && data.coverUrl){
      p.src = data.coverUrl;
      p.style.display='block';
      if (rmRemoveBtn) rmRemoveBtn.style.display = '';
      if (rmNameLbl)  rmNameLbl.textContent = '';
    } else {
      p.src = '';
      p.style.display='none';
      if (rmRemoveBtn) rmRemoveBtn.style.display = 'none';
      if (rmNameLbl)  rmNameLbl.textContent = '';
    }
  }
  // Rebuild the ingredient rows in the editor
  if (rmIngredients) {
    rmIngredients.innerHTML = '';

    // If editing and there are saved ingredients, render those; otherwise render one empty row
    const list = (data && Array.isArray(data.ingredients) && data.ingredients.length)
      ? data.ingredients
      : [ { name:'', qty:'', size:'', notes:'' } ];

    for (const ing of list) {
      rmIngredients.appendChild(createIngRow(ing));
    }
  }

  // Rebuild the steps in the editor
  const rmStepsList = document.getElementById('rmStepsList');
  if (rmStepsList) {
    rmStepsList.innerHTML = '';
    const stepsList = (data && Array.isArray(data.steps) && data.steps.length)
      ? data.steps
      : [];

    for (const step of stepsList) {
      addStepRow(step);
    }

    // Ensure drag is active and titles are numbered for existing steps
    if (typeof rmSteps_setupDnd === 'function') rmSteps_setupDnd();
    if (typeof rmSteps_renumber === 'function') rmSteps_renumber();
  }

  // --- ALWAYS start editor sections collapsed on open -----------------
  try {
    ['rmIngredientsWrap', 'rmSteps', 'rmTagsWrap'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.removeAttribute('open');
    });
    localStorage.setItem('rmIngredients.open', '0');
    localStorage.setItem('rmSteps.open', '0');
    localStorage.setItem('rmTags.open', '0');

    const carets = ['rmIngredientsCaret','rmStepsCaret','rmTagsCaret'];
    carets.forEach(id => {
      const c = document.getElementById(id);
      if (c) c.style.transform = 'rotate(-90deg)';
    });
  } catch (e) {}
  // -------------------------------------------------------------------

  // show modal
  recipeModal.classList.add('show');
  document.body.classList.add('modal-open');
  recipeModal.setAttribute('aria-hidden','false');

  // Push a history entry so Back first closes this modal
  try {
    history.pushState({ recipeModalOpen: true }, '');
  } catch (e) {}

  // ensure nothing is focused (also blurs whatever was focused on the list)
  setTimeout(() => {
    const ae = document.activeElement;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT' || ae.isContentEditable)) {
      ae.blur();
    }
  }, 0);

  }

  function closeRecipeModal(){
    recipeModal.classList.remove('show');
    recipeModal.setAttribute('aria-hidden','true');
    document.body.classList.remove('modal-open');

    // Pop the history entry we pushed on open
    try {
      if (history.state && history.state.recipeModalOpen) {
        history.back();
      }
    } catch (e) {}
  }
  // When user presses Back / swipe-back while the Recipe modal is open, close it
  window.addEventListener('popstate', () => {
    try {
      if (recipeModal && recipeModal.classList.contains('show')) {
        recipeModal.classList.remove('show');
        recipeModal.setAttribute('aria-hidden','true');
        document.body.classList.remove('modal-open');
      }
    } catch (e) {}
  });



  if (btnOpenAddRecipe) btnOpenAddRecipe.onclick = () => openRecipeModal('add');
  if (rmClose) rmClose.onclick = closeRecipeModal;
    // Delete button: soft delete by default; ALT+Click => hard delete
  if (rmDelete) rmDelete.onclick = async (ev) => {
    if (!auth || !auth.currentUser || !household || !editingRecipeId) return;

    const hard = !!ev.altKey; // hold Alt for hard delete
    if (!hard) {
      const ok = confirm('Delete this recipe? It will be hidden from the list (soft delete).');
      if (!ok) return;

      try {
        const ref = db.collection('recipes').doc(household)
          .collection('recipes').doc(editingRecipeId);

        await ref.set({
          deletedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
        }, { merge: true });

        showToast('Recipe deleted');
        closeRecipeModal();
      } catch (e) {
        console.error(e);
        alert('Delete failed: ' + (e.message || e));
      }
    } else {
      const ok = confirm('HARD DELETE? This will permanently remove the recipe, its steps and ingredients, and the cover file. This cannot be undone.');
      if (!ok) return;
      try {
        await hardDeleteRecipe(editingRecipeId);
        closeRecipeModal();
      } catch (e) {
        console.error(e);
        alert('Hard delete failed: ' + (e.message || e));
      }
    }
  };


  if (rmSave) rmSave.onclick = async () => {
      // If nothing changed, behave like a Close button
    if (!recipeDirty) { closeRecipeModal(); return; }

    if (!auth || !auth.currentUser || !household) { alert('Sign in and set the household first.'); return; }
    


    const name = ($('rmName').value || '').trim();
    const basePortions = Math.max(1, parseInt(($('rmBasePortions').value || '1'), 10));
    const tags = getActiveTags();
    if (!name) { alert('Please enter a recipe name.'); $('rmName').focus(); return; }

    const nameLower = name.toLowerCase();

    try {
      const col = db.collection('recipes').doc(household).collection('recipes');

      // Duplicate-name guard (ignore the same doc if editing)
      const qs = await col.where('nameLower','==', nameLower).get();
      const dup = qs.docs.find(d => {
        const data = d.data() || {};
        const isDeleted = !!data.deletedAt;
        const isSame = editingRecipeId && d.id === editingRecipeId;
        return !isDeleted && !isSame;
      });
        if (dup) {
        alert('A recipe with that name already exists.');
        return;
      }

    // Close the modal immediately (keeps UI snappy)
  closeRecipeModal();
  await new Promise(r => setTimeout(r, 0));

  const now = firebase.firestore.FieldValue.serverTimestamp();
  const who = (auth.currentUser.email || auth.currentUser.uid || 'unknown');

  let recipeDocRef;

  // CREATE
  if (!editingRecipeId) {
    recipeDocRef = col.doc(); // pre-generate id

    await recipeDocRef.set({
      id: recipeDocRef.id,
      name,
      nameLower,
      basePortions,
      tags,
      coverUrl: null,
      coverPath: null,
      lastUsedServings: basePortions,
      createdAt: now,
      createdBy: who,
      updatedAt: now,
      updatedBy: who,
      deletedAt: null
    });

    showToast('Recipe created');
  }
  // UPDATE
  else {
    recipeDocRef = col.doc(editingRecipeId);

    await recipeDocRef.set({
      name,
      nameLower,
      basePortions,
      tags,
      updatedAt: now,
      updatedBy: who
    }, { merge: true });

    showToast('Recipe updated');
  }


  // === Save ingredients & steps (replace-all strategy) ===
  try {
    // Gather current editor state
    const ingredients = readIngredientsFromEditor();
    const steps = readStepsFromEditor();

    // Map stepId -> DOM row to access any selected File and previous path
    const listEl = document.getElementById('rmStepsList');
    const rowMap = new Map();
    if (listEl){
      Array.from(listEl.children).forEach(r => rowMap.set(r.dataset.stepId, r));
    }

    // Ensure we have a recipe id available for Storage paths
    const recipeIdForUpload = (typeof recipeDocRef !== 'undefined' && recipeDocRef && recipeDocRef.id)
      ? recipeDocRef.id
      : null;

    // Upload any newly chosen step photos, then patch the steps array
    if (recipeIdForUpload && Array.isArray(steps) && steps.length){
      for (const s of steps){
        const row = rowMap.get(s.id);
        if (row && row._file){
          try {
            const prevPath = row.dataset.photoPath || null;
            const { url, path } = await uploadStepPhoto(row._file, recipeIdForUpload, s.id, prevPath);
            s.photoUrl = url;
            s.photoPath = path;
            // reflect back to the DOM row so subsequent saves keep the info
            row.dataset.photoUrl = url;
            row.dataset.photoPath = path;
            row._file = null; // clear reference
          } catch (e) {
            console.warn('Step photo upload failed for', s.id, e);
            // keep existing s.photoUrl/path as-is if upload fails
          }
        }
      }
    }

    await recipeDocRef.set({
      ingredients,
      steps,
      updatedAt: now,
      updatedBy: who
    }, { merge: true });
  } catch (e) {
    console.error(e);
    alert('Saving ingredients/steps failed: ' + (e.message || e));
  }

  // We’ll reuse this for the cover background tasks
  const recipeId = recipeDocRef.id;





      
      // === Cover file changes (background, non-blocking) ===
  try {
    // Inform the user immediately; we won't await the upload/remove
    

    // Define tasks (but do NOT await here)
    const removeTask = (rmRemoveCover && !rmCoverFile) ? (async () => {
      await db.collection('recipes').doc(household).collection('recipes').doc(recipeId)
        .set({
          coverUrl: null,
          coverPath: null,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
        }, { merge: true });

      if (rmExistingCoverPath) { try { await storage.ref().child(rmExistingCoverPath).delete(); } catch(e){} }
    }) : null;

    const uploadTask = rmCoverFile ? (async () => {
      await uploadRecipeCover(rmCoverFile, recipeId, rmExistingCoverPath || null);
    }) : null;

    // Kick off tasks in a microtask after this click handler finishes,
    // so the modal can close right away.
  Promise.resolve().then(async () => {
    const coverChanged = Boolean(removeTask || uploadTask);
    try {
      if (removeTask) await removeTask();
      if (uploadTask) await uploadTask();
      if (coverChanged) showToast('Cover updated');
    } catch (e) {
      console.warn('Background cover update failed:', e);
      if (coverChanged) showToast('Cover update failed');
    }
  });

  } catch (e) {
    console.warn('Failed to schedule background cover update:', e);
  }


    



      closeRecipeModal();


    } catch (e) {
      console.error(e);
      alert('Save failed: ' + (e.message || e));
    }
  };



  // ==== Add-to-List modal wiring (full) ====
  const addToListModal = $('addToListModal');
  const atlClose       = $('atlClose');
  const atlListEl      = $('atlList');
  const atlServingsEl  = $('atlServings');
  const atlInc         = $('atlInc');
  const atlDec         = $('atlDec');
  const atlPresets     = document.querySelectorAll('.preset-row .preset');
  const atlSelectAll   = $('atlSelectAll');
  const atlAddBtn      = $('atlAdd');
  let atlIngredients = [];

  let atlRecipe = null;          // recipe meta being added
  let atlBasePortions = 2;       // base portions (from recipe)

  let atlServings = 2;           // current servings in the modal

  // --- Qty helpers (preserve units like "g", "kg", "ml", etc.)
  function parseNum(s){
    const n = parseFloat((s||'').toString().trim().replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  }
  function fmtNum(n){
    // Always round up to the nearest whole number
    return Math.ceil(n).toString();
  }
  // Split into numeric part + the exact trailing text (units/spaces kept as typed)
  function parseQtyParts(s){
    if (s == null) return { num: null, tail: '' };
    const str = String(s);
    const m = str.trim().match(/^([+-]?\d+(?:[.,]\d+)?)(.*)$/);
    if (!m) return { num: null, tail: '' };
    const num = parseFloat(m[1].replace(',', '.'));
    return Number.isFinite(num) ? { num, tail: m[2] || '' } : { num: null, tail: m[2] || '' };
  }
  // Scale number and re-attach the original tail (so "150g" -> "300g")
  function scaleQtyStr(qtyStr, factor){
    const { num, tail } = parseQtyParts(qtyStr);
    if (num === null) return qtyStr || '';
    return fmtNum(num * factor) + (tail || '');
  }
  // Add two qty strings, but only combine numbers if the unit-tails match
  // Add/merge two qty strings, consolidating ALL same-unit segments in combos.
  // Examples:
  //   "1 + 150g + 50 g" + "200g" → "1 + 400g"
  //   "2kg + 300 g + note" + "0.2 kg" → "2.2kg + 300 g + note"
  //   "pack + 150g" + "pack" (non-numeric) → "pack + 150g + pack"
  // Add/merge two qty strings, consolidating ALL same-unit segments in combos.
  // Examples:
  //   "1 + 150g + 50 g" + "200g" → "1 + 400g"
  //   "2kg + 300 g + note" + "0.2 kg" → "2.2kg + 300 g + note"
  //   "pack + 150g" + "pack" (non-numeric) → "pack + 150g + pack"
  function addQtyStr(aStr, bStr){
    const A = (aStr || '').trim();
    const B = (bStr || '').trim();

    // Split A into segments if it's a combo, else treat as single
    const Aparts = A ? A.split('+').map(s => s.trim()).filter(Boolean) : [];

    // Buckets
    const nonNumeric = [];                 // keep free text pieces
    const unitOrder = [];                  // preserve first-seen order of units
    const unitMap = Object.create(null);   // unitKey -> { sum:number, displayTail:string }

    // Helpers
    const norm = t => (t || '').trim().toLowerCase();

    // Early rule: if A is explicitly zero, overwrite with B (previous behavior)
    const Afirst = parseQtyParts(A);
    if (A === '0' || (Afirst.num !== null && Afirst.num === 0)){
      return B || '';
    }

    // 1) Consume existing A: group numeric segments by unit; keep other text
    const Asegments = Aparts.length ? Aparts : (A ? [A] : []);
    for (const seg of Asegments){
      const p = parseQtyParts(seg);
      if (p.num === null){
        nonNumeric.push(seg);
        continue;
      }
      const key = norm(p.tail);
      if (!(key in unitMap)){
        unitMap[key] = { sum: 0, displayTail: (p.tail || '') };
        unitOrder.push(key);
      }
      unitMap[key].sum += p.num;
    }

    // 2) Fold in B
    const Pb = parseQtyParts(B);
    if (Pb.num === null){
      if (B) nonNumeric.push(B);     // free text term → append later
    } else {
      const key = norm(Pb.tail);
      if (!(key in unitMap)){
        unitMap[key] = { sum: 0, displayTail: (Pb.tail || '') };
        unitOrder.push(key);
      }
      unitMap[key].sum += Pb.num;
      if (!unitMap[key].displayTail) unitMap[key].displayTail = (Pb.tail || '');
    }

    // If nothing numeric at all, fall back to simple join rules
    const hasNumeric = unitOrder.length > 0;
    if (!hasNumeric && nonNumeric.length){
      if (!A) return B;
      if (!B) return A;
      return (A ? A : '') + (A && B ? ' + ' : '') + (B ? B : '');
    }

    // 3) Rebuild: numeric groups first (preserving unit order), then non-numeric terms
    const numericOut = [];
    for (const key of unitOrder){
      const { sum, displayTail } = unitMap[key];
      if (sum === 0) continue;                  // drop zero totals
      numericOut.push(fmtNum(sum) + (displayTail || ''));
    }

    const out = [...numericOut, ...nonNumeric].join(' + ').trim();
    return out || '';
  }




  // Find existing list item (case-insensitive name match)
  function findExistingItem(nameKey){
    const key = (nameKey||'').trim().toLowerCase();
    return lastSnapshotItems.find(it => (it.name||'').trim().toLowerCase() === key) || null;
  }

  // Build the checklist rows for current servings
  function renderAtlList(){
    if (!atlListEl) return;
    atlListEl.innerHTML = '';

    const factor = Math.max(1, atlServings) / Math.max(1, atlBasePortions);

    for (const ing of atlIngredients){
      const scaledQty = scaleQtyStr(ing.qty || '', factor);
      const existing  = findExistingItem(ing.nameKey || ing.name);
      const haveTxt   = existing && (existing.qty || existing.size) 
        ? (existing.qty || '') 
        : '';

      const row = document.createElement('div');
      row.className = 'checkrow';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = true;

      const label = document.createElement('div');
      const main = document.createElement('div');
      main.innerHTML = '<strong>'+escapeHtml(ing.name)+'</strong>' +
        (ing.size ? ' <span class="muted">• '+escapeHtml(ing.size)+'</span>' : '');
      const sub  = document.createElement('div');
      sub.className = 'muted';
      sub.textContent = 'Qty: ' + (scaledQty || '—');
      if (haveTxt){
        const hint = document.createElement('span');
        hint.className = 'muted';
        hint.textContent = '  (have ' + haveTxt + ' already)';
        sub.appendChild(hint);
      }
      label.append(main, sub);

      row.append(cb, label, document.createElement('div'));
      // store refs on DOM for readback
      row._ing = ing;
      row._cb  = cb;
      row._scaledQty = scaledQty;

      atlListEl.appendChild(row);
    }
  }
  // Read the current ingredient rows from the recipe editor modal
  function readIngredientsFromEditor(){
    const rows = Array.from(document.querySelectorAll('#rmIngredients .ing-row'));
    return rows.map(row=>{
      const name  = (row.querySelector('.ing-name')?.value || '').trim();
      const qty   = (row.querySelector('.ing-qty')?.value || '').trim();
      const size  = (row.querySelector('.ing-size')?.value || '').trim();
      const notes = (row.querySelector('.ing-notes')?.value || '').trim();
      if (!name) return null;
      return {
        name,
        nameKey: name.toLowerCase(),
        qty,
        size,
        notes
      };
    }).filter(Boolean);
  }

  /* ===== Steps editor helpers (titles + drag reorder) ===== */

  // Small helper: generate a simple id
  function uid8(){
    try {
      const a = new Uint8Array(8);
      (self.crypto || window.crypto).getRandomValues(a);
      return Array.from(a, x => x.toString(16).padStart(2,'0')).join('');
    } catch(e) {
      return (Date.now().toString(36) + Math.random().toString(36).slice(2,6)).toLowerCase();
    }
  }

  // Global drag state (kept simple)
  let rmSteps_draggingRow = null;

  // Update "Step N" titles based on visual order
  function rmSteps_renumber(){
    const list = document.getElementById('rmStepsList');
    if (!list) return;
    Array.from(list.children).forEach((row, idx) => {
      const t = row.querySelector('.step-title');
      if (t) t.textContent = `Step ${idx + 1}`;
    });
  }

  // One-time setup of container-level drag handlers (guarded)
  function rmSteps_setupDnd(){
    const list = document.getElementById('rmStepsList');
    if (!list || list.dataset.dndInit === '1') return;

    list.addEventListener('dragover', (e) => {
      if (!rmSteps_draggingRow) return;
      e.preventDefault();
      const after = (() => {
        const rows = [...list.querySelectorAll('.step-row')].filter(r => r !== rmSteps_draggingRow);
        let closest = null;
        let closestOffset = Number.NEGATIVE_INFINITY;
        for (const r of rows){
          const rect = r.getBoundingClientRect();
          const offset = e.clientY - (rect.top + rect.height/2);
          if (offset < 0 && offset > closestOffset){
            closestOffset = offset;
            closest = r;
          }
        }
        return closest;
      })();

      if (after == null){
        list.appendChild(rmSteps_draggingRow);
      } else {
        list.insertBefore(rmSteps_draggingRow, after);
      }
    });

    list.addEventListener('drop', (e) => {
      if (!rmSteps_draggingRow) return;
      e.preventDefault();
      rmSteps_draggingRow.classList.remove('dragging');
      rmSteps_draggingRow = null;
      rmSteps_renumber();
    });

    list.dataset.dndInit = '1';
  }

  // Build one step row (prefills supported)
  function createStepRow(prefill = null) {
    const row = document.createElement('div');
    row.className = 'step-row';
    row.dataset.stepId = prefill?.id || uid8();

    row.innerHTML = `
      <div class="step-grid" style="display:grid; grid-template-rows:auto auto auto auto; gap:10px; align-items:start; margin-bottom:12px; padding:8px; border:1px solid var(--c-border,#444); border-radius:10px; max-width:100%; box-sizing:border-box; min-width:0; overflow-x:hidden;">
        <!-- Title -->
        <div class="step-header" style="display:flex; align-items:center;">
          <div class="step-title" style="font-weight:600;">Step ?</div>
          <div class="step-controls" style="margin-left:auto; display:flex; gap:8px;">
            <button type="button" class="step-up" title="Move up">▲</button>
            <button type="button" class="step-down" title="Move down">▼</button>
            <button type="button" class="step-del" title="Delete">✕</button>
          </div>
        </div>

                 <!-- Toolbar -->
        <div class="step-toolbar" style="display:flex; flex-wrap:wrap; gap:6px;">
          <button type="button" class="step-tool" data-act="task" title="Insert checkbox">Checkbox</button>
          <button type="button" class="step-tool" data-act="bullet" title="Insert bullet">• Bullet</button>
          <button type="button" class="step-tool" data-act="bold" title="Bold">Bold</button>
          <button type="button" class="step-tool" data-act="italic" title="Italic">Italic</button>
        </div>

        <!-- Textarea -->
  <textarea class="step-text" placeholder="Step instructions (Markdown supported with [ ] checkboxes)" rows="7" style="width:100%; resize:vertical; box-sizing:border-box;"></textarea>

        <!-- Timer -->
        <div class="step-timer" style="display:flex; gap:8px; align-items:center; min-width:0;">
          <label>Timer:</label>
          <input class="step-mm" type="number" min="0" max="999" inputmode="numeric" placeholder="mm" style="width:68px;">
          <span>:</span>
          <input class="step-ss" type="number" min="0" max="59"  inputmode="numeric" placeholder="ss" style="width:68px;">
        </div>

        <!-- Photo picker + preview (uses shared openPhotoPicker) -->
        <div class="step-photo" style="display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap; min-width:0;">
          <button type="button" class="step-photo-btn">Add photo</button>
          <img class="step-preview" alt="Step photo" style="max-width:120px; max-height:120px; display:none; border-radius:8px; border:1px solid var(--c-border,#444);" />
        </div>

      </div>
    `;

    // Prefill values
    if (prefill) {
      if (typeof prefill.text === 'string') row.querySelector('.step-text').value = prefill.text;
      const mm = Math.max(0, Math.floor((prefill.timerSec || 0) / 60));
      const ss = Math.max(0, (prefill.timerSec || 0) % 60);
      row.querySelector('.step-mm').value = mm ? String(mm) : '';
      row.querySelector('.step-ss').value = ss ? String(ss) : '';

      // Show existing photo preview if any
      if (prefill.photoUrl) {
        const p = row.querySelector('.step-preview');
        p.src = prefill.photoUrl;
        p.style.display = 'block';
        // Keep known paths on the row so read/save can carry them through
        row.dataset.photoUrl = prefill.photoUrl;
        if (prefill.photoPath) row.dataset.photoPath = prefill.photoPath;
        // Button label reflects existing photo
        const b = row.querySelector('.step-photo-btn');
        if (b) b.textContent = 'Change photo';
      }

    }

   // Delete
row.querySelector('.step-del').onclick = () => {
  row.remove();
  rmSteps_renumber();
  markRecipeDirty();
};

// Reorder (buttons)
row.querySelector('.step-up').onclick = () => {
  const parent = row.parentElement;
  if (parent && row.previousElementSibling) parent.insertBefore(row, row.previousElementSibling);
  rmSteps_renumber();
  markRecipeDirty();
};
row.querySelector('.step-down').onclick = () => {
  const parent = row.parentElement;
  if (parent && row.nextElementSibling) parent.insertBefore(row.nextElementSibling, row);
  rmSteps_renumber();
  markRecipeDirty();
};

// Use shared photo picker popup; preview + remember File for later upload
{
  const photoBtn = row.querySelector('.step-photo-btn');
  const img = row.querySelector('.step-preview');
  if (photoBtn) {
    photoBtn.onclick = () => {
      openPhotoPicker({
        onFile: (file) => {
          if (!file) return;
          const u = URL.createObjectURL(file);
          img.src = u;
          img.style.display = 'block';
          row._file = file; // keep the chosen file on the row for upload step
          // Clear any stale stored path when selecting a new file
          delete row.dataset.photoUrl;
          delete row.dataset.photoPath;
          // Update button label
          photoBtn.textContent = 'Change photo';
          markRecipeDirty();
        }
      });
    };
  }
}

// Step toolbar bindings
{
  const ta = row.querySelector('.step-text');
  const tools = Array.from(row.querySelectorAll('.step-tool'));

  const insert = (before = '', after = '') => {
    if (!ta) return;
    const s = ta.selectionStart ?? ta.value.length;
    const e = ta.selectionEnd ?? s;
    const val = ta.value;
    const sel = val.slice(s, e);
    const next = val.slice(0, s) + before + sel + after + val.slice(e);
    ta.value = next;

    // Caret logic:
    // - If no selection: place caret immediately after the *opening* token (inside the pair)
    // - If there was a selection: place caret after the whole inserted block
    const hadSelection = e > s;
    const pos = hadSelection ? (s + before.length + sel.length + after.length)
                             : (s + before.length);

    ta.focus({ preventScroll: true });
    try { ta.setSelectionRange(pos, pos); } catch(e) {}

    if (typeof markRecipeDirty === 'function') markRecipeDirty();
  };

  const insertLinePrefix = (prefix) => {
    if (!ta) return;
    const s = ta.selectionStart ?? 0;
    const e = ta.selectionEnd ?? 0;
    const val = ta.value;

    const lineStart = val.lastIndexOf('\n', s - 1) + 1;
    const lineEnd   = val.indexOf('\n', e);
    const end = lineEnd === -1 ? val.length : lineEnd;

    const selected = val.slice(lineStart, end);
    const replaced = selected.split('\n').map(l => (l ? prefix + l : prefix)).join('\n');

    const next = val.slice(0, lineStart) + replaced + val.slice(end);
    ta.value = next;

    // Place caret immediately after the *inserted prefix* on the FIRST affected line
    const pos = lineStart + prefix.length;

    ta.focus({ preventScroll: true });
    try { ta.setSelectionRange(pos, pos); } catch(e) {}

    if (typeof markRecipeDirty === 'function') markRecipeDirty();
  };

  tools.forEach(b => {
    b.addEventListener('click', () => {
      const act = b.dataset.act;
      if (act === 'task')   return insertLinePrefix('[ ] ');
      if (act === 'bullet') return insertLinePrefix('• ');
      if (act === 'bold')   return insert('**','**');
      if (act === 'italic') return insert('*','*');
    });
  });
}





    return row;
  }






  

  // Add one step (blank or prefill)
  function addStepRow(prefill=null){
    const list = document.getElementById('rmStepsList');
    if (!list) return;
    rmSteps_setupDnd();
    const row = createStepRow(prefill);
    list.appendChild(row);
    rmSteps_renumber();
// Bind checkbox-autocomplete to the new textarea
if (window.initStepIngredientAutocomplete) {
  window.initStepIngredientAutocomplete();
}
    // ---- Auto-assign default photo for NEW steps (no photo yet) ----
    // Tries “step N” with common extensions and base paths. If you provide files,
    // place them (for example) in /assets/steps/ as: Step 1.jpg, Step 2.png, etc.
    // If you want a custom rule, define window.resolveDefaultStepPhoto(n) => URL.
    (function autoAssignDefaultStepPhoto(){
      // Only assign when creating a NEW step or a prefill without a photo
      const hasExisting = !!(row.dataset.photoUrl || row._file);
      const fromPrefillHasPhoto = !!(prefill && prefill.photoUrl);
      if (hasExisting || fromPrefillHasPhoto) return;

      const children = Array.from(list.children);
      const index = children.indexOf(row);
      const n = index >= 0 ? (index + 1) : 0;
      if (!n) return;

      // 1) If user provided a resolver, use it
      if (typeof window.resolveDefaultStepPhoto === 'function') {
        const url = window.resolveDefaultStepPhoto(n);
        if (url && typeof url === 'string') {
          const probe = new Image();
          probe.onload = () => {
            const img = row.querySelector('.step-preview');
            if (img) {
              img.src = url;
              img.style.display = 'block';
            }
            row.dataset.photoUrl = url;
            row.dataset.photoPath = ''; // not from Storage
            const b = row.querySelector('.step-photo-btn');
            if (b) b.textContent = 'Change photo';
            if (typeof markRecipeDirty === 'function') markRecipeDirty();
          };
          probe.src = url;
          return;
        }
      }

      // 2) Fallback: try common locations and extensions
      const bases = ['', './', '/assets/steps/'];
      const names = [`Step ${n}.webp`, `Step ${n}.jpg`, `Step ${n}.jpeg`, `Step ${n}.png`];
      let i = 0;

      const tryNext = () => {
        if (i >= bases.length * names.length) return;
        const base = bases[Math.floor(i / names.length)];
        const file = names[i % names.length];
        i++;

        const url = base + file;
        const probe = new Image();
        probe.onload = () => {
          const img = row.querySelector('.step-preview');
          if (img) {
            img.src = url;
            img.style.display = 'block';
          }
          row.dataset.photoUrl = url;
          row.dataset.photoPath = ''; // not from Storage
          const b = row.querySelector('.step-photo-btn');
          if (b) b.textContent = 'Change photo';
          if (typeof markRecipeDirty === 'function') markRecipeDirty();
        };
        probe.onerror = tryNext;
        probe.src = url;
      };

      tryNext();
    })();
    // ----------------------------------------------------------------

    return row;
  }


  // Read all steps from editor into schema:
  // { id, text, timerSec|null, photoUrl|null, photoPath|null }
  function readStepsFromEditor(){
    const list = document.getElementById('rmStepsList');
    const rows = Array.from(list ? list.children : []);
    const steps = rows.map((row) => {
      const id = row.dataset.stepId || uid8();
      const text = (row.querySelector('.step-text')?.value || '').trim();
      const mm = parseInt(row.querySelector('.step-mm')?.value || '0', 10) || 0;
      const ss = parseInt(row.querySelector('.step-ss')?.value || '0', 10) || 0;
      const total = Math.max(0, (mm * 60) + Math.min(59, ss));
      if (!text) return null;

      // Keep whatever is already known on the row; uploads will update these later
      const photoUrl = row.dataset.photoUrl || null;
      const photoPath = row.dataset.photoPath || null;

      return {
        id,
        text,
        timerSec: total > 0 ? total : null,
        photoUrl,
        photoPath
      };
    }).filter(Boolean);

    return steps;
  }





  /* (removed duplicate) Using the main “Steps editor helpers (titles + drag reorder)” block above.
    This avoids overriding the version that renders the bold “Step N” title and the ≡ drag handle. */


   // Open modal for a recipe
  async function openAddToListModal(recipe){
    // Store recipe & servings info
    atlRecipe = recipe || null;
    atlBasePortions = (recipe && recipe.basePortions) ? Number(recipe.basePortions) : 2;
    atlServings = atlBasePortions;   // Always start at base portions (1×)

    // Build the ingredient list for the ATL modal:
    // 1) Prefer recipe.ingredients if provided,
    // 2) else read the current editor rows (so it still works while editing).
    if (recipe && Array.isArray(recipe.ingredients) && recipe.ingredients.length){
      atlIngredients = recipe.ingredients.map(ing => ({
        name:  (ing.name  || '').trim(),
        nameKey: (ing.name || '').toLowerCase(),
        qty:   (ing.qty   || '').trim(),
        size:  (ing.size  || '').trim(),
        notes: (ing.notes || '').trim()
      })).filter(x => x.name);
    } else {
      atlIngredients = readIngredientsFromEditor();
    }

    // Reset UI
    atlServingsEl.value = atlServings;
    if (atlSelectAll) atlSelectAll.checked = true;

    // Render the checklist based on atlIngredients
    renderAtlList();

   // Show modal
  addToListModal.classList.add('show');
  document.body.classList.add('modal-open');
  addToListModal.setAttribute('aria-hidden','false');

  // Push a history entry so Back first closes this modal
  try {
    history.pushState({ addToListOpen: true }, '');
  } catch (e) {}

  // Focus servings input for quick scaling

   
  }


  function closeAddToListModal(){
    addToListModal.classList.remove('show');
    addToListModal.setAttribute('aria-hidden','true');
    document.body.classList.remove('modal-open');

    // Pop the history entry we pushed on open
    try {
      if (history.state && history.state.addToListOpen) {
        history.back();
      }
    } catch (e) {}
  }
  // When user presses Back / swipe-back while Add-to-List is open, close it
  window.addEventListener('popstate', () => {
    try {
      if (addToListModal && addToListModal.classList.contains('show')) {
        addToListModal.classList.remove('show');
        addToListModal.setAttribute('aria-hidden','true');
        document.body.classList.remove('modal-open');
      }
    } catch (e) {}
  });


  // wire close
  if (atlClose) atlClose.onclick = closeAddToListModal;

  // servings +/- buttons
  if (atlInc) atlInc.onclick = () => {
    atlServings = Math.max(1, Number(atlServingsEl.value||atlServings) + 1);
    atlServingsEl.value = atlServings;
    renderAtlList();
  };
  if (atlDec) atlDec.onclick = () => {
    atlServings = Math.max(1, Number(atlServingsEl.value||atlServings) - 1);
    atlServingsEl.value = atlServings;
    renderAtlList();
  };

  // presets (1×, 1.5×, 2× relative to base portions)
  atlPresets.forEach(btn=>{
    btn.onclick = () => {
      const mult = parseFloat(btn.dataset.x);
      if (!Number.isFinite(mult)) return;
      atlServings = Math.max(1, Math.round(atlBasePortions * mult));
      atlServingsEl.value = atlServings;
      renderAtlList();
      // simple visual state
      atlPresets.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
    };
  });

  // keyboard ↑/↓ in servings
  if (atlServingsEl){
    atlServingsEl.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowUp'){ e.preventDefault(); atlInc.click(); }
      if (e.key === 'ArrowDown'){ e.preventDefault(); atlDec.click(); }
    });
    atlServingsEl.addEventListener('change', ()=>{
      const v = parseInt(atlServingsEl.value||atlServings, 10);
      atlServings = Number.isFinite(v) && v>0 ? v : atlServings;
      atlServingsEl.value = atlServings;
      renderAtlList();
    });
  }

  // select/deselect all
  if (atlSelectAll){
    atlSelectAll.onchange = () => {
      document.querySelectorAll('#atlList .checkrow input[type="checkbox"]').forEach(cb=>{
        cb.checked = atlSelectAll.checked;
      });
    };
  }

  // Commit: add selected ingredients (merged) to shopping list
  if (atlAddBtn) atlAddBtn.onclick = async () => {
    if (!auth || !auth.currentUser || !household) { alert('Sign in and set the household first.'); return; }
    try{
      const factor = Math.max(1, atlServings) / Math.max(1, atlBasePortions);

      const rows = Array.from(document.querySelectorAll('#atlList .checkrow'));
      const chosen = rows.filter(r => r._cb && r._cb.checked);

      if (!chosen.length){ showToast('Nothing selected'); return; }

      const batch = db.batch();

      for (const row of chosen){
        const ing = row._ing;
        const scaledQty = scaleQtyStr(ing.qty || '', factor);

        // Find existing list item
        const existing = findExistingItem(ing.nameKey || ing.name);
        if (existing){
          // merge qty
          const newQty = addQtyStr(existing.qty || '', scaledQty);
          const ref = db.collection('lists').doc(household).collection('items').doc(existing.id);
          batch.set(ref, {
            qty: newQty,
            // optionally fill size/notes if empty
            size: existing.size || ing.size || '',
            notes: existing.notes || ing.notes || '',
            checked: false, // force it back onto the Shopping list
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
         } else {
          // new item; pull category/route from catalogCache if available
          const catKnown = catalogCache.get((ing.name||'').toLowerCase()) || {};
          const ref = db.collection('lists').doc(String(household)).collection('items').doc();
          batch.set(ref, {
            name: ing.name,
            qty: scaledQty,
            size: ing.size || '',
            notes: ing.notes || '',
            category: catKnown.category || '',
            routeOrder: (catKnown.routeOrder === 0 || catKnown.routeOrder) ? catKnown.routeOrder : '',
            checked: false,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        }

      }

      // Update recipe lastUsedServings
      if (atlRecipe && atlRecipe.id){
        const rref = db.collection('recipes').doc(household).collection('recipes').doc(atlRecipe.id);
        batch.set(rref, {
          lastUsedServings: atlServings,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
        }, { merge: true });
      }

      await batch.commit();
      showToast('Added to shopping list');
      closeAddToListModal();
    } catch(e){
      console.error(e);
      alert('Add failed: ' + (e.message || e));
    }
  };

    </script>

    <script>
      // Subtle haptic on taps
      document.addEventListener('pointerdown', (e) => {
        const btn = e.target.closest('button,[role="button"]');
        if (!btn) return;
        if (btn.dataset && btn.dataset.haptic === 'off') return;
        if (navigator.vibrate) navigator.vibrate(10);
      });
    </script>
    <script>
      // Press animation on rows
      document.addEventListener('pointerdown', (e) => { const row = e.target.closest('.item'); if (row) row.classList.add('is-pressed'); });
      const clearPress = () => { document.querySelectorAll('.item.is-pressed').forEach(r => r.classList.remove('is-pressed')); };
      document.addEventListener('pointerup', clearPress);
      document.addEventListener('pointercancel', clearPress);
    </script>
  <script>
    // Minimal toast helper (smooth + tap-to-dismiss + restartable)
    (function(){
      const t = document.createElement('div');
      t.id = 'toast';
      t.className = 'toast';
      t.setAttribute('role','status');
      t.setAttribute('aria-live','polite');
      document.body.appendChild(t);

      let hideTimer = null;

      window.showToast = function(msg, {timeout = 4000} = {}){
        t.textContent = String(msg || '');
        t.classList.add('show');
        if (hideTimer) clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
          t.classList.remove('show');
          hideTimer = null;
        }, timeout);
      };

      t.addEventListener('click', () => {
        if (hideTimer) clearTimeout(hideTimer);
        t.classList.remove('show');
        hideTimer = null;
      });
    })();
  </script>


    <script>
      // Lightbox
      (function(){
        const lb = document.createElement('div');
        lb.className = 'lightbox';
        lb.innerHTML = '<img alt=""><button class="close" aria-label="Close">×</button>';
        document.body.appendChild(lb);
        const img = lb.querySelector('img');
        const close = () => lb.classList.remove('show');
        lb.addEventListener('click', (e)=>{ if (e.target===lb || e.target.classList.contains('close')) close(); });
        window.openLightbox = (src) => { img.src = src; lb.classList.add('show'); };
      })();
    </script>
    <script>
      // Enter key = Add
      (['itemName','itemQty','itemSize','itemCategory','itemRoute','itemNotes']).forEach(id => {
        const n = document.getElementById(id); if (!n) return;
        n.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.isComposing) { e.preventDefault(); const addBtn = document.getElementById('add'); if (addBtn) addBtn.click(); }
        });
      });
    </script>
  <!-- ==================== Bottom Navigation ==================== -->
  <nav class="bottom-nav" id="bottomNav">
    <!-- Left: Menu -->
    <button id="menuBtn" class="tab" type="button" aria-label="Menu">⋮</button>

    <!-- Middle: Tabs -->
    <button id="tabList" class="tab" type="button">List</button>
    <button id="tabShopping" class="tab" type="button">Shopping</button>
    <button id="tabRecipes" class="tab" type="button">Recipes</button>

    <!-- Right: Filter controls -->
    <button id="filterBtn" class="tab" type="button" aria-label="Filters">⚙️</button>
  </nav>
<!-- Weekly Items FAB (bottom-right, above nav) -->
<!-- Weekly Items FAB -->
<button id="weeklyItemsFab" class="fab btn btn-pink" type="button" style="display:none;" aria-label="Weekly Items">
  Weekly Items
</button>


  <!-- ============ Settings Menu Sheet ============ -->
  <div id="menuSheet" class="menu-sheet" aria-hidden="true">
    <div class="menu-card">
      <h3>Settings</h3>

      <label style="display:block; margin-top:10px;">
        <div>Household</div>
        <input id="household" type="text" placeholder="Household code" style="width:100%; margin-top:4px;">
      </label>
      <button id="setHousehold" style="margin-top:6px;">Set</button>

      <div style="margin-top:12px;">
        <button id="signIn" class="primary">Sign in</button>
        <button id="signOut" style="display:none">Sign out</button>
      </div>

      <div style="margin-top:12px;">
        <button id="themeToggle" type="button">🌙 Dark</button>
      </div>


      <div style="margin-top:20px; text-align:right;">
        <button id="menuClose">Close</button>
      </div>
    </div>
  </div>

  <!-- ============ Filter Sheet ============ -->
  <div id="filterSheet" class="menu-sheet" aria-hidden="true">
    <div class="menu-card">
      <h3>Filters</h3>

      <div style="margin-top:10px;">
        <label>Sort by</label>
        <select id="sortMode">
          <option value="route">Route</option>
          <option value="category">Category</option>
          <option value="name">Name</option>
        </select>
      </div>

    

      <div style="margin-top:12px;">
        <label>Filter</label>
      <select id="filterMode">
    <option value="all">All</option>
    <option value="unchecked">Unchecked</option>
    <option value="checked">Checked</option>
  </select>

      </div>

      <div style="margin-top:20px; text-align:right;">
        <button id="filterClose">Close</button>
      </div>
    </div>
  </div>

  <style>
  /* ====== Shared Menu Sheet (settings + filter) ====== */
  .menu-sheet {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.5);
    display: none;
    align-items: flex-end;
    justify-content: center;
    z-index: 12000;
  }

  .menu-sheet.show { display: flex; }

  .menu-card {
    width: 100%;
    max-width: 480px;
    background: var(--surface);
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
    box-shadow: var(--shadow-md);
    padding: 16px;
    animation: slideUp .2s ease;
  }
  @keyframes slideUp {
    from { transform: translateY(100%); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
    /* Make each ingredient row stack on small screens */
  @media (max-width: 560px) {
    .ing-row {
      grid-template-columns: 1fr; /* stack fields vertically */
    }
    /* Optional: tighten inputs a bit on phones */
    .ing-row input { min-height: 40px; }
  }


    /* ==== INGREDIENT ROW: 2×2 grid (no sideways scroll) ==== */
  .ing-row{
    display: grid;                /* JS also sets this; CSS here is the source of truth */
    grid-template-columns: minmax(0,.8fr) minmax(0,1fr);
    grid-template-rows: auto auto;
    grid-template-areas:
      "name rightTop"
      "name rightBottom";
    gap: 8px 10px;
    align-items: center;
    max-width: 100%;
  }
    /* Allow all grid children to actually shrink in their tracks */
  .ing-row > * { min-width: 0; }

  /* Belt-and-suspenders for the name wrapper/input */
  .ing-name-wrap,
  .ing-name-wrap input { min-width: 0; width: 100%; }

  /* Allow everything inside the grid to shrink when needed */
  .ing-row, .ing-row * { min-width: 0; max-width: 100%; }

  /* Explicitly uncap both left and right wrappers */
  .ing-name-wrap,
  .ing-right,
  .ing-rightTop,
  .ing-rightBottom { min-width: 0; }


  .ing-row, .ing-row * {
    min-width: 0;                 /* allow children to shrink inside grid cells */
    max-width: 100%;              /* nothing may exceed the row width */
  }

  /* Left column (spans two rows) */
  .ing-name-wrap{ grid-area: name; }
  /* Allow the name column to actually shrink */
  .ing-name-wrap { min-width: 0; }

  /* Right column, row 1: Qty + Size (wraps nicely on small widths) */
  .ing-right-top{
    grid-area: rightTop;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .ing-right-top > input{
    flex: 1 1 140px;              /* grow/shrink; start around 140px */
    width: 100%;
  }

  /* Right column, row 2: Notes + × aligned right */
  .ing-right-bottom{
    grid-area: rightBottom;
    display: grid;
    grid-template-columns: 1fr auto;   /* notes | delete */
    gap: 8px;
    align-items: center;
  }
  .ing-right-bottom .ing-notes{
    width: 100%;
  }



  /* Let any long text/tokens wrap rather than push layout wider */
  .ing-row .ing-updateTag{
    grid-column: 1 / -1;          /* show below notes+× when visible */
    white-space: normal;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  /* Mobile: single-column stack — Name → Qty/Size → Notes + × */
  @media (max-width:560px){
    .ing-row{
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto;
      grid-template-areas:
        "name"
        "rightTop"
        "rightBottom";
    }

    .ing-right-top{
      gap: 8px;
    }

    .ing-right-top > input{
      flex: 1 1 180px;           /* a bit more space on phones */
    }
  }

  @media (max-width: 560px) {
    .ing-row {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    .ing-row input {
      max-width: 100%;  /* so they wrap instead of overflowing */
    }
  }
  /* Prevent qty inputs from collapsing on short values */
  input.qtyInline{
    min-width: 4ch; /* matches JS floor */
  }
  /* === Tags UI helpers === */
  .tagchip { user-select: none; }
  .tagchip .x {
    margin-left: 6px;
    opacity: .7;
    cursor: pointer;
    font-weight: 700;
  }

  .tag-badge {
    display: inline-block;
    margin-right: 6px;
    padding: 2px 8px;
    border: 1px solid var(--chip-border);
    border-radius: 999px;
    font-size: 11px;
    opacity: .8;
    background: var(--chip);
  }

  /* === Recipe Editor: Ingredient Row (2 rows, fixed % columns) === */
  /* Row 1: [ Name 35% | Qty 32.5% | Size 32.5% ]
    Row 2: [ (empty) | Notes 55% | Delete 10% ] */
  .ing-row {
    display: grid;
    grid-template-columns: 35% 32.5% 32.5%;
    grid-template-rows: auto auto;
    gap: 3px;
    align-items: start;
    width: 100%;
  }

  /* Row 1 mapping */
  .ing-name { grid-column: 1; grid-row: 1; min-width: 0; }
  .ing-qty  { grid-column: 2; grid-row: 1; }
  .ing-size { grid-column: 3; grid-row: 1; }

  /* Row 2 mapping */
  .ing-notes {
    grid-column: 2 / 4;  /* span columns 2 and 3 */
    grid-row: 2;
    min-width: 0;
  }

  .ing-del   { grid-column: 1; grid-row: 2; justify-self: end; }
  /* Make the fields fill their grid columns */
  .ing-name,
  .ing-qty,
  .ing-size,
  .ing-notes {
    width: 100%;
    max-width: none;
    min-width: 0;
    box-sizing: border-box;
  }


  /* Inputs/textarea reset INSIDE the ingredient row */
  .ing-row textarea,
  .ing-row input {
    width: 100%;
    max-width: 100%;
    padding: 8px;
    border: 1px solid var(--chip-border);
    border-radius: 12px;
    font: inherit;
    box-sizing: border-box;
  }

  /* Tall, wrapping fields */
  .ing-name,
  .ing-notes {
    resize: none;
    height: 3.6em;      /* ~2 lines */
    line-height: 1.4;
  }

  /* Delete button appearance */
  .ing-del {
    background: var(--surface);
    border: 1px solid var(--chip-border);
    border-radius: 12px;
    padding: 8px 12px;
    cursor: pointer;
    height: 100%;
    box-sizing: border-box;
  }

  /* Optional: keep tiny mobile screens from forcing horizontal scroll */
  .ing-row > * { min-width: 0; }
  /* --- Pink buttons for the recipe modal --- */
  .btn-pink {
    background: #ff2f7d;           /* solid pink */
    color: #fff;
    border: none;
    border-radius: 10px;
    padding: 10px 14px;
    font-weight: 600;
    transition: transform .08s ease, opacity .2s ease, background-color .2s ease;
  }
  .btn-pink:hover { transform: translateY(-1px); }
  .btn-pink:active { transform: translateY(0); }
  .btn-pink[disabled] {
    opacity: .55;
    pointer-events: none;
  }

  </style>

  <script>
  /* ===== Open/Close Menu Sheet ===== */
  function openSheet(sheet) {
    sheet.classList.add('show');
    sheet.setAttribute('aria-hidden','false');
  }
  function closeSheet(sheet) {
    sheet.classList.remove('show');
    sheet.setAttribute('aria-hidden','true');
  }

  const menuBtn    = document.getElementById('menuBtn');
  const menuSheet  = document.getElementById('menuSheet');
  const menuClose  = document.getElementById('menuClose');

  const filterBtn   = document.getElementById('filterBtn');
  const filterSheet = document.getElementById('filterSheet');
  const filterClose = document.getElementById('filterClose');

  if (menuBtn) menuBtn.onclick = () => openSheet(menuSheet);
  if (menuClose) menuClose.onclick = () => closeSheet(menuSheet);
  if (menuSheet) menuSheet.addEventListener('click', (e)=>{ if(e.target===menuSheet) closeSheet(menuSheet); });

  if (filterBtn) filterBtn.onclick = () => {
  const filterModeSel = document.getElementById('filterMode');
  const sortModeSel   = document.getElementById('sortMode');

  // Show/hide blocks depending on tab
  if (filterModeSel) {
    const filterBlock = filterModeSel.closest('div');
    if (filterBlock) filterBlock.style.display = (activeTab === 'list') ? '' : 'none';
  }
  if (sortModeSel) {
    const sortBlock = sortModeSel.closest('div');
    if (sortBlock) sortBlock.style.display = (activeTab === 'list' || activeTab === 'shopping') ? '' : 'none';
  }

  // Load tab-specific sort value into the select before opening the sheet
  if (sortModeSel) {
    const key = (activeTab === 'shopping') ? 'sortMode_shopping' : 'sortMode_list';
    sortModeSel.value = localStorage.getItem(key) || 'route';
  }

  openSheet(filterSheet);
};



  if (filterClose) filterClose.onclick = () => closeSheet(filterSheet);
  if (filterSheet) filterSheet.addEventListener('click', (e)=>{ if(e.target===filterSheet) closeSheet(filterSheet); });

  if (menuBtn && menuSheet) {
      menuBtn.onclick = () => {
        menuSheet.classList.add('show');
        menuSheet.setAttribute('aria-hidden','false');
      };
    }
    if (menuClose) {
      menuClose.onclick = () => {
        menuSheet.classList.remove('show');
        menuSheet.setAttribute('aria-hidden','true');
      };
    }
    // Close if clicking backdrop
    if (menuSheet) {
      menuSheet.addEventListener('click', (e)=>{
        if (e.target === menuSheet) {
          menuSheet.classList.remove('show');
          menuSheet.setAttribute('aria-hidden','true');
        }
      });
    }

    // ===== Bottom nav tabs (single source of truth) =====
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#tabList, #tabShopping, #tabRecipes');
    if (!btn) return;

    const idToTab = { tabList: 'list', tabShopping: 'shopping', tabRecipes: 'recipes' };
    const tab = idToTab[btn.id];
    if (!tab) return;

    // Let setActiveTab() handle both the highlight and the view
    if (typeof setActiveTab === 'function') setActiveTab(tab);
  });


    // ===== THEME TOGGLE (moved into menu) =====
    const root = document.documentElement;
    const themeBtn = document.getElementById('themeToggle');

    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      root.setAttribute('data-theme', 'dark');
      themeBtn.textContent = '☀️ Light';
    } else {
      root.setAttribute('data-theme', 'light');
      themeBtn.textContent = '🌙 Dark';
    }

    themeBtn.onclick = () => {
      const current = root.getAttribute('data-theme');
      if (current === 'dark') {
        root.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
        themeBtn.textContent = '🌙 Dark';
      } else {
        root.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        themeBtn.textContent = '☀️ Light';
      }
    };
  </script>







  <script>
    // Handle clicks for the bottom nav (single listener)
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tabList, #tabShopping, #tabRecipes');
      if (!btn) return;

      const idToTab = { tabList: 'list', tabShopping: 'shopping', tabRecipes: 'recipes' };
      const tab = idToTab[btn.id];
      if (!tab) return;

      // Visual state
      document.querySelectorAll('.bottom-nav .tab').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
     


      // Persist + render using your existing function
localStorage.setItem('activeTab', tab);
if (typeof setActiveTab === 'function') setActiveTab(tab);





    });

  // Sync the active highlight on page load
(function syncBottomNav(){
  const current = localStorage.getItem('activeTab') || 'list';

  const el = {
    list: document.getElementById('tabList'),
    shopping: document.getElementById('tabShopping'),
    recipes: document.getElementById('tabRecipes')
  };

  // first remove all active classes
  Object.values(el).forEach(b => b && b.classList.remove('active'));

  // then add the active class to the correct tab
  if (el[current]) el[current].classList.add('active');


})();

  </script>


  <script>
  document.addEventListener('DOMContentLoaded', () => {
      // === Bind Sort/Filter now that the Filter Sheet is in the DOM ===
    sortModeEl = document.getElementById('sortMode');
    filterModeEl = document.getElementById('filterMode');

  // === Bind Sort/Filter now that the Filter Sheet is in the DOM ===
  sortModeEl   = document.getElementById('sortMode');
  filterModeEl = document.getElementById('filterMode');

  // Sort (per tab)
if (sortModeEl) {

  // one-time migration from legacy single key → per-tab keys
  (function migrateLegacySortKey(){
    const legacy = localStorage.getItem('sortMode');
    if (legacy && !localStorage.getItem('sortMode_list') && !localStorage.getItem('sortMode_shopping')) {
      localStorage.setItem('sortMode_list', legacy);
      localStorage.setItem('sortMode_shopping', legacy);
      // keep legacy around harmlessly; no delete needed
    }
  })();

  // When the dropdown changes, save to the active tab's key and repaint
  sortModeEl.onchange = () => {
    const key = (activeTab === 'shopping') ? 'sortMode_shopping' : 'sortMode_list';
    localStorage.setItem(key, sortModeEl.value);
    scheduleRenderItems(lastSnapshotItems || []);
  };
}


  // Filter
  if (filterModeEl) {
    const savedFilter = localStorage.getItem('filterMode');
    if (savedFilter) filterModeEl.value = savedFilter;
    filterModeEl.onchange = () => {
      localStorage.setItem('filterMode', filterModeEl.value);
      // Use the same renderer you use elsewhere
      scheduleRenderItems(lastSnapshotItems || []);
    };
  }


    if (filterModeEl) {
      const savedFilter = localStorage.getItem('filterMode');
      if (savedFilter) filterModeEl.value = savedFilter;

      filterModeEl.onchange = () => {
        localStorage.setItem('filterMode', filterModeEl.value);
        render(lastSnapshotItems || []);
      };
    }

  // Single delegated click handler so duplicates of buttons still work
    document.addEventListener('click', async (e) => {
      // Set household
      if (e.target.closest('#setHousehold')) {
        household = document.getElementById('household').value.trim();
        localStorage.setItem('household', household);
        setHouseholdUI();
        subscribeList();
        subscribeRecipes();
        ensureHouseholdDoc().catch(()=>{});
        updateStatus();
        return;
      }

    // Sign in
  if (e.target.closest('#signIn')) {
    try {
      const email = prompt("Enter email:");
      const password = prompt("Enter password:");
      if (!email || !password) return;
      await auth.signInWithEmailAndPassword(email, password);
  if (typeof closeSheet === 'function') { const ms = document.getElementById('menuSheet'); if (ms) closeSheet(ms); }

      // Always show the generic toast
      showToast("Signed in as " + email);

      // 🔴 Custom toast for Ines
      if (email.toLowerCase() === "ines@ines.com") {
        showToast("Logged in as Schnucki.  Ich liebe dich!!! 💖");
      }

        } catch (e2) {
          if (e2.code === 'auth/user-not-found') {
            alert("No user found. Ask admin to add you in Firebase.");
          } else if (e2.code === 'auth/wrong-password') {
            alert("Wrong password.");
          } else {
            alert("Sign-in failed: " + (e2.message || e2));
          }
        }
        return;
      }

      // Sign out
      if (e.target.closest('#signOut')) {
        try {
          await auth.signOut();
          showToast("Signed out");
        } catch (e3) {
          alert("Sign-out failed: " + (e3.message || e3));
        }
        return;
      }
    });

  }); // <-- correctly close DOMContentLoaded

  const savedTab = localStorage.getItem('activeTab') || 'list';
  if (typeof setActiveTab === 'function') setActiveTab(savedTab);


  try {
    const cachedItems = JSON.parse(localStorage.getItem('cache_items') || '[]');
    if (Array.isArray(cachedItems) && cachedItems.length) {
      lastSnapshotItems = cachedItems;
      render(cachedItems);
    }
  } catch {}
  // If no cache, show skeleton until Firestore snapshot lands
  if (!lastSnapshotItems || !lastSnapshotItems.length) {
    showListSkeleton();
  }

  try {
    const cachedRecipes = JSON.parse(localStorage.getItem('cache_recipes') || '[]');
    if (Array.isArray(cachedRecipes) && cachedRecipes.length) {
      lastSnapshotRecipes = cachedRecipes;
      renderRecipes(cachedRecipes);
    }
  } catch {}
  </script>


  <style>
  /* ——— skeleton styles (lightweight) ——— */
  .item.skeleton { pointer-events:none; opacity:.85; }
  .item.skeleton .sk-line,
  .item.skeleton .sk-box,
  .item.skeleton .sk-chip,
  .item.skeleton .sk-btn {
    background: linear-gradient(90deg,
      color-mix(in oklab, var(--chip) 92%, transparent) 25%,
      color-mix(in oklab, var(--chip) 80%, transparent) 37%,
      color-mix(in oklab, var(--chip) 92%, transparent) 63%
    );
    background-size: 400% 100%;
    animation: sk-shimmer 1.2s ease-in-out infinite;
    border-radius: 8px;
  }
  @keyframes sk-shimmer {
    0% { background-position: 100% 0; }
    100% { background-position: 0 0; }
  }
  </style>
  <style>
  /* ——— layout stabilizers ——— */
  .item { min-height: 70px; }                   /* row won’t collapse during first paint */
  .line1 { min-height: 22px; display:block; }   /* title line steady */
  .thumb { width:44px; height:44px; }           /* avoid reflow when images load */
  .qty-inline { min-height: 32px; }             /* consistent control height */
  </style>
  <script>
  // ===================== List Show/Hide toggle (with persistence) =====================
  (function(){
    // Elements
    var listSection = document.getElementById('listSection');
    var toggleBtn   = document.getElementById('toggleListItemsButton');

    // Safety: if the button isn't present yet, do nothing
    if (!listSection || !toggleBtn) return;

    // LocalStorage key
    var LS_KEY = 'listCollapsed'; // "true" or "false" as strings

    // Helper: apply a given collapsed boolean to DOM + button label
    function applyCollapsed(collapsed){
      // 1) Attribute on section (drives CSS hide rule)
      if (collapsed) {
        listSection.setAttribute('data-list-collapsed', 'true');
      } else {
        listSection.removeAttribute('data-list-collapsed');
      }

      // 2) Button label + aria state
      if (collapsed) {
        toggleBtn.textContent = '🔽 Show items';
        toggleBtn.setAttribute('aria-pressed', 'false');
      } else {
        toggleBtn.textContent = '🔼 Hide items';
        toggleBtn.setAttribute('aria-pressed', 'true');
      }
    }

    // Read saved preference
    var saved = localStorage.getItem(LS_KEY);

    // Starting state logic:
    // - If saved is "true" or "false", use it.
    // - If nothing saved, default to collapsed (hidden).
    var startCollapsed;
    if (saved === 'true') {
      startCollapsed = true;
    } else if (saved === 'false') {
      startCollapsed = false;
    } else {
      startCollapsed = true; // default hidden
    }

    // Apply starting state (this also corrects the button text)
    applyCollapsed(startCollapsed);

    // Click to toggle
    toggleBtn.addEventListener('click', function(){
      var currentlyCollapsed = listSection.hasAttribute('data-list-collapsed');
      var nextCollapsed = !currentlyCollapsed;

      applyCollapsed(nextCollapsed);
      localStorage.setItem(LS_KEY, String(nextCollapsed));
    });
  })();
  </script>

  </script>

  <script id="markdown-sanitize">
  /*
    Minimal Markdown → Safe HTML utilities:
    - Supported: **bold**, *italic*, `code`, [text](url), hard line breaks
    - Task markers `[ ]` and `[x]` are preserved as plain text for step 4
    - Sanitizer allow-list blocks scripts, event handlers, javascript: URLs, etc.
    - Usage: const html = window.renderMarkdownSafe(stepText);
  */
  (function(){
    // Basic HTML escape
    function escapeHtml(str){
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    // Very small Markdown subset → HTML (no HTML passthrough)
    function mdToHtml(md){
      if (!md) return "";
      // Work on an escaped base to avoid raw HTML injection
      let s = escapeHtml(md);

      // Inline code: `code`
      s = s.replace(/`([^`]+)`/g, "<code>$1</code>");

      // Bold: **text**
      s = s.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");

      // Italic: *text* (simple form; avoids overlap with **bold**)
      s = s.replace(/(^|[^\*])\*([^*\n]+)\*(?!\*)/g, "$1<em>$2</em>");

      // Links: [text](url)  — allow only http(s) protocols
      s = s.replace(/\[([^\]]+)\]\(([^)\s]+)\)/g, function(_, text, href){
        try {
          const u = new URL(href, location.href);
          const safe = (u.protocol === "http:" || u.protocol === "https:");
          return safe ? '<a href="' + escapeHtml(u.href) + '" rel="noopener noreferrer" target="_blank">' + escapeHtml(text) + '</a>'
                      : escapeHtml("[" + text + "](" + href + ")");
        } catch(e){
          return escapeHtml("[" + text + "](" + href + ")");
        }
      });

      // Preserve single newlines as <br> and double newlines as paragraph breaks
      // Split into paragraphs by two or more newlines
      const parts = s.split(/\n{2,}/).map(p => p.replace(/\n/g, "<br>"));
      return parts.map(p => "<p>" + p + "</p>").join("");
    }

    // Strict sanitizer for the HTML we produce
    function sanitizeHtml(html){
      // Create a detached DOM to sanitize
      const tpl = document.createElement("template");
      tpl.innerHTML = html;

      const ALLOWED_TAGS = new Set(["P","BR","STRONG","EM","CODE","A"]);
      const ALLOWED_ATTR = {
        "A": new Set(["href","rel","target"])
      };

      function isSafeUrl(url){
        try {
          const u = new URL(url, location.href);
          return (u.protocol === "http:" || u.protocol === "https:");
        } catch(e){
          return false;
        }
      }

      (function walk(node){
        // Remove disallowed elements
        if (node.nodeType === 1) {
          const tag = node.tagName;
          if (!ALLOWED_TAGS.has(tag)) {
            // Replace unknown element with its textContent
            const txt = document.createTextNode(node.textContent || "");
            node.replaceWith(txt);
            return;
          }

          // Strip all attributes not on the allow-list, and strip event handlers
          for (const attr of Array.from(node.attributes)) {
            const name = attr.name.toLowerCase();
            const allowed = ALLOWED_ATTR[tag] && ALLOWED_ATTR[tag].has(attr.name);
            const isEvent = name.startsWith("on");
            if (isEvent) {
              node.removeAttribute(attr.name);
              continue;
            }
            if (!allowed) {
              node.removeAttribute(attr.name);
              continue;
            }
            // For <a>, validate href protocol; otherwise drop
            if (tag === "A" && name === "href" && !isSafeUrl(attr.value)) {
              node.removeAttribute(attr.name);
            }
          }
        }

        // Recurse
        for (const child of Array.from(node.childNodes)) {
          walk(child);
        }
      })(tpl.content);

      return tpl.innerHTML;
    }

    function renderMarkdownSafe(mdText){
      const raw = mdToHtml(mdText || "");
      const safe = sanitizeHtml(raw);

      // Convert [ ] and [x] into checkboxes (unchecked/checked)
      // This must run AFTER sanitization
      return safe
        .replace(/\[ \]/g, '<input type="checkbox" class="md-task" />')
        .replace(/\[x\]/gi, '<input type="checkbox" class="md-task" checked />');
    }

    // Expose for app use
    window.sanitizeHtml = sanitizeHtml;
    window.renderMarkdownSafe = renderMarkdownSafe;
  })();
  </script>

  </script>

  <script id="cook-session-state">
  /*
    Cook Session state for task checkboxes (+ 12h session expiry).
    - Persists in localStorage under "cookSession.v1"
    - Cross-tab sync via BroadcastChannel "cookSession"
    - Backward compatible with prior shape: value could be a plain map OR { map, lastUsedAt }.
    - Usage:
        const html = renderMarkdownSafe(text);
        container.innerHTML = html;
        cookSession.attachTaskCheckboxBinding(container, "recipe:<recipeId>:step:<stepId>");
  */
  (function(){
    const LS_KEY = "cookSession.v1";
    const CH_NAME = "cookSession";
    const SESSION_TTL_MS = 12 * 60 * 60 * 1000; // 12 hours
    const bc = ("BroadcastChannel" in self) ? new BroadcastChannel(CH_NAME) : null;

    function now(){ return Date.now(); }

    function readStore(){
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
      catch(e){ return {}; }
    }
    function writeStore(store){
      localStorage.setItem(LS_KEY, JSON.stringify(store));
      if (bc) bc.postMessage({ type:"storeUpdated" });
    }

    // Normalize an entry for a given context key.
    // Returns { map:Object<string,bool>, lastUsedAt:number|null }
    function readEntry(contextKey){
      const s = readStore();
      const v = s[contextKey];
      if (!v) return { map: {}, lastUsedAt: null };
      if (v && typeof v === 'object' && v.map && (typeof v.map === 'object')) {
        return { map: v.map || {}, lastUsedAt: Number(v.lastUsedAt || 0) || null };
      }
      // legacy shape: plain map of indices -> boolean
      return { map: (typeof v === 'object' ? v : {}), lastUsedAt: null };
    }

    function isExpired(entry){
      if (!entry) return false;
      if (!entry.lastUsedAt) return false; // legacy entries without timestamp are treated as active until first touch
      return (now() - entry.lastUsedAt) > SESSION_TTL_MS;
    }

    // Public-style helpers that keep backward compatibility
    function getContext(contextKey){
      const entry = readEntry(contextKey);
      // If expired, return empty — attach() will refresh/store & notify.
      return isExpired(entry) ? {} : entry.map;
    }

    function setContext(contextKey, map){
      const s = readStore();
      s[contextKey] = { map: map || {}, lastUsedAt: now() };
      writeStore(s);
    }

    function clearContext(contextKey){
      const s = readStore();
      if (s.hasOwnProperty(contextKey)) {
        delete s[contextKey];
        writeStore(s);
      }
    }

    // Ensure a fresh session for this context key.
    // If expired, clears and writes an empty fresh entry, and returns true (meaning it reset).
    function ensureFresh(contextKey){
      const s = readStore();
      const entry = readEntry(contextKey);
      if (isExpired(entry)) {
        s[contextKey] = { map: {}, lastUsedAt: now() };
        writeStore(s);
        // Friendly one-line notice if the host app has a toast function
        try { if (typeof window.showToast === 'function') window.showToast('Started a fresh cooking session — checkmarks reset.'); } catch {}
        return true;
      }
      // Touch the timestamp so an actively-open session doesn’t expire mid-cook
      s[contextKey] = { map: entry.map || {}, lastUsedAt: now() };
      writeStore(s);
      return false;
    }

    // Attach behavior to a container that already has .md-task inputs
    function attachTaskCheckboxBinding(containerEl, contextKey){
      if (!containerEl || !contextKey) return;

      // Auto-expire/refresh if needed (also updates lastUsedAt)
      ensureFresh(contextKey);

      const inputs = Array.from(containerEl.querySelectorAll('input.md-task'));
      const saved = getContext(contextKey);

      // Index each checkbox (stable order in current render)
      inputs.forEach((inp, idx) => {
        if (!inp.dataset.taskIndex) inp.dataset.taskIndex = String(idx);
        const i = inp.dataset.taskIndex;
        if (Object.prototype.hasOwnProperty.call(saved, i)) {
          inp.checked = !!saved[i];
        }
      });

      // Change handler (delegated per container)
      const onChange = (ev) => {
        const t = ev.target;
        if (!(t instanceof HTMLInputElement)) return;
        if (!t.classList.contains('md-task')) return;
        const i = t.dataset.taskIndex || "0";
        const map = getContext(contextKey);
        map[i] = !!t.checked;
        setContext(contextKey, map); // updates lastUsedAt on every interaction
      };

      // Avoid duplicate listeners
      detach(containerEl);
      containerEl.addEventListener('change', onChange);
      containerEl._cookTaskHandler = onChange;

      // Return a cleanup function for callers (e.g., when closing Cook Mode)
      return () => detach(containerEl);
    }

    function detach(containerEl){
      if (containerEl && containerEl._cookTaskHandler) {
        containerEl.removeEventListener('change', containerEl._cookTaskHandler);
        delete containerEl._cookTaskHandler;
      }
    }

    // Optional: react to cross-tab updates (no-op unless a view wants to re-apply)
    if (bc) {
      bc.onmessage = (e) => {
        // Views can re-apply saved states if necessary.
        // Cook Mode rebinds on slide show; nothing needed here.
      };
    }

    // Expose API
    window.cookSession = {
      attachTaskCheckboxBinding,
      clearContext
    };
  })();
  </script>


  <!-- ==================== Cook Mode Modal (full-screen) ==================== -->
  <style id="cook-mode-styles">
    #cookModeModal { position: fixed; inset: 0; display: none; z-index: 100002; }
    #cookModeOverlay { position:absolute; inset:0; background:rgba(0,0,0,.6); }
    #cookModeSheet {
      position:absolute; inset:0;
      background: var(--cook-bg, #0b0b0b);
      color: var(--cook-fg, #f0f0f0);
      display:flex; flex-direction:column;
    }
    #cookModeHeader {
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.2); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    #cookModeTitle { font-weight:600; font-size:16px; opacity:.9; }
    #cookModeClose { border:1px solid rgba(255,255,255,.2); background:#111; color:#eee; border-radius:10px; padding:8px 10px; }
    #cookModeBody { flex:1; overflow:auto; -webkit-overflow-scrolling:touch; }
    .cookStepPage { display:flex; flex-direction:column; gap:12px; padding:14px; min-height:100%; }
    .cookPhoto { width:100%; max-height:40vh; object-fit:cover; border-radius:12px; border:1px solid rgba(255,255,255,.08); background:#111; }

    /* Timer card */
    #cookTimerCard {
      border:1px solid rgba(255,255,255,.15); background:#101010; border-radius:12px; padding:10px 12px;
      display:flex; flex-direction:column; gap:8px;
    }
    #cookTimerTop { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    #cookTimerLabel { font-weight:600; }
    #cookTimerMeta { font-size:12px; opacity:.85; }
    #cookTimerProgress { height:6px; background:#161616; border-radius:6px; overflow:hidden; border:1px solid rgba(255,255,255,.1); }
    #cookTimerProgress > div { height:100%; width:0%; background:#ff4081; }
    #cookTimerRow { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .cookBtn {
      border:1px solid rgba(255,255,255,.2); background:#121212; color:#eee;
      padding:10px 14px; border-radius:12px;
    }
    .tbtn { border:1px solid rgba(255,255,255,.25); background:#151515; color:#eee; border-radius:10px; padding:6px 10px; font-size:13px; }

    .cookMeta { display:flex; align-items:center; justify-content:space-between; font-size:14px; opacity:.9; }
    .cookNav { display:flex; gap:8px; }
    #cookStepBody { font-size:16px; line-height:1.5; }
    #cookStepBody p { margin: 0 0 10px; }
    #cookStepBody code { padding:0 4px; border-radius:6px; background:#111; border:1px solid rgba(255,255,255,.15); }
    #cookStepBody a { color:#8ab4ff; text-decoration:underline; }
    #cookSwipeRegion { position:absolute; inset:0; pointer-events:none; }
  </style>

  <div id="cookModeModal" aria-hidden="true">
    <div id="cookModeOverlay"></div>
    <div id="cookModeSheet" role="dialog" aria-modal="true" aria-label="Cook Mode">
      <div id="cookModeHeader">
    <div id="cookModeTitle">Cook Mode</div>
    <div class="cookNav">
      <button id="cookModeClose" type="button">Close</button>
    </div>
  </div>


      <div id="cookModeBody">
        <div class="cookStepPage">
<div id="cookPhotoWrap" style="position:relative;">
  <img id="cookStepPhoto" class="cookPhoto" alt="" />
  <button id="cookStepPhotoBtn" type="button" title="Change photo"
          style="position:absolute; right:10px; bottom:10px; display:none;
                 border-radius:999px; padding:6px 10px; font-size:12px;
                 border:1px solid rgba(255,255,255,.25);
                 background:#151515; color:#eee;">
    Change photo
  </button>
</div>

          <!-- Timer controls (per-step) -->
          <div id="cookTimerCard">
            <div id="cookTimerTop">
              <div id="cookTimerLabel">Timer</div>
              <div id="cookTimerMeta">--:--</div>
            </div>
            <div id="cookTimerProgress"><div></div></div>
            <div id="cookTimerRow">
    <button id="cookTimerStart" class="tbtn" type="button">Start</button>
    <button id="cookTimerPause" class="tbtn" type="button" style="display:none;">Pause</button>
    <button id="cookTimerResume" class="tbtn" type="button" style="display:none;">Resume</button>
    <button id="cookTimerReset" class="tbtn" type="button" style="display:none;">Reset</button>

    <div class="tbtn" id="cookM10s" role="button">–10s</div>
    <div class="tbtn" id="cookM1" role="button">–1m</div>

    <div class="tbtn" id="cookS1" role="button">+1m</div>
    
    <button id="cookTimerStop" class="tbtn" type="button" style="margin-left:auto;">Stop</button>
  </div>

          </div>

          <div class="cookMeta"><div id="cookStepCount">Step –</div></div>
          <div id="cookStepBody"></div>
        </div>
        <div id="cookSwipeRegion"></div>
      </div>
    </div>
  </div>

  <script id="cook-mode-module">
  /*
    Cook Mode with per-step Timer controls
    - window.cookMode.open(recipe, startIndex=0)
    - Integrates with global window.timers store
    - NOTE: Scope all queries to the *last* Cook Mode modal in the DOM to avoid duplicate-ID conflicts.
  */
  (function(){
    // --- Singleton guard: avoid binding Cook Mode twice when duplicate blocks exist.
    if (window.__cookModeSingletonLoaded) { return; }
    window.__cookModeSingletonLoaded = true;

    // Always target the *last* Cook Mode modal (the one with timers/text/photo wired up)
    const modals = document.querySelectorAll('#cookModeModal');
    const modal  = modals[modals.length - 1];

    // Scope all element lookups *within* that modal
    const overlay   = modal.querySelector('#cookModeOverlay');
    const sheet     = modal.querySelector('#cookModeSheet');
    const btnClose  = modal.querySelector('#cookModeClose');
    const elCount   = modal.querySelector('#cookStepCount');
    const elBody    = modal.querySelector('#cookStepBody');
    const elPhoto   = modal.querySelector('#cookStepPhoto');
    const elPhotoBtn = modal.querySelector('#cookStepPhotoBtn');
const showPhotoBtn = (show) => { if (elPhotoBtn) elPhotoBtn.style.display = show ? '' : 'none'; };

    // Listen for touch on the scrollable body instead of the overlay (which is non-blocking)
    const swipeRegion = modal.querySelector('#cookModeBody');



  // Timer UI refs (scoped to the selected modal)
  const tLabel  = modal.querySelector('#cookTimerLabel');
  const tMeta   = modal.querySelector('#cookTimerMeta');
  const tProg   = modal.querySelector('#cookTimerProgress > div');
  const btnStart  = modal.querySelector('#cookTimerStart');
  const btnPause  = modal.querySelector('#cookTimerPause');
  const btnResume = modal.querySelector('#cookTimerResume');
  const btnReset  = modal.querySelector('#cookTimerReset');
  const btnStop   = modal.querySelector('#cookTimerStop');
  const btnM10s   = modal.querySelector('#cookM10s');
  const btnM1     = modal.querySelector('#cookM1');
  const btnS1     = modal.querySelector('#cookS1');
  



    let state = {
      recipe: null,
      index: 0,
      cleanupTasksBinding: null,
      listenersBound: false,
      touch: { startX:0, startY:0, active:false },
      unsubTimers: null
    };

    // Helpers
    function fmt(ms){
      ms = Math.max(0, ms|0);
      const s = Math.floor(ms/1000);
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      return (hh>0? (String(hh).padStart(2,'0')+':'):'') + String(mm).padStart(2,'0')+':'+String(ss).padStart(2,'0');
    }
    function now(){ return Date.now(); }
    function remainingFor(t){
      if (!t) return 0;
      if (t.isPaused) return Math.max(0, t.remainingMs|0);
      if (t.endsAt == null) return 0;
      return Math.max(0, t.endsAt - now());
    }
    function progressFor(t){
      if (!t) return 0;
      const total = t.durationMs || (t.remainingMs||0);
      if (!total) return 0;
      const rem = remainingFor(t);
      const done = total - rem;
      return Math.max(0, Math.min(1, done/total));
    }
    function findTimerForStep(recipeId, stepId, stepIndex){
  if (!window.timers || typeof window.timers.list !== 'function') return null;
  const arr = window.timers.list();
  return arr.find(t => t.context
    && String(t.context.recipeId||'') === String(recipeId||'')
    && String(t.context.stepId||'') === String(stepId||'')
    && Number(t.context.stepIndex||0) === Number(stepIndex||0)
  ) || null;
}

// --- Cook progress (resume last step) ---------------------------------
const PROG_LS_KEY = 'cookProgress.v1';
const PROG_TTL_MS = 12 * 60 * 60 * 1000; // 12h, matches cookSession vibe

function _readProgStore(){
  try { return JSON.parse(localStorage.getItem(PROG_LS_KEY) || '{}'); }
  catch { return {}; }
}
function _writeProgStore(s){
  localStorage.setItem(PROG_LS_KEY, JSON.stringify(s));
}
function _getSavedIndex(recipeId){
  if (!recipeId) return null;
  const s = _readProgStore();
  const e = s[String(recipeId)];
  if (!e) return null;
  const ts = Number(e.lastUsedAt || 0);
  if (!Number.isFinite(ts) || (Date.now() - ts) > PROG_TTL_MS) return null; // expired
  const idx = Number(e.index);
  return Number.isFinite(idx) ? idx : null;
}
function _saveIndex(recipeId, index){
  if (!recipeId) return;
  const s = _readProgStore();
  s[String(recipeId)] = { index: Number(index)||0, lastUsedAt: Date.now() };
  _writeProgStore(s);
}
function _clearIndex(recipeId){
  if (!recipeId) return;
  const s = _readProgStore();
  delete s[String(recipeId)];
  _writeProgStore(s);
}


    function open(recipe, startIndex=0){
      if (!recipe) return;

      // Allow recipes with no steps; treat as empty array
      const stepsArr = Array.isArray(recipe.steps) ? recipe.steps : [];

      // Shallow-clone to avoid mutating the caller; ensure steps is always an array
      state.recipe = Object.assign({}, recipe, { steps: stepsArr });

      // Clamp index; if no steps, index will be 0 and UI will show "No steps"
// Prefer saved index if fresh; otherwise use caller's startIndex
let desired = startIndex|0;
try {
  const saved = _getSavedIndex(state.recipe && state.recipe.id);
  if (saved != null) desired = saved;
} catch {}
// Clamp index correctly: allow 0 (prep) through steps.length (last step)
const maxIdx = stepsArr.length; 
state.index = Math.max(0, Math.min(desired, maxIdx));
// Touch timestamp so the entry stays fresh while cooking
try { _saveIndex(state.recipe && state.recipe.id, state.index); } catch {}

        render();
      show();
      if (window.timers && typeof window.timers.unlockAudio === 'function') {
        window.timers.unlockAudio();
      }


      if (!state.listenersBound) {
        bindListeners();
        state.listenersBound = true;
      }

      // Subscribe to global timers for structural changes (pause/resume/stop/snooze)
      if (window.timers && typeof window.timers.subscribe === 'function') {
        if (state.unsubTimers) state.unsubTimers();
        state.unsubTimers = window.timers.subscribe(() => updateTimerUI());
      }

      // Lightweight UI tick so the countdown/progress animates between store writes
      if (!window.__cookUITick){
        let last = 0, raf = 0;
        const loop = (ts) => {
          if (!modal || modal.style.display !== 'block') { window.__cookUITick = null; cancelAnimationFrame(raf); return; }
          if (!last || (ts - last) >= 200) { // ~5 fps
            updateTimerUI();
            last = ts;
          }
          raf = requestAnimationFrame(loop);
        };
        window.__cookUITick = true;
        raf = requestAnimationFrame(loop);
      }
    }


    

      // Unique history key for Cook Mode
    const COOK_MODE_STATE_KEY = 'cookModeOpen';

    function show(){
      modal.style.display = 'block';
      sheet.focus?.();
      document.documentElement.style.overflow = 'hidden';
      document.body.classList.add('modal-open');

      // Push a history entry so Android Back will first close this modal
      try {
        history.pushState({ [COOK_MODE_STATE_KEY]: true }, '');
      } catch(e){}
    }

    function hide(){
      modal.style.display = 'none';
      document.documentElement.style.overflow = '';
      document.body.classList.remove('modal-open');
    }

    // If user presses Back (or swipe-back) while Cook Mode is visible, close it
    function onCookModePopState(){
      try {
        if (modal.style.display === 'block') {
          // Close without adding another history entry
          unbindListeners();
          state.listenersBound = false;
          state.recipe = null;
          state.index = 0;
          hide();
        }
      } catch(e){}
    }
    window.addEventListener('popstate', onCookModePopState);

    // When closing via UI, also pop the history entry we added on open
    function maybePopCookHistory(){
      try {
        if (history.state && history.state[COOK_MODE_STATE_KEY]) {
          history.back();
        }
      } catch(e){}
    }



    function close(){
      if (typeof state.cleanupTasksBinding === 'function') {
        state.cleanupTasksBinding();
        state.cleanupTasksBinding = null;
      }
      if (state.unsubTimers) { state.unsubTimers(); state.unsubTimers = null; }
      try { if (window.__cookUITick) { window.__cookUITick = null; } } catch {}
      unbindListeners();
      state.listenersBound = false;
      state.recipe = null;
      state.index = 0;
      hide();
      // Pop the history entry we pushed in show()
      maybePopCookHistory();
    }



    function next(){
      if (!state.recipe) return;
      const steps = state.recipe.steps || [];
      if (state.index < steps.length) setIndex(state.index + 1); // +1 to allow "prep" at index 0
    }


    function prev(){
      if (!state.recipe) return;
      if (state.index > 0) setIndex(state.index - 1);
    }

  function setIndex(i){
  if (typeof state.cleanupTasksBinding === 'function') {
    state.cleanupTasksBinding();
    state.cleanupTasksBinding = null;
  }
  state.index = i;
  // save progress (prep = 0, steps start at 1)
  try { _saveIndex(state.recipe && state.recipe.id, state.index); } catch {}
  render();
  updateTimerUI();
}


    function render(){
     const steps = state.recipe.steps || [];
      const isPrep = state.index === 0;
      const step = isPrep ? null : (steps[state.index - 1] || { text:"", photoUrl:null });
      const total = (steps.length || 0) + 1; // include prep page
      const n = isPrep ? 0 : state.index;


      // If on prep page (index 0): render ingredients checklist + progress and skip normal step rendering
      if (isPrep) {
        if (elPhoto) { elPhoto.removeAttribute('src'); elPhoto.style.display = 'none'; elPhoto.alt = ''; }
        const timerCard = modal.querySelector('#cookTimerCard');
        if (timerCard) timerCard.style.display = 'none';

        elCount.textContent = 'Ingredients';

        const ings = Array.isArray(state.recipe.ingredients) ? state.recipe.ingredients : [];
        const total = ings.length;

        if (!total) {
          elBody.innerHTML = '<p>No ingredients.</p>';
          return;
        }

        // Header with counter, progress bar, and Start Again button
        const headerHTML = `
          <div id="prepHeader" style="display:flex; align-items:center; gap:10px; justify-content:space-between; margin-bottom:8px;">
            <div id="prepCounter" style="font-weight:600;">0 / ${total} prepped</div>
            <div style="flex:1; height:6px; background:#161616; border:1px solid rgba(255,255,255,.12); border-radius:6px; overflow:hidden; margin:0 10px;">
              <div id="prepProg" style="height:100%; width:0%; background:#3a86ff;"></div>
            </div>
            <button id="prepReset" class="tbtn" type="button">Start Again</button>
          </div>
        `;

        const listHTML = '<ul style="margin:0; padding-left:18px;">' + ings.map((ing,i) => {
          const text = [ing.qty, ing.size, ing.name, ing.notes].filter(Boolean).join(' ').replace(/\s+/g,' ').trim();
          return `<li style="margin:6px 0;"><label><input type="checkbox" class="md-task" data-task-index="${i}"> ${text}</label></li>`;
        }).join('') + '</ul>';

        const hintHTML = `
          <div style="margin-top:12px; text-align:center; font-size:0.9em; opacity:0.8;">
            Swipe to See Step&nbsp;1 →
          </div>
        `;

        elBody.innerHTML = headerHTML + listHTML + hintHTML;

        const recipeId = state.recipe.id || 'temp';
        const contextKey = `recipe:${recipeId}:step:prep`;
        if (window.cookSession && typeof window.cookSession.attachTaskCheckboxBinding === 'function') {
          state.cleanupTasksBinding = window.cookSession.attachTaskCheckboxBinding(elBody, contextKey);
        }

        // Progress updater
        const counterEl = elBody.querySelector('#prepCounter');
        const progEl    = elBody.querySelector('#prepProg');
        const inputs    = Array.from(elBody.querySelectorAll('input.md-task'));

        const updatePrepProgress = () => {
          const done = inputs.filter(i => i.checked).length;
          if (counterEl) counterEl.textContent = `${done} / ${total} prepped`;
          if (progEl)    progEl.style.width = total ? Math.round((done/total)*100) + '%' : '0%';
        };

        // Update on any change
        elBody.addEventListener('change', (e) => {
          if (e.target && e.target.classList && e.target.classList.contains('md-task')) {
            updatePrepProgress();
          }
        });

        // "Start Again" — clear saved context + uncheck all
        const resetBtn = elBody.querySelector('#prepReset');
        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            if (window.cookSession && typeof window.cookSession.clearContext === 'function') {
              window.cookSession.clearContext(contextKey);
            }
            inputs.forEach(i => { i.checked = false; });
            updatePrepProgress();
          });
        }

              // Initial paint reflects persisted checks
        updatePrepProgress();
        return; // do not run the normal step path
      }

      // ← ensure timer is visible on real step pages
      const timerCard = modal.querySelector('#cookTimerCard');
      if (timerCard) timerCard.style.display = '';

      // Photo



      // Photo
      if (step.photoUrl) {

        elPhoto.src = step.photoUrl;
        elPhoto.style.display = '';
        elPhoto.alt = state.recipe.name ? `${state.recipe.name} – Step ${n}` : `Step ${n}`;
      } else {
        elPhoto.removeAttribute('src');
        elPhoto.style.display = 'none';
        elPhoto.alt = '';
      }
      showPhotoBtn(!isPrep);

      // Count
      elCount.textContent = (steps.length > 0) ? `Step ${n} of ${steps.length}` : 'No steps';

      // Body (Markdown → safe HTML with clickable checkboxes)
      elBody.innerHTML = (window.renderMarkdownSafe ? window.renderMarkdownSafe(step.text || '') : (step.text || ''));
      const recipeId = state.recipe.id || 'temp';
      const stepId = step.id || String(state.index - 1);
      const contextKey = `recipe:${recipeId}:step:${stepId}`;
      if (window.cookSession && typeof window.cookSession.attachTaskCheckboxBinding === 'function') {
        state.cleanupTasksBinding = window.cookSession.attachTaskCheckboxBinding(elBody, contextKey);
      }

      // Timer label default
      tLabel.textContent = step.timerSec ? `Timer • ${Math.floor(step.timerSec/60)}m ${step.timerSec%60}s` : 'Timer';
      updateTimerUI();
    }

   function currentStepContext(){
  const steps = state.recipe.steps || [];
  const idx = Math.max(0, state.index - 1);         // adjust for prep at index 0
  const step = steps[idx] || {};
  return {
    recipeId: state.recipe.id || 'temp',
    stepId: step.id || String(idx),
    stepIndex: idx,
    // Optional hook for drawer "Open Step"
    goTo: () => { window.cookMode && window.cookMode.setIndex && window.cookMode.setIndex(state.index); }
  };
}


    function updateTimerUI(){
  const steps = state.recipe?.steps || [];
  const idx = Math.max(0, state.index - 1);
  const step = steps[idx] || {};

      const ctx = currentStepContext();
      const timer = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);

      if (!timer) {
        // No active timer: show Start (uses step.timerSec if present; else 1m default)
        btnStart.style.display = '';
        btnPause.style.display = 'none';
        btnResume.style.display = 'none';
        btnReset.style.display = 'none';
        if (btnStop) {
          btnStop.textContent = 'Stop';
          if (btnStop.classList) btnStop.classList.remove('btn-pink');
        }
        tMeta.textContent = step.timerSec ? fmt(step.timerSec * 1000) : '--:--';
        tProg.style.width = '0%';
        return;
      }

      const rem = remainingFor(timer);
      const p = Math.round(progressFor(timer) * 100);
      const isDone = !!timer.isDone;

      tMeta.textContent = (timer.isPaused ? 'Paused · ' : '') + fmt(rem);
      tProg.style.width = p + '%';

      // Toggle controls
      btnStart.style.display = 'none';
      btnPause.style.display = timer.isPaused || isDone ? 'none' : '';
      btnResume.style.display = timer.isPaused && !isDone ? '' : 'none';
      btnReset.style.display = isDone ? 'none' : ''; // hide Reset if done (we're offering Silence & Reset on Stop)

        // Change Stop button label when finished (swap style to match other pink buttons)
      if (btnStop) {
        if (isDone) {
          btnStop.textContent = 'Silence & Reset';
          btnStop.className = 'btn-pink';
        } else {
          btnStop.textContent = 'Stop';
          btnStop.className = 'tbtn';
        }
      }

    }



    function createStepTimer(){
  const steps = state.recipe.steps || [];
  const idx = Math.max(0, state.index - 1);
  const step = steps[idx] || {};
  const ctx = currentStepContext();
  const label = (state.recipe.name ? state.recipe.name + ' – ' : '') + `Step ${state.index}`;
  const durationMs = (Number.isFinite(step.timerSec) ? step.timerSec*1000 : 60_000);

      // Include recipe snapshot for optional “Open Step” from the drawer
      const context = { ...ctx, recipe: { id: state.recipe.id, name: state.recipe.name, steps: state.recipe.steps } };
      const id = window.timers.create({ label, durationMs, context });
      return id;
    }

 function resetStepTimer(){
  const steps = state.recipe.steps || [];
  const idx = Math.max(0, state.index - 1);
  const step = steps[idx] || {};
  const ctx = currentStepContext();

      const timer = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
      if (timer) window.timers.stop(timer.id);
      createStepTimer();
    }

    // Bind timer buttons
  btnStart.addEventListener('click', () => {   if (window.timers && window.timers.unlockAudio) window.timers.unlockAudio();   createStepTimer();   updateTimerUI(); });

  btnPause.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t) window.timers.pause(t.id);
  });

  btnResume.addEventListener('click', () => {
    if (window.timers && window.timers.unlockAudio) window.timers.unlockAudio();
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t) window.timers.resume(t.id);
  });


  btnReset.addEventListener('click', () => {
    if (window.timers && window.timers.unlockAudio) window.timers.unlockAudio();
    resetStepTimer();
  });

  btnStop.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (!t) { updateTimerUI(); return; }

    // Always just stop the timer — when done this serves as "Silence & Reset"
    window.timers.stop(t.id);

    updateTimerUI();
  });




  // –10s / –1m
  if (btnM10s) btnM10s.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t && window.timers.adjust) window.timers.adjust(t.id, -10*1000);
  });
  if (btnM1) btnM1.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t && window.timers.adjust) window.timers.adjust(t.id, -60*1000);
  });

  // +N minutes
  btnS1.addEventListener('click', () => {
    const ctx = currentStepContext(); const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex); if (t) window.timers.snooze(t.id,1);
  });

// Cook Mode: change the current step photo
if (typeof elPhotoBtn !== 'undefined' && elPhotoBtn) {
  elPhotoBtn.addEventListener('click', () => {
    if (!state || !state.recipe) return;

    const steps = Array.isArray(state.recipe.steps) ? state.recipe.steps : [];
    const idx = state.index - 1; // UI is 1-based for steps; 0 = prep
    if (idx < 0 || idx >= steps.length) return;

    const step = steps[idx] || {};
    const stepId = step.id || String(idx + 1);
    const recipeId = state.recipe.id;

    if (typeof openPhotoPicker !== 'function') {
      alert('Photo picker not available.');
      return;
    }

    openPhotoPicker({
      onFile: async (file) => {
        if (!file) return;
        try {
          const prevPath = step.photoPath || null;
          const { url, path } = await uploadStepPhoto(file, recipeId, stepId, prevPath);

          // Update local state + image
          step.photoUrl = url;
          step.photoPath = path;
          steps[idx] = step;

          if (elPhoto) {
            elPhoto.src = url;
            elPhoto.style.display = '';
            elPhoto.alt = state.recipe.name ? `${state.recipe.name} – Step ${idx + 1}` : `Step ${idx + 1}`;
          }

          // Persist to Firestore
          try {
            await db.collection('recipes').doc(household)
              .collection('recipes').doc(recipeId)
              .set({
                steps: steps,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
              }, { merge: true });
          } catch (e) {
            console.warn('Failed to save updated step photo to Firestore:', e);
          }

          if (typeof showToast === 'function') showToast('Photo updated');
        } catch (e) {
          console.error(e);
          alert('Upload failed: ' + (e.message || e));
        }
      }
    });
  });
}


    // Navigation + swipe
    function bindListeners(){
    btnClose.addEventListener('click', close);
    overlay.addEventListener('click', close);
    document.addEventListener('keydown', onKey);

    swipeRegion.addEventListener('touchstart', onTouchStart, { passive:true });
    swipeRegion.addEventListener('touchmove', onTouchMove, { passive:true });
    swipeRegion.addEventListener('touchend', onTouchEnd);
  }
  function unbindListeners(){
    btnClose.removeEventListener('click', close);
    overlay.removeEventListener('click', close);
    document.removeEventListener('keydown', onKey);
    swipeRegion.removeEventListener('touchstart', onTouchStart);
    swipeRegion.removeEventListener('touchmove', onTouchMove);
    swipeRegion.removeEventListener('touchend', onTouchEnd);
  }

    function onKey(e){
      if (modal.style.display !== 'block') return;
      if (e.key === 'ArrowRight') next();
      else if (e.key === 'ArrowLeft') prev();
      else if (e.key === 'Escape') close();
    }
    function onTouchStart(ev){
      const t = ev.changedTouches && ev.changedTouches[0];
      if (!t) return;
      state.touch.active = true;
      state.touch.startX = t.clientX;
      state.touch.startY = t.clientY;
    }
    function onTouchMove(ev){}
    function onTouchEnd(ev){
      if (!state.touch.active) return;
      const t = ev.changedTouches && ev.changedTouches[0];
      state.touch.active = false;
      if (!t) return;
      const dx = t.clientX - state.touch.startX;
      const dy = t.clientY - state.touch.startY;
      if (Math.abs(dx) > 50 && Math.abs(dx) > Math.abs(dy)) { if (dx < 0) next(); else prev(); }
    }

    // Public API
    window.cookMode = { open, close, next, prev, setIndex };
  })();

/* (intentionally blank) — legacy modal open/close removed; the FAB swapper script owns this now */




    
  </script>


 <!-- ==================== Timers: Chip + Drawer ==================== -->
<style id="timer-ui-styles">

  #timerChip {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100000;
    background: #121212;
    color: #eee;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 999px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: 0 4px 18px rgba(0, 0, 0, 0.4);
  }

  #timerChip[hidden] { display: none; }

  #timerChip .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #3ddc97;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  #timerChipCount { font-weight: 600; }

  #timerDrawer {
    position: fixed;
    inset: auto 0 0 0;
    z-index: 100000;
    display: none;
  }

  #timerDrawer[open] { display: block; }

  #timerDrawerOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
  }

  #timerDrawerSheet {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    background: #0b0b0b;
    color: #eee;
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
    box-shadow: 0 -8px 28px rgba(0, 0, 0, 0.6);
    max-height: 75vh;
    overflow: auto;
  }

  #timerDrawerHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 12px 14px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  }

  #timerDrawerTitle { font-weight: 700; }

  #timerDrawerClose {
    border: 1px solid rgba(255, 255, 255, 0.25);
    background: #121212;
    color: #eee;
    border-radius: 10px;
    padding: 8px 10px;
  }

  #timerList {
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .timerCard {
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 12px;
    padding: 10px 12px;
    background: #101010;
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    align-items: center;
  }

  .timerMain { display: flex; flex-direction: column; gap: 6px; }
  .timerLabel { font-weight: 600; }
  .timerMeta { font-size: 12px; opacity: 0.8; }
  .timerRow { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }

  .timerProgress {
    height: 6px;
    background: #161616;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .timerProgress > div {
    height: 100%;
    width: 0%;
    background: #3a86ff;
  }

  .tbtn {
    border: 1px solid rgba(255, 255, 255, 0.25);
    background: #151515;
    color: #eee;
    border-radius: 10px;
    padding: 6px 10px;
    font-size: 13px;
  }

  @media (min-width: 520px) {
    .timerCard { grid-template-columns: 1fr auto; }
  }

  /* --- Sticky “Timer Done” bar --- */
  #timerDoneBar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--surface);
    border-top: 2px solid var(--border);
    padding: 10px;
    display: none;
    z-index: 999999;
  }

  #timerDoneBar.show { display: block; }

  #timerDoneBar .inner {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
  }

  #timerDoneMsg { font-weight: 600; flex: 1; }

  #timerDoneBar .bar-btn {
    border: 1px solid rgba(255, 255, 255, 0.25);
    background: #111;
    color: #eee;
    border-radius: 10px;
    padding: 8px 12px;
  }

</style>



  <button id="timerChip" type="button" hidden>
    <span class="dot"></span>
    <span id="timerChipCount">0</span>
    <span>Timers</span>
  </button>

  <div id="timerDrawer">
    <div id="timerDrawerOverlay"></div>
    <div id="timerDrawerSheet" role="dialog" aria-modal="true" aria-label="Timers">
      <div id="timerDrawerHeader">
        <div id="timerDrawerTitle">Timers</div>
        <button id="timerDrawerClose" type="button">Close</button>
      </div>
      <div id="timerList"></div>
    </div>
  </div>

  <!-- Sticky “Timer Done” bar (hidden until a timer finishes) -->
  <div id="timerDoneBar" role="alert" aria-live="assertive">
    <div class="inner">
      <div id="timerDoneMsg">Timer done</div>
      <button id="timerDoneOpen" class="bar-btn" type="button">Open</button>
      <button id="timerDoneAck" class="bar-btn" type="button" aria-label="Acknowledge alarm">Acknowledge</button>
    </div>
  </div>

  <script id="timer-core-module">
  /*
    Timers core + UI (Chip + Drawer) — with DONE alarm + notifications
    - Persistence: localStorage "timers.v1" (backward compatible; adds optional isDone:boolean)
    - Cross-tab: BroadcastChannel "timers"
    - Countdown derived from endsAt (avoid drift)
    - Alarm: WebAudio loop (unlocked on first user gesture), Notification API + vibration, sticky “Timer Done” bar
    - Public API (window.timers):
        create({label, durationMs, context}) -> id
        pause(id) / resume(id) / stop(id) / snooze(id, minutes)
        list() / subscribe(cb) -> unsubscribe()
        unlockAudio() / requestNotifyPermission()
  */
  (function(){
    // --- Singleton guard: if another copy of this script exists in the page, do nothing.
    if (window.__timersSingletonLoaded) { return; }
    window.__timersSingletonLoaded = true;

    const LS_KEY = "timers.v1";
    const CH_NAME = "timers";
    const bc = ("BroadcastChannel" in self) ? new BroadcastChannel(CH_NAME) : null;

    // ===== Alarm sound file (MP3/WAV/OGG) =====
    // Put your file next to index.html as "alarm.mp3", or set this to a Firebase Storage download URL.
  const ALARM_URL = 'alarm.mp3';

    const chip = document.getElementById('timerChip');
    const chipCount = document.getElementById('timerChipCount');
    const drawer = document.getElementById('timerDrawer');
    const drawerOverlay = document.getElementById('timerDrawerOverlay');
    const drawerClose = document.getElementById('timerDrawerClose');
    const listEl = document.getElementById('timerList');

    // Sticky “done” bar
    const doneBar = document.getElementById('timerDoneBar');
    const doneMsg = document.getElementById('timerDoneMsg');
    const doneAck = document.getElementById('timerDoneAck');
    const doneOpen = document.getElementById('timerDoneOpen');
    // ---------- Screen Wake (keep display on while timers run) ----------
    let wakeLock = null;
    const hasWakeLock = !!(navigator && navigator.wakeLock);

    // iOS fallback (no Wake Lock API): keep a muted 1s video looping
    let _iosVideo = null;
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent || '') && !hasWakeLock;

    function startIOSSilentVideo(){
      if (!isIOS) return;
      // If already present, just play again
      if (_iosVideo) { try { _iosVideo.play(); } catch(e){} return; }

      const v = document.createElement('video');
      v.setAttribute('playsinline','');
      v.muted = true;
      v.loop = true;
      v.src = 'silent-1s.mp4';  // ⟵ put a tiny 1s silent MP4 next to index.html
      Object.assign(v.style, {
        position:'fixed', width:'1px', height:'1px', opacity:'0',
        pointerEvents:'none', bottom:'0', left:'0', zIndex:'-1'
      });
      document.body.appendChild(v);
      _iosVideo = v;
      try { v.play(); } catch(e){}
    }

    function stopIOSSilentVideo(){
      if (!_iosVideo) return;
      try { _iosVideo.pause(); } catch(e){}
      try { _iosVideo.remove(); } catch(e){}
      _iosVideo = null;
    }

    async function requestScreenWakeLock(){
      try {
        if (hasWakeLock) {
          if (wakeLock) return; // already locked
          wakeLock = await navigator.wakeLock.request('screen');
          // If the lock is released by the UA (e.g., system changes), clear our handle
          wakeLock.addEventListener?.('release', () => { wakeLock = null; });
        } else {
          // iOS fallback
          startIOSSilentVideo();
        }
      } catch(e){
        // Best effort: ignore failures
        console.warn('Wake lock request failed:', e);
      }
    }

    function releaseScreenWakeLock(){
      try {
        if (wakeLock) { wakeLock.release?.(); }
      } catch(e){}
      wakeLock = null;
      stopIOSSilentVideo();
    }

    function anyRunning(){
      // Any timer with an active countdown (not paused, not done)
      const arr = list();
      return arr.some(t => !t.isPaused && !t.isDone && t.endsAt != null);
    }

    function maybeUpdateWakeLock(){
      try {
        if (document.visibilityState !== 'visible') {
          // Page not visible — don’t try to hold the screen on
          releaseScreenWakeLock();
          return;
        }
        if (anyRunning()) {
          requestScreenWakeLock();
        } else {
          releaseScreenWakeLock();
        }
      } catch(e){}
    }

    // ---------- Store ----------
    function uid8(){
      try {
        const a = new Uint8Array(8);
        (self.crypto||window.crypto).getRandomValues(a);
        return Array.from(a,x=>x.toString(16).padStart(2,'0')).join('');
      } catch(e){
        return (Date.now().toString(36)+Math.random().toString(36).slice(2,10)).slice(0,16);
      }
    }

    function now(){ return Date.now(); }

    function readStore(){
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); }
      catch(e){ return []; }
    }
    function writeStore(arr){
      localStorage.setItem(LS_KEY, JSON.stringify(arr));
      if (bc) bc.postMessage({ type:"storeUpdated" });
      notify();
      // Keep screen awake if any timer is actively running
      try { maybeUpdateWakeLock(); } catch(e){}
    }


    function list(){ return readStore(); }
    function getById(id){ return list().find(t => t.id === id); }

    function create({label, durationMs, context}){
      const id = uid8();
      const createdAt = now();
      const t = {
        id, label: String(label||'Timer'),
        durationMs: Math.max(0, durationMs|0),
        // Calculate endsAt from now (running)
        endsAt: createdAt + Math.max(0, durationMs|0),
        remainingMs: null,
        isPaused: false,
        isDone: false,          // NEW (back-compat; absent means false)
        context: context || null,
        createdAt
      };
      const arr = list();
      arr.push(t);
      writeStore(arr);
      return id;
    }

    function pause(id){
      const arr = list();
      const i = arr.findIndex(t => t.id === id);
      if (i === -1) return;
      const t = arr[i];
      if (!t.isPaused && !t.isDone) {
        const rem = Math.max(0, (t.endsAt||0) - now());
        t.remainingMs = rem;
        t.endsAt = null;
        t.isPaused = true;
        arr[i] = t;
        writeStore(arr);
      }
    }

    function resume(id){
      const arr = list();
      const i = arr.findIndex(t => t.id === id);
      if (i === -1) return;
      const t = arr[i];
      if (t.isPaused && !t.isDone) {
        const rem = Math.max(0, t.remainingMs|0);
        t.endsAt = now() + rem;
        t.remainingMs = null;
        t.isPaused = false;
        arr[i] = t;
        writeStore(arr);
      }
    }

    function stop(id){
      const arr = list().filter(t => t.id !== id);
      writeStore(arr);
      if (!list().some(x => x.isDone)) stopAlarm(); // if no more done timers, stop alarm
      if (!list().length) hideDoneBar();
    }

    function snooze(id, minutes){
      const add = Math.max(1, minutes|0) * 60_000;
      const arr = list();
      const i = arr.findIndex(t => t.id === id);
      if (i === -1) return;
      const t = arr[i];
      // Snoozing a done timer restarts it
      if (t.isDone) {
        t.isDone = false;
        t.isPaused = false;
        t.remainingMs = null;
        t.endsAt = now() + add;
      } else if (t.isPaused) {
        t.remainingMs = Math.max(0, (t.remainingMs||0) + add);
      } else {
        const rem = Math.max(0, (t.endsAt||0) - now()) + add;
        t.endsAt = now() + rem;
      }
      arr[i] = t;
      writeStore(arr);
      hideDoneBar();
      if (!list().some(x => x.isDone)) stopAlarm();
    }

  // Adjust remaining time by an arbitrary delta (ms). Negative = subtract.
  function adjust(id, deltaMs){
    const delta = (deltaMs|0);
    const arr = list();
    const i = arr.findIndex(t => t.id === id);
    if (i === -1) return;
    const t = arr[i];
    if (t.isDone) return; // no-op for completed timers
    if (t.isPaused) {
      t.remainingMs = Math.max(0, (t.remainingMs||0) + delta);
    } else if (t.endsAt != null) {
      const rem = Math.max(0, (t.endsAt||0) - now()) + delta;
      t.endsAt = now() + Math.max(0, rem);
    }
    arr[i] = t;
    writeStore(arr);
  }

    // ---------- Subscriptions ----------
    const subs = new Set();


    function subscribe(cb){
      subs.add(cb);
      cb(list());
      return () => subs.delete(cb);
    }
    function notify(){
      for (const cb of Array.from(subs)) cb(list());
    }
    if (bc) bc.onmessage = (e) => {
      if (e && e.data && e.data.type === 'storeUpdated') notify();
    };

    // ---------- Alarm engine (WebAudio) ----------
    let audioUnlocked = false;
    let ac = null;
    // File-based alarm nodes
    let alarmBuffer = null;     // decoded AudioBuffer
    let alarmSrc = null;        // current AudioBufferSourceNode
    let alarmGain = null;       // GainNode to control volume/fades
    let alarmTimer = 0;         // legacy interval (not used for file playback; kept for safety)


  async function unlockAudio(){
  if (audioUnlocked) return;
  try {
    ac = ac || new (window.AudioContext || window.webkitAudioContext)();
    try { if (ac.state === 'suspended') await ac.resume(); } catch(e){}
    const n = ac.createOscillator();
    const g = ac.createGain();
    n.type = 'sine';
    n.frequency.value = 880;
    g.gain.value = 0;
    n.connect(g); g.connect(ac.destination);
    n.start();
    // brief click to unlock
    g.gain.setValueAtTime(0.0001, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.05);
    setTimeout(() => { try{ n.stop(); }catch(e){} }, 120);
    audioUnlocked = (ac.state === 'running');

    // --- NEW: Preload & decode alarm buffer right now (once) ---
    if (!alarmBuffer && ac && typeof fetch === 'function') {
      try {
        const res = await fetch(ALARM_URL, { cache: 'force-cache' });
        const arr = await res.arrayBuffer();
        if (ac.decodeAudioData.length === 1) {
          alarmBuffer = await ac.decodeAudioData(arr);
        } else {
          alarmBuffer = await new Promise((resolve, reject) => {
            ac.decodeAudioData(arr, resolve, reject);
          });
        }
      } catch(e){
        console.error('Failed to preload alarm sound:', e);
      }
    }
  } catch(e){}
}


        async function playAlarm(){
      // Ensure AudioContext exists and is running
      if (!ac) {
        try { ac = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}
      }
      if (!ac) return;
      try { if (ac.state === 'suspended') await ac.resume(); } catch(e){}

      // If already playing, do nothing (idempotent guard)
      if (alarmSrc) {
        return;
      }

      // Load & decode the alarm buffer once (cached)
      async function ensureAlarmBuffer(){
        if (alarmBuffer) return alarmBuffer;
        try {
          const res = await fetch(ALARM_URL, { cache: 'force-cache' });
          const arr = await res.arrayBuffer();
          // Some browsers require callback form; try promise first, fallback below
          if (ac.decodeAudioData.length === 1) {
            alarmBuffer = await ac.decodeAudioData(arr);
          } else {
            alarmBuffer = await new Promise((resolve, reject) => {
              ac.decodeAudioData(arr, resolve, reject);
            });
          }
        } catch(e){
          console.error('Failed to load alarm sound:', e);
          alarmBuffer = null;
        }
        return alarmBuffer;
      }

      const buf = await ensureAlarmBuffer();
      if (!buf) return;

      // Build a fresh graph and start looping the audio file
      try {
        alarmSrc = ac.createBufferSource();
        alarmSrc.buffer = buf;
        alarmSrc.loop = true;

        alarmGain = ac.createGain();
        // Small fade-in to avoid click
        const t = ac.currentTime;
        alarmGain.gain.cancelScheduledValues(t);
        alarmGain.gain.setValueAtTime(0.0001, t);
        alarmGain.gain.exponentialRampToValueAtTime(0.8, t + 0.08);

        alarmSrc.connect(alarmGain);
        alarmGain.connect(ac.destination);
        alarmSrc.start();
      } catch(e){
        console.error('Failed to start alarm playback:', e);
      }

      // Clear any legacy interval (no pulsing needed for file playback)
      clearInterval(alarmTimer);
      alarmTimer = 0;
    }



    function stopAlarm(){
      clearInterval(alarmTimer);
      alarmTimer = 0;

      // Smooth fade-out, then stop and tear down the file source
      if (alarmGain && ac) {
        try {
          const t = ac.currentTime;
          alarmGain.gain.cancelScheduledValues(t);
          alarmGain.gain.setValueAtTime(alarmGain.gain.value || 0.8, t);
          alarmGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);
        } catch(e){}
      }

      // Stop after the short fade
      setTimeout(() => {
        try { if (alarmSrc) alarmSrc.stop(); } catch(e){}
        try { if (alarmSrc) alarmSrc.disconnect(); } catch(e){}
        try { if (alarmGain) alarmGain.disconnect(); } catch(e){}
        alarmSrc = null;
        alarmGain = null;
      }, 120);
    }

    // ---------- Notifications ----------
    function requestNotifyPermission(){

      try {
        if (!("Notification" in window)) return;
        if (Notification.permission === 'default') Notification.requestPermission().catch(()=>{});
      } catch(e){}
    }
    function vibrate(){
      try { if ('vibrate' in navigator) navigator.vibrate([200, 100, 200, 100, 400]); } catch(e){}
    }
    function sendNotification(t){
  try {
    if (!("Notification" in window)) return;
    if (Notification.permission !== 'granted') return;
    const title = 'Timer done';
    const body  = String(t?.label || 'Timer');

    // Prefer Service Worker notifications so they fire in the background
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready
        .then(reg => {
          reg.showNotification(title, {
            body,
            tag: 'timers',        // collapse/replace previous
            renotify: true,       // play sound again if needed
            requireInteraction: false, // let it auto-dismiss per OS
          });
        })
        .catch(()=>{ /* fall back below */ });
    }

    // Fallback: page-level Notification (foreground only)
    const n = new Notification(title, { body, tag: 'timers', renotify:true });
    n.onclick = () => { window.focus?.(); try { n.close(); } catch{} };
  } catch(e){}
}

    // ---------- UI: Chip + Drawer + Done Bar ----------
    function openDrawer(){
      drawer.setAttribute('open','');
      renderList();
      unlockAudio();
      requestNotifyPermission();
    }
    function closeDrawer(){
      drawer.removeAttribute('open');
    }
    chip.addEventListener('click', openDrawer);
    drawerOverlay.addEventListener('click', closeDrawer);
    drawerClose.addEventListener('click', closeDrawer);

    function showDoneBar(t){
      if (!t) return;
      doneMsg.textContent = `⏰ Timer done: ${String(t.label||'Timer')}`;
      doneBar.classList.add('show');
    }
    function hideDoneBar(){ doneBar.classList.remove('show'); }

  // Delegated clicks so buttons work even if the bar is rebuilt/moved
  document.addEventListener('click', (ev) => {
    const t = ev.target;
    if (!t || !(t instanceof HTMLElement)) return;

    if (t.id === 'timerDoneAck') {
      // Acknowledge all currently-done timers, but keep the bar visible
      const arr = list();
      let mutated = false;
      for (const itm of arr) {
        if (itm && itm.isDone && !itm.isDoneAck) {
          itm.isDoneAck = true;
          mutated = true;
        }
      }
      if (mutated) writeStore(arr);
      // Stop the alarm sound, but do NOT hide the bar here
      stopAlarm();
    } else if (t.id === 'timerDoneOpen') {
      // Prefer the first unacknowledged done timer; fall back to any done timer
      const arr = list();
      const firstDone = arr.find(x => x.isDone && !x.isDoneAck) || arr.find(x => x.isDone);
      if (firstDone && firstDone.context) {
        try {
          if (typeof firstDone.context.goTo === 'function') {
            firstDone.context.goTo();
          } else if (firstDone.context.recipe && Array.isArray(firstDone.context.recipe.steps)) {
            cookMode.open(firstDone.context.recipe, (Number(firstDone.context.stepIndex||0)|0) + 1);
          }
        } catch(e){}
      }
    }
  });



    // Render loop (throttled) — also promotes timers to "done" and fires alarm
    let rafId = 0, lastTick = 0;
    function tick(ts){
      if (!lastTick) lastTick = ts;
      const elapsed = ts - lastTick;
      if (elapsed >= 200) { // ~5 fps is enough for countdown text & progress
        // Promote completed timers to done
        const arr = list();
        let mutated = false;
        for (const t of arr) {
          if (!t.isDone && !t.isPaused && t.endsAt != null && (t.endsAt - now()) <= 0) {
            t.isDone = true;
            t.endsAt = now();      // clamp
            t.remainingMs = 0;
            mutated = true;
          }
        }
        if (mutated) writeStore(arr);

            const arrNow = list();
        const anyDone = arrNow.some(x => x.isDone);
        const firstUnacked = arrNow.find(x => x.isDone && !x.isDoneAck);
        const toShow = firstUnacked || arrNow.find(x => x.isDone);

        if (anyDone && toShow) {
          // Keep the bar visible if *any* done timer exists,
          // but only play/vibrate/notify for unacknowledged ones
          showDoneBar(toShow);
          if (firstUnacked) {
            playAlarm();
            vibrate();
            sendNotification(firstUnacked);
          }
        } else {
          // No done timers remaining — hide bar and ensure alarm is stopped
          hideDoneBar();
          stopAlarm();
        }



        renderChip();
        if (drawer.hasAttribute('open')) renderList();
        lastTick = ts;
      }
      rafId = requestAnimationFrame(tick);
    }
    rafId = requestAnimationFrame(tick);
    
// Background-safe tick: promotes finished timers & posts OS notification
setInterval(() => {
  try {
    // Promote completed timers to done (same rule as in rAF tick)
    const arr = list();
    let mutated = false;
    for (const t of arr) {
      if (!t.isDone && !t.isPaused && t.endsAt != null && (t.endsAt - Date.now()) <= 0) {
        t.isDone = true;
        t.endsAt = Date.now();
        t.remainingMs = 0;
        mutated = true;
      }
    }
    if (mutated) writeStore(arr);

    // Decide whether to show the bar / notify
    const arrNow = list();
    const anyDone = arrNow.some(x => x.isDone);
    const firstUnacked = arrNow.find(x => x.isDone && !x.isDoneAck);
    const toShow = firstUnacked || arrNow.find(x => x.isDone);

    if (anyDone && toShow) {
      showDoneBar(toShow);
      // In background, rely on OS notification (audio may be blocked)
      if (firstUnacked) {
        sendNotification(firstUnacked);
        // Only play sound when visible (mobile blocks autoplay in background)
        if (document.visibilityState === 'visible') { try { playAlarm(); } catch{} }
      }
    } else {
      hideDoneBar();
      try { stopAlarm(); } catch{}
    }
  } catch {}
}, 1000);

    function fmt(ms){
      ms = Math.max(0, ms|0);
      const s = Math.floor(ms/1000);
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      return (hh>0? (String(hh).padStart(2,'0')+':'):'') + String(mm).padStart(2,'0')+':'+String(ss).padStart(2,'0');
    }

    function remainingFor(t){
      if (t.isDone) return 0;
      if (t.isPaused) return Math.max(0, t.remainingMs|0);
      if (t.endsAt == null) return 0;
      return Math.max(0, t.endsAt - now());
    }

    function progressFor(t){
      const total = (t.isPaused ? (t.remainingMs||t.durationMs) : t.durationMs);
      const rem = remainingFor(t);
      if (!total) return 0;
      const done = total - rem;
      return Math.max(0, Math.min(1, done/total));
    }

    function renderChip(){
      const arr = list();
      const active = arr.length;
      chipCount.textContent = String(active);
      chip.hidden = (active === 0);
    }

    function renderList(){
      const arr = list();
      if (arr.length === 0) {
        listEl.innerHTML = `<div style="opacity:.8; padding:10px 12px;">No active timers.</div>`;
        return;
      }
      listEl.innerHTML = arr.map(t => {
        const done = !!t.isDone;
        const rem = done ? 0 : remainingFor(t);
        const p = Math.round((done ? 100 : progressFor(t)*100));
        const ctx = (t.context && (t.context.recipeId || t.context.stepId)) ? `recipe:${t.context.recipeId||''} step:${t.context.stepId||''}` : '';
        const meta = done ? 'Done · 00:00' : (t.isPaused ? 'Paused' : 'Running') + ' · ' + fmt(rem) + (ctx ? ' · '+sanitizeHtml(ctx) : '');
        return `
          <div class="timerCard" data-id="${t.id}">
            <div class="timerMain">
              <div class="timerLabel">${sanitizeHtml(String(t.label||'Timer'))}</div>
              <div class="timerRow"><div class="timerMeta">${meta}</div></div>
              <div class="timerProgress"><div style="width:${p}%"></div></div>
            </div>
            <div class="timerRow">
              ${done
                ? `<button class="tbtn act-open" type="button">Open Step</button>
                  <button class="tbtn act-s1" type="button">+1m</button>
                  <button class="tbtn act-s3" type="button">+3m</button>
                  <button class="tbtn act-s5" type="button">+5m</button>
                  <button class="tbtn act-s10" type="button">+10m</button>
                  <button class="tbtn act-stop" type="button">Stop</button>`
                : (t.isPaused
                    ? `<button class="tbtn act-resume" type="button">Resume</button>`
                    : `<button class="tbtn act-pause" type="button">Pause</button>`)
              }
              ${done ? '' : `
                <div class="tbtn act-m10s" role="button">–10s</div>
                <div class="tbtn act-m1" role="button">–1m</div>
                <div class="tbtn act-s1" role="button">+1m</div>
                <div class="tbtn act-s3" role="button">+3m</div>
                <div class="tbtn act-s5" role="button">+5m</div>
                <div class="tbtn act-s10" role="button">+10m</div>
                <button class="tbtn act-open" type="button">Open Step</button>
                <button class="tbtn act-stop" type="button">Stop</button>
              `}
            </div>
          </div>
        `;
      }).join('');
    }


    // Delegated actions
    listEl.addEventListener('click', (ev) => {
      const card = ev.target.closest('.timerCard');
      if (!card) return;
      const id = card.getAttribute('data-id');
      if (!id) return;

      if (ev.target.classList.contains('act-pause')) {
        pause(id);
      } else if (ev.target.classList.contains('act-resume')) {
        resume(id);
      } else if (ev.target.classList.contains('act-s1')) {
        snooze(id, 1);
      } else if (ev.target.classList.contains('act-s3')) {
        snooze(id, 3);
      } else if (ev.target.classList.contains('act-s5')) {
        snooze(id, 5);
      } else if (ev.target.classList.contains('act-s10')) {
        snooze(id, 10);
      } else if (ev.target.classList.contains('act-m10s')) {
        // subtract 10 seconds
        if (typeof adjust === 'function') adjust(id, -10*1000);
      } else if (ev.target.classList.contains('act-m1')) {
        // subtract 1 minute
        if (typeof adjust === 'function') adjust(id, -60*1000);
      } else if (ev.target.classList.contains('act-stop')) {
        stop(id);
      } else if (ev.target.classList.contains('act-open')) {
        const t = getById(id);
        if (t && t.context && window.cookMode && typeof window.cookMode.setIndex === 'function' && typeof window.cookMode.open === 'function') {
          try {
            // Close the drawer so Cook Mode is visible
            closeDrawer();

            if (typeof t.context.goTo === 'function') {
              t.context.goTo();
            } else if (t.context.recipe && Array.isArray(t.context.recipe.steps)) {
              cookMode.open(t.context.recipe, (Number(t.context.stepIndex||0)|0) + 1);
            } else if (Number.isFinite(t.context.stepIndex)) {
              cookMode.setIndex((Number(t.context.stepIndex)|0) + 1);
            }
          } catch(e){}
        }
      }

      renderList();
    });


    // First gesture anywhere can unlock audio (best-effort)
document.addEventListener('visibilitychange', () => {
  try {
    if (document.visibilityState === 'visible' && ac && ac.state === 'suspended') {
      ac.resume();
    }
  } catch(e){}
  try { maybeUpdateWakeLock(); } catch(e){}
}, { passive:true });

// On page unloads, always release the lock/audio fallback
window.addEventListener('pagehide', () => { try { releaseScreenWakeLock(); } catch(e){} }, { passive:true });
window.addEventListener('beforeunload', () => { try { releaseScreenWakeLock(); } catch(e){} }, { passive:true });


  // Expose API
    window.timers = {
      create, pause, resume, stop, snooze, adjust, list, subscribe,
      unlockAudio, requestNotifyPermission
    };


  })();

</script>

<!-- Weekly Items modal -->
<div id="weeklyItemsModal" role="dialog" aria-modal="true" aria-labelledby="weeklyItemsTitle">
  <div class="backdrop" data-close="1"></div>
  <div class="sheet">
    <div class="header">
      <div id="weeklyItemsTitle">Weekly Items</div>
      <button id="weeklyItemsClose" class="close" aria-label="Close">×</button>
    </div>
    <div class="body">
      <!-- Content goes here -->
      <!-- Weekly Items — full Lists tab clone (namespaced) -->
<section id="wiSection" class="card" style="margin-top:0;">
  <!-- Top toolbar like Lists -->
  <div class="toolbar" id="wiFilterGroup">
    <div class="group">
      <h2 style="margin:0">Weekly Items</h2>
      <span id="wiStatus" class="muted"></span>
    </div>

    <div class="group" style="flex:1; min-width:260px;">
      <div class="row" style="gap:8px; flex-wrap:wrap;">
       <div style="min-width:220px; flex:1;">
  <label for="wiItemName">Item</label>
<div class="wiInputWrap" style="position: relative; width: 100%;">
  <input id="wiItemName" type="text" placeholder="e.g., Milch, Bananen" autocomplete="off" />
  <!-- wiAutoList moved to .body for full-width -->
</div>

        <div><button id="wiAdd" class="primary">Add</button></div>
      </div>

      <!-- Weekly Items bulk actions (moved here) -->
      <div class="row" style="margin-top:12px; justify-content:flex-end;">
        <button id="wiClearChecked" type="button">Uncheck all</button>
      </div>

  
    </div>
  </div>

  <!-- List render area -->
  <div id="wiList" class="list" aria-live="polite"></div>
  <div id="wiEmpty" class="empty" style="display:none">
    <svg class="icon" aria-hidden="true"><use href="#i-cart"></use></svg>
    <div class="headline">Your weekly list is empty</div>
    <div class="muted">Add your first weekly item above.</div>
  </div>


  
</section>

      <!-- Full-width suggestion overlay anchored to the modal body -->
      <div id="wiAutoList"
           class="ac-list"
           role="listbox"
           aria-label="Suggestions"
           style="display:none;"></div>

    </div>
  </div>
</div>


<script>
/* ===================== Weekly Items (modal) =====================

Collection path: lists/{household}/weekly
Schema: same as main list items (name, qty, size, notes, category, routeOrder, checked, createdAt, updatedAt, photoPath, photoUrl)

This is a namespaced clone so it won’t interfere with your main List tab.
================================================================= */

document.addEventListener('DOMContentLoaded', () => {
  // Elements
  const wrap       = document.getElementById('wiSection');
  if (!wrap) return;

  const statusEl   = document.getElementById('wiStatus');
  const listEl     = document.getElementById('wiList');
  const emptyEl    = document.getElementById('wiEmpty');

  const nameEl     = document.getElementById('wiItemName');
  const qtyEl      = document.getElementById('wiItemQty');
  const sizeEl     = document.getElementById('wiItemSize');
  const catEl      = document.getElementById('wiItemCategory');
  const routeEl    = document.getElementById('wiItemRoute');
  const notesEl    = document.getElementById('wiItemNotes');

  const addBtn     = document.getElementById('wiAdd');
  const clearBtn   = document.getElementById('wiClearChecked');
  // === Shared references (Auth, Firestore, Household) ===
const auth =
  (window.auth && window.auth) ||
  (firebase && firebase.auth && firebase.auth()) ||
  null;

const db =
  (window.db && window.db) ||
  (firebase && firebase.firestore && firebase.firestore()) ||
  null;

// Robust household detection (same logic as Lists tab)
const householdId =
  (typeof window.household !== 'undefined' && window.household) ||
  (typeof window.activeHousehold !== 'undefined' && window.activeHousehold) ||
  (typeof window.currentHousehold !== 'undefined' && window.currentHousehold) ||
  localStorage.getItem('household') ||
  localStorage.getItem('activeHousehold') ||
  (document.body?.dataset?.household || '');

// === Shared: Keyboard navigation for all autocomplete boxes ===
function enableAutoListKeyboard(inputEl, listEl, onSelect) {
  let activeIndex = -1;

  inputEl.addEventListener('keydown', (e) => {
    const items = listEl.querySelectorAll('.suggestion, .autoItem');
    if (!items.length) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      activeIndex = (activeIndex + 1) % items.length;
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      activeIndex = (activeIndex - 1 + items.length) % items.length;
    } else if (e.key === 'Enter' && activeIndex >= 0) {
      e.preventDefault();
      const chosen = items[activeIndex];
      chosen?.click(); // triggers existing click handler
      activeIndex = -1;
      return;
    } else {
      return; // ignore other keys
    }

    // update visual focus
    items.forEach((it, i) => it.classList.toggle('active', i === activeIndex));
    items[activeIndex]?.scrollIntoView({ block: 'nearest' });
  });
}

    // === Weekly Items: Name Autocomplete (mirrors LISTS tab) ===
  const wiAutoList = document.getElementById('wiAutoList');
enableAutoListKeyboard(document.getElementById('wiItemName'), wiAutoList);

  function wiSuggestionMeta(it){
    const parts = [];
    if (it.category) parts.push(it.category);
    if (it.size)     parts.push(it.size);
    if (it.routeOrder !== '' && !isNaN(parseFloat(it.routeOrder))) parts.push('Route ' + it.routeOrder);
    return parts.join(' • ');
  }

  function showWiSuggestions(q){
  if (!wiAutoList) return;
  q = (q || '').trim().toLowerCase();
  if (!q){
    wiAutoList.style.display = 'none';
    wiAutoList.innerHTML = '';
    return;
  }

  // Source: lastSnapshotItems from LISTS tab (already maintained globally)
  const matches = (Array.isArray(lastSnapshotItems) ? lastSnapshotItems : [])
    .filter(it => ((it.name || '').toLowerCase().includes(q)))
    .sort((a,b)=>{
      const an=(a.name||'').toLowerCase(), bn=(b.name||'').toLowerCase();
      const as = an.startsWith(q) ? 0 : 1;
      const bs = bn.startsWith(q) ? 0 : 1;
      if (as !== bs) return as - bs;
      return an.localeCompare(bn);
    })
    .slice(0, 8);

  if (!matches.length){
    wiAutoList.style.display = 'none';
    wiAutoList.innerHTML = '';
    return;
  }

  wiAutoList.innerHTML = '';
  for (const it of matches){
    const row = document.createElement('div');
    row.className = 'ac-item';
    row.setAttribute('role','option');
    row.dataset.id = it.id || '';
    row._item = it;

    const safe = (s) => (s||'').replace(/[&<>\"']/g, c => (
      {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]
    ));

    // Build inner layout to visually resemble list items
    const photoHtml = it.photoUrl
      ? `<img src="${safe(it.photoUrl)}" alt="" class="thumb" style="width:38px;height:38px;border-radius:6px;object-fit:cover;margin-right:8px;">`
      : '';

    const qtyTxt   = safe(it.qty   || '');
    const sizeTxt  = safe(it.size  || '');
    const notesTxt = safe(it.notes || '');
    const catTxt   = safe(it.category || '');
    const metaTxt  = [qtyTxt, sizeTxt].filter(Boolean).join(' • ');

    row.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;">
        ${photoHtml}
        <div style="flex:1;overflow:hidden;">
          <div style="font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${safe(it.name||'')}</div>
          <div class="muted" style="font-size:0.85em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
            ${metaTxt ? metaTxt + (catTxt ? ' • '+catTxt : '') : (catTxt || '')}
          </div>
          ${notesTxt ? `<div class="muted" style="font-size:0.8em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${notesTxt}</div>` : ''}
        </div>
      </div>
    `;

    wiAutoList.appendChild(row);
  }

  // Position overlay directly under the Item input, within the modal body
  const bodyEl = document.querySelector('#weeklyItemsModal .body');
  const inputWrap = document.querySelector('#weeklyItemsModal .wiInputWrap');
  if (bodyEl && inputWrap){
    const bodyRect = bodyEl.getBoundingClientRect();
    const wrapRect = inputWrap.getBoundingClientRect();
    wiAutoList.style.top = (wrapRect.bottom - bodyRect.top) + 'px';
  } else {
    wiAutoList.style.top = '0px';
  }

  wiAutoList.style.display = 'block';
}



  function applyWiSuggestion(it){
    if (!it) return;

    // Remember the picked suggestion so we can carry fields into the created weekly item.
    wiPicked = {
      id: it.id || '',
      name: it.name || '',
      qty: (typeof it.qty !== 'undefined' && it.qty !== null) ? String(it.qty) : '',
      size: it.size || '',
      notes: it.notes || '',
      category: it.category || '',
      routeOrder: (it.routeOrder === 0 || it.routeOrder) ? it.routeOrder : '',
      photoUrl: it.photoUrl || '',
      photoPath: it.photoPath || ''
    };

    // Fill what exists in this modal (only the name input is present)
    if (nameEl) nameEl.value = wiPicked.name;

    // Hide list; keep focus in the name field for fast confirm
    if (wiAutoList){ wiAutoList.style.display = 'none'; wiAutoList.innerHTML = ''; }
    if (nameEl) nameEl.focus();
  }


  // Delegate suggestion clicks
  if (wiAutoList){
    wiAutoList.addEventListener('click', (e)=>{
      const row = e.target.closest('.ac-item');
      if (!row || !row._item) return;
      applyWiSuggestion(row._item);
    });
  }

  // Hide suggestions when clicking outside
  document.addEventListener('click', (e)=>{
    const withinName = nameEl && (e.target === nameEl || nameEl.contains(e.target));
    const withinList = wiAutoList && (e.target === wiAutoList || wiAutoList.contains(e.target));
    if (!withinName && !withinList && wiAutoList){
      wiAutoList.style.display = 'none';
      wiAutoList.innerHTML = '';
    }
  });


  const addPhotoBtn= document.getElementById('wiAddPhoto');
  const photoName  = document.getElementById('wiPhotoName');
  const photoPrev  = document.getElementById('wiPhotoPreview');

  const toggleBtn  = document.getElementById('wiToggleBtn');

  // State
  let unsubWeekly  = null;
  let weeklyItems  = [];
  let liveQuery    = '';
  let newPhotoFile = null;

  // Last suggestion the user clicked in the Weekly Items modal.
  // We use this to propagate existing fields (qty, size, notes, category, routeOrder, photo*) into the new weekly item.
  let wiPicked = null;


  // Helpers already exist globally in your file: auth, db, storage, showToast, openPhotoPicker, uploadItemPhoto, etc. 

  function setWiControlsEnabled(enabled){
    [addBtn, clearBtn, nameEl, qtyEl, sizeEl, catEl, routeEl, notesEl, addPhotoBtn].forEach(n=>{
      if (!n) return; n.disabled = !enabled; n.classList.toggle('disabled', !enabled);
    });
  }

  function updateWiStatus(){
    if (!statusEl) return;
    const bits = [];
    bits.push((auth && auth.currentUser) ? 'Signed in' : 'Not signed in');
    bits.push('household: ' + (household || '—'));
    statusEl.textContent = bits.join(' • ');
    setWiControlsEnabled(!!(auth && auth.currentUser && household));
  }

  function wiDocRef(id){ return db.collection('lists').doc(household).collection('weekly').doc(id); }
  function wiColRef(){   return db.collection('lists').doc(household).collection('weekly'); }

  // Render
  function renderWi(items){
    // Filter by live query (match name)
    const q = (liveQuery || '').trim().toLowerCase();
    let filtered = q ? items.filter(i => (i.name||'').toLowerCase().includes(q)) : items;

    // Sort like List tab: by route, then name
    const sorted = [...filtered].sort((a,b)=>{
      const ra = isNaN(parseFloat(a.routeOrder)) ? -1 : parseFloat(a.routeOrder);
      const rb = isNaN(parseFloat(b.routeOrder)) ? -1 : parseFloat(b.routeOrder);
      if (ra !== rb) return ra - rb;
      return (a.name||'').localeCompare(b.name||'');
    });

    listEl.innerHTML = '';
    if (!sorted.length){ emptyEl.style.display='block'; return; }
    emptyEl.style.display='none';
    for (const it of sorted) listEl.appendChild(renderWiRow(it));
  }

 function renderWiRow(it){
  const row = document.createElement('div');
  row.className = 'item';
  row.dataset.id = it.id;
  row.dataset.cat = ((it.category || '').trim().toLowerCase().replace(/[^a-z0-9]+/g, '-'));

  // === 1) Checkbox (left cell) ===
  const left = document.createElement('div');
  left.className = 'left';
  const cb = document.createElement('input');
  cb.type = 'checkbox';
  cb.checked = !!it.checked;
  cb.setAttribute('aria-label', 'Mark checked');
  cb.onchange = async () => {
    const isChecked = !!cb.checked;
    try{
      await wiDocRef(it.id).set({
        checked: isChecked,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge:true });
      it.checked = isChecked;
    }catch(e){
      console.error(e);
      showToast('Failed to update');
      cb.checked = !isChecked;
    }
  };
  left.appendChild(cb);

  // === 2) Title + meta (click-to-edit chips) ===
  const line1 = document.createElement('div');
  line1.className = 'line1';

  const catdot = document.createElement('span');
  catdot.className = 'catdot';

  const nameEl = document.createElement('span');
  nameEl.className = 'name';
  nameEl.textContent = capitalizeWords(it.name || '');

  // route flag
  const routeMissing = (
    it.routeOrder === undefined ||
    it.routeOrder === null ||
    it.routeOrder === '' ||
    isNaN(parseFloat(it.routeOrder))
  );
  if (routeMissing) {
    const flag = document.createElement('span');
    flag.textContent = ' 🚩';
    flag.title = 'No route number set';
    flag.style.color = 'red';
    nameEl.appendChild(flag);
  }

  line1.append(catdot, nameEl);

  const meta = document.createElement('div');
  meta.className = 'meta';

  // Helper: editable chip (input)
  function editableChip({
    labelWhenEmpty,
    value,
    inputType = 'text',
    inputMode,
    field,
    title
  }){
    const span = document.createElement('span');
    span.className = 'muted';
    span.style.cursor = 'text';
    if (title) span.title = title;

    const setDisplay = (val) => {
      const v = (val || '').trim();
      span.textContent = v || labelWhenEmpty;
      span.classList.add('muted');
      span.style.fontStyle = v ? 'normal' : 'italic';
    };
    setDisplay(value || '');

    span.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = inputType;
      if (inputMode) input.inputMode = inputMode;
      input.className = 'qty-inline';
      input.value = value || '';
      span.replaceWith(input);
      input.focus();
      try { input.select(); } catch {}

      const finish = async (commit) => {
        const next = commit ? (input.value || '').trim() : (value || '');
        if (commit && next !== (value || '')) {
          try{
            await wiDocRef(it.id).set({
              [field]: next,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge:true });
            it[field] = next;
            value = next;
          }catch(e){
            console.error(`Failed to update ${field}`, e);
            showToast(`Failed to update ${field}`);
          }
        }
        setDisplay(next);
        input.replaceWith(span);
        // reflect category badge + data-cat for filtering if category changed
        if (field === 'category') {
          row.dataset.cat = ((next || '').trim().toLowerCase().replace(/[^a-z0-9]+/g, '-'));
        }
      };

      input.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter') finish(true);
        else if (e.key === 'Escape') finish(false);
      });
      input.addEventListener('blur', () => finish(true));
    });

    return span;
  }

  // Qty (allow empty → “Add qty”)
  const chipQty = editableChip({
    labelWhenEmpty: 'Add qty',
    value: it.qty || '',
    inputType: 'text',
    inputMode: 'decimal',
    field: 'qty',
    title: 'Click to edit qty'
  });

  // Size (allow empty → “Add size”)
  const chipSize = editableChip({
    labelWhenEmpty: 'Add size',
    value: it.size || '',
    inputType: 'text',
    field: 'size',
    title: 'Click to edit size'
  });

  // Category (free text chip; matches Lists inline feel)
  const chipCat = editableChip({
    labelWhenEmpty: 'Add category',
    value: it.category || '',
    inputType: 'text',
    field: 'category',
    title: 'Click to edit category'
  });

  // Route (number; allow empty)
  const chipRoute = editableChip({
    labelWhenEmpty: 'Add route',
    value: (it.routeOrder !== undefined && it.routeOrder !== null) ? String(it.routeOrder) : '',
    inputType: 'text',
    inputMode: 'numeric',
    field: 'routeOrder',
    title: 'Click to edit route'
  });

  // Attach chips (no bullet separators)
meta.append(
  chipQty,
  chipSize,

);
line1.appendChild(meta);


  // === 3) Actions (right cell) — Weekly Items modal: NO Edit button ===
  const actions = document.createElement('div');
  actions.className = 'actions';

  const delBtn = document.createElement('button');
  delBtn.type = 'button';
  delBtn.className = 'pill danger wi-del';
  delBtn.textContent = 'Delete';
  delBtn.onclick = async () => {
    if (!confirm(`Delete '${it.name || ''}'?`)) return;
    try{
      await wiDocRef(it.id).delete();
      showToast('Deleted');
    }catch(e){
      console.error(e);
      alert('Delete failed: ' + (e.message || e));
    }
  };

  actions.append(delBtn);


  // === 4) Below row: photo + notes (notes already inline-editable) ===
  const below = document.createElement('div');
  below.className = 'below';

  const mediaCell = document.createElement('div');

  const mountCameraBtn = () => {
    mediaCell.innerHTML = '';
    const camBtn = document.createElement('button');
    camBtn.type = 'button';
    camBtn.className = 'camBtn';
    camBtn.title = 'Add photo';
    camBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-camera"></use></svg>';
    camBtn.onclick = () => {
      if (typeof openPhotoPicker !== 'function') { alert('Photo picker not available.'); return; }
      openPhotoPicker({
        onFile: async (file) => {
          if (!file) return;
          try{
            showToast('Uploading photo…');
            const { url, path } = await uploadItemPhoto(file, it.id, it.photoPath || null);
            it.photoUrl = url; it.photoPath = path;
            mountThumb(url);
            below.classList.remove('hidden');
            showToast('Photo uploaded');
          }catch(e){
            console.error(e);
            showToast('Photo upload failed');
          }
        }
      });
    };
    mediaCell.appendChild(camBtn);
  };

  const mountThumb = (url) => {
    mediaCell.innerHTML = '';
    const thumb = document.createElement('img');
    thumb.className = 'thumb';
    thumb.src = url;
    thumb.alt = it.name || 'photo';
    thumb.onclick = () => openLightbox && openLightbox(url);
    mediaCell.appendChild(thumb);
  };

  if (it.photoUrl) mountThumb(it.photoUrl); else mountCameraBtn();

  const line2 = document.createElement('div');
  line2.className = 'line2';
  line2.title = 'Click to edit notes';
  line2.style.cursor = 'text';
  if (!it.notes) {
    line2.textContent = 'Add note';
    line2.classList.add('muted');
    line2.style.fontStyle = 'italic';
  } else {
    line2.textContent = it.notes || '';
  }

  line2.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Notes';
    input.className = 'notes';
    input.value = it.notes || '';
    line2.replaceWith(input);
    input.focus();
    input.select();

    const commit = async () => {
      const next = (input.value || '').trim();
      try{
        await wiDocRef(it.id).set({
          notes: next,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge:true });
        it.notes = next;
        line2.textContent = next || 'Add note';
        line2.classList.toggle('muted', !next);
        line2.style.fontStyle = next ? 'normal' : 'italic';
      }catch(e){
        console.error(e);
        showToast('Failed to update notes');
      }finally{
        input.replaceWith(line2);
      }
    };

    input.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') commit();
      else if (e.key === 'Escape') { input.replaceWith(line2); }
    });
    input.addEventListener('blur', commit);
  });

  below.append(mediaCell, line2);

  // === 5) Assemble ===
  row.append(left, line1, actions, below);

  return row;
}



 // Add new weekly item (UI reduced to "Item" only)
if (addBtn) addBtn.addEventListener('click', async () => {
  if (!auth || !auth.currentUser || !household) return alert('Sign in and set household first.');
  const raw = (nameEl?.value || '').trim();
  const name = capitalizeWords(raw);
  if (!name) return alert('Name is required');

  // Build payload from picked suggestion when available and matching the current text; otherwise fall back to blanks.
  const usePick = (wiPicked && String(wiPicked.name || '').toLowerCase() === raw.toLowerCase()) ? wiPicked : null;

  const payload = {
    name,
    qty:  usePick ? (usePick.qty ?? '') : '',
    size: usePick ? (usePick.size || '') : '',
    notes: usePick ? (usePick.notes || '') : '',
    category: usePick ? (usePick.category || '') : '',
    routeOrder: usePick ? ((usePick.routeOrder === 0 || usePick.routeOrder) ? usePick.routeOrder : '') : '',
    // If photos exist on the source item, carry them too
    photoUrl: usePick ? (usePick.photoUrl || '') : '',
    photoPath: usePick ? (usePick.photoPath || '') : '',
    checked: false,
    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
  };

  const newId = wiColRef().doc().id;
  try {
    await wiDocRef(newId).set(payload);
  } catch (e) {
    return alert('Add failed: ' + (e.message || e));
  }

  // Clear form & UI (and drop the pick so next entry starts clean)
  if (nameEl) nameEl.value = '';
  wiPicked = null;

  // Reset live filter and suggestions so the full list is visible again
  liveQuery = '';
  renderWi(weeklyItems);
  if (wiAutoList) { wiAutoList.style.display = 'none'; wiAutoList.innerHTML = ''; }

  // Focus back to the name field for fast entry
  if (nameEl) nameEl.focus();
});



  // Add photo
  if (addPhotoBtn) addPhotoBtn.addEventListener('click', () => {
    if (typeof openPhotoPicker !== 'function') { alert('Photo picker not available.'); return; }
    openPhotoPicker({
      onFile: (file) => {
        newPhotoFile = file;
        if (photoName) photoName.textContent = file?.name || '';
        if (photoPrev) {
          const url = URL.createObjectURL(file);
          photoPrev.src = url;
          photoPrev.style.display = 'inline-block';
        }
        showToast('Photo selected');
      }
    });
  });

  // Live filter + autocomplete (mirrors LISTS tab)
  if (nameEl){
    nameEl.addEventListener('input', () => {
      liveQuery = nameEl.value || '';
      // If the user changed the text so it no longer equals the picked suggestion, drop wiPicked.
      if (wiPicked && (String(wiPicked.name || '').toLowerCase() !== String(liveQuery).trim().toLowerCase())) {
        wiPicked = null;
      }
      renderWi(weeklyItems);
      showWiSuggestions(liveQuery);
    });
    // Also open suggestions on focus if there is already text
    nameEl.addEventListener('focus', () => {
      if (nameEl.value) showWiSuggestions(nameEl.value);
      const bodyEl = document.querySelector('#weeklyItemsModal .body');
      const inputWrap = document.querySelector('#weeklyItemsModal .wiInputWrap');
      if (bodyEl && inputWrap) {
        const bodyRect = bodyEl.getBoundingClientRect();
        const wrapRect = inputWrap.getBoundingClientRect();
        wiAutoList.style.top = (wrapRect.bottom - bodyRect.top) + 'px';
      }
    });


  }

  // Hide / Show items (mirrors your list collapse UX) 
  if (toggleBtn){
    toggleBtn.addEventListener('click', () => {
      const pressed = toggleBtn.getAttribute('aria-pressed') === 'true';
      const next = !pressed;
      toggleBtn.setAttribute('aria-pressed', String(next));
      toggleBtn.textContent = next ? '🔼 Hide items' : '🔽 Show items';
      // Use CSS trick via inline style (modal-only)
      if (next){
        listEl.style.maxHeight = ''; listEl.style.opacity = ''; listEl.style.transform = ''; listEl.style.pointerEvents = '';
        emptyEl.style.maxHeight = ''; emptyEl.style.opacity = ''; emptyEl.style.transform = ''; emptyEl.style.pointerEvents = '';
      } else {
        listEl.style.maxHeight = '0'; listEl.style.opacity = '0'; listEl.style.transform = 'translateY(-6px)'; listEl.style.pointerEvents = 'none';
        emptyEl.style.maxHeight = '0'; emptyEl.style.opacity = '0'; emptyEl.style.transform = 'translateY(-6px)'; emptyEl.style.pointerEvents = 'none';
      }
    });
  }

  // Uncheck all
  if (clearBtn) clearBtn.addEventListener('click', async () => {
    if (!auth || !auth.currentUser || !household) return alert('Sign in and set household first.');
    try{
      const qs = await wiColRef().where('checked','==',true).get();
      if (qs.empty) { showToast('Nothing to clear'); return; }
    const batch = db.batch();
  qs.forEach(doc => batch.set(doc.ref, { checked:false, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true }));
   await batch.commit();
      showToast('Unchecked all weekly items');
    }catch(e){ alert('Failed: '+(e.message||e)); }
  });

  // Subscribe
 async function subscribeWeekly(){
  if (unsubWeekly) { unsubWeekly(); unsubWeekly = null; }
  if (!auth || !auth.currentUser || !household) { renderWi([]); return; }

  try {
    // Ensure lists/{household} exists and this user is in members before any read
    await ensureHouseholdDoc();

    unsubWeekly = wiColRef().onSnapshot((snap) => {
      const arr = [];
      snap.forEach(d => arr.push({ id: d.id, ...d.data() }));
      weeklyItems = arr;
      renderWi(weeklyItems);
    }, (err) => {
      console.error(err);
      alert('Cannot read weekly items. Check Firestore rules and that Firestore is enabled.');
    });
  } catch (e) {
    console.error('subscribeWeekly bootstrap failed', e);
    alert('Cannot read weekly items. Check Firestore rules and that Firestore is enabled.');
  }
}


  // React to auth changes (reuse your global handler pattern) 
  updateWiStatus();
  auth && auth.onAuthStateChanged(() => { updateWiStatus(); subscribeWeekly(); });
  // Also subscribe immediately if already signed in:
  if (auth && auth.currentUser) subscribeWeekly();
  // Expose a small API so other code (e.g., the FAB) can read checked weekly items.
window.weeklyItemsAPI = window.weeklyItemsAPI || {};
window.weeklyItemsAPI.getChecked = function () {
  return Array.isArray(weeklyItems)
    ? weeklyItems.filter(function (it) { return !!it.checked; })
    : [];
};

});
</script>


    
<script>
// Weekly Items: FAB label swap + add-checked-to-shopping while modal is open
document.addEventListener('DOMContentLoaded', () => {
  const fab      = document.getElementById('weeklyItemsFab');
  const modal    = document.getElementById('weeklyItemsModal');
  const closeBtn = document.getElementById('weeklyItemsClose');
  const backdrop = modal ? modal.querySelector('.backdrop') : null;

  if (!fab || !modal) return;

  const WI_STATE_KEY = 'weeklyItemsOpen';

  function openWeeklyItems(){
    modal.classList.add('show');
    document.body.classList.add('modal-open');
    try { history.pushState({ [WI_STATE_KEY]: true }, ''); } catch(e){}
    setFabToAdd();
  }
  function closeWeeklyItems(){
    modal.classList.remove('show');
    document.body.classList.remove('modal-open');
    setFabToOpen();
    // Pop the history entry we pushed on open
    try { if (history.state && history.state[WI_STATE_KEY]) history.back(); } catch(e){}
  }
  function onWeeklyItemsPopState(){
    try {
      if (modal.classList.contains('show')) {
        modal.classList.remove('show');
        document.body.classList.remove('modal-open');
        setFabToOpen();
      }
    } catch(e){}
  }
  window.addEventListener('popstate', onWeeklyItemsPopState);

  // ---------- helpers ----------
  function setFabToOpen() {
    fab.textContent = 'Weekly Items';
    fab.setAttribute('aria-label', 'Weekly Items');
    fab.onclick = openWeeklyItems;
  }

  // When modal closes by X/backdrop, revert the FAB
  if (closeBtn) closeBtn.addEventListener('click', closeWeeklyItems);
  if (backdrop) backdrop.addEventListener('click', closeWeeklyItems);


  // Weekly Items → Shopping: use the exact ATL-style commit logic (no servings scaling)
  async function addWeeklyCheckedToShopping(){
    // Require session + household (match ATL’s guard)
    if (!auth || !auth.currentUser || !household) {
      alert('Sign in and set the household first.');
      return;
    }

    // Collect checked Weekly Items
    const getChecked = (window.weeklyItemsAPI && typeof window.weeklyItemsAPI.getChecked === 'function')
      ? window.weeklyItemsAPI.getChecked
      : null;
    const picked = getChecked ? getChecked() : [];
    if (!picked.length){ showToast('Nothing selected'); return; }

    try{
      // Build a pseudo-ATL "chosen" list (no scaling; keep user-entered qty/size/notes)
      const chosen = picked
        .map(it => ({
          name: (it && it.name ? String(it.name) : '').trim(),
          nameKey: (it && it.name ? String(it.name).toLowerCase() : ''),
          qty: (it && typeof it.qty !== 'undefined' && it.qty !== null) ? String(it.qty) : '',
          size: (it && it.size)  ? String(it.size)  : '',
          notes:(it && it.notes) ? String(it.notes) : ''
        }))
        .filter(x => !!x.name);

      if (!chosen.length){ showToast('Nothing selected'); return; }

      const batch = db.batch();

      for (const ing of chosen){
        // Find existing list item (same lookup as ATL)
        const existing = (typeof findExistingItem === 'function')
          ? findExistingItem(ing.nameKey || ing.name)
          : null;

        if (existing){
          // Merge qty exactly like ATL (addQtyStr), and prefer existing size/notes
          const newQty = (typeof addQtyStr === 'function')
            ? addQtyStr(existing.qty || '', ing.qty || '')
            : ((ing.qty || existing.qty || ''));

          const ref = db.collection('lists').doc(household).collection('items').doc(existing.id);
          batch.set(ref, {
            qty: newQty,
            size: existing.size || ing.size || '',
            notes: existing.notes || ing.notes || '',
            checked: false,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });

        } else {
          // New item; pull category/route from catalogCache (same as ATL)
          const catKnown = (window.catalogCache && typeof catalogCache.get === 'function')
            ? (catalogCache.get((ing.name||'').toLowerCase()) || {})
            : {};

          const ref = db.collection('lists').doc(String(household)).collection('items').doc();
          batch.set(ref, {
            name: ing.name,
            qty: ing.qty || '',
            size: ing.size || '',
            notes: ing.notes || '',
            category: catKnown.category || '',
            routeOrder: (catKnown.routeOrder === 0 || catKnown.routeOrder) ? catKnown.routeOrder : '',
            checked: false,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        }
      }

      await batch.commit();
      showToast('Added to shopping list');

      // Close Weekly Items modal and restore FAB (unchanged)
      if (modal) modal.classList.remove('show');
      document.body.classList.remove('modal-open');
      setFabToOpen();

    } catch(e){
      console.error(e);
      alert('Add failed: ' + (e.message || e));
    }
  }



  function setFabToAdd() {
    fab.textContent = 'Add to Shopping List';
    fab.setAttribute('aria-label', 'Add checked weekly items to the Shopping list');
    fab.onclick = () => { addWeeklyCheckedToShopping(); };
  }

  // ---------- initial visibility (Shopping tab only) ----------
  const current = localStorage.getItem('activeTab') || 'list';
  fab.style.display = (current === 'shopping') ? 'block' : 'none';

  // Update FAB visibility when tabs are clicked
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#tabList, #tabShopping, #tabRecipes');
    if (!btn) return;
    const idToTab = { tabList: 'list', tabShopping: 'shopping', tabRecipes: 'recipes' };
    const tab = idToTab[btn.id];
    if (!tab) return;
    fab.style.display = (tab === 'shopping') ? 'block' : 'none';
  });

  // ---------- open/close wiring ----------
  // Default state (closed): FAB opens the modal
  setFabToOpen();

  // Close modal actions restore FAB to open-mode
  if (closeBtn) closeBtn.addEventListener('click', () => { modal.classList.remove('show'); setFabToOpen(); });
  if (backdrop) backdrop.addEventListener('click', () => { modal.classList.remove('show'); setFabToOpen(); });
});
  /* ====== Recipe Step Ingredient Autocomplete (checkbox-triggered) ======
   Triggers when the caret is on a line that starts with "- [ ] "
   and user types at least 1 character. Shows ingredients from the
   current recipe (best-effort sources below).
====================================================================== */


// Collect detailed ingredients (name, qty, size, notes) for the active recipe
function getActiveRecipeIngredientsDetailed() {
  const out = [];

  // 1) From a provided active recipe object (if present)
  if (window.activeRecipe && Array.isArray(window.activeRecipe.ingredients)) {
    window.activeRecipe.ingredients.forEach(x => {
      if (!x) return;
      if (typeof x === 'string') {
        const name = String(x).trim();
        if (name) out.push({ name, qty: '', size: '', notes: '' });
      } else {
        const name  = (x.name  || '').toString().trim();
        const qty   = (x.qty   || '').toString().trim();
        const size  = (x.size  || '').toString().trim();
        const notes = (x.notes || '').toString().trim();
        if (name) out.push({ name, qty, size, notes });
      }
    });
  }

  // 2) Live editor rows (the modal you type in)
  document.querySelectorAll('#rmIngredients .ing-row').forEach(row => {
    const name  = ((row.querySelector('.ing-name')?.value)  || (row.querySelector('.ing-name')?.textContent) || '').trim();
    const qty   = (row.querySelector('.ing-qty')?.value  || '').trim();
    const size  = (row.querySelector('.ing-size')?.value || '').trim();
    const notes = (row.querySelector('.ing-notes')?.value|| '').trim();
    if (name) out.push({ name, qty, size, notes });
  });

  // 3) DOM fallbacks elsewhere on the page (names only)
  document.querySelectorAll('[data-ingredient-name]').forEach(el => {
    const name = (el.getAttribute('data-ingredient-name') || '').trim();
    if (name) out.push({ name, qty: '', size: '', notes: '' });
  });
  document.querySelectorAll('.ingredient-name').forEach(el => {
    const name = (el.textContent || '').trim();
    if (name) out.push({ name, qty: '', size: '', notes: '' });
  });

  return out;
}



function attachStepAutocomplete(ta) {
  const wrapper = document.createElement('div');
  wrapper.style.position = 'relative';
  wrapper.style.width = '100%';
  ta.parentNode.insertBefore(wrapper, ta);
  wrapper.appendChild(ta);

  const list = document.createElement('div');
  list.className = 'stepAutoList';
  list.setAttribute('role', 'listbox');
  wrapper.appendChild(list);

  let items = [];
  let highlighted = -1;
  let lastAnchor = null;
  let lastQuery = '';
  const CHECKBOX_LINE = /^\s*(?:-\s*)?(?:\[\s?\]|☐)\s*(.*)$/;

  function closeList() {
    list.style.display = 'none';
    list.innerHTML = '';
    items = [];
    highlighted = -1;
  }

  function openList() {
    list.style.left = '0px';
    list.style.top = ta.offsetHeight + 'px';
    list.style.width = ta.offsetWidth + 'px';
    list.style.display = 'block';
  }

  function renderList() {
    list.innerHTML = '';
    items.forEach((txt, i) => {
      const item = document.createElement('div');
      item.className = 'stepAutoItem';
      item.setAttribute('role', 'option');
      item.setAttribute('aria-selected', i === highlighted ? 'true' : 'false');
      item.textContent = txt;
      item.addEventListener('mouseenter', () => { highlighted = i; renderList(); });
      item.addEventListener('mousedown', (ev) => {
        ev.preventDefault();
        commitChoice(i);
      });
      list.appendChild(item);
    });
    if (items.length) openList(); else closeList();
  }

  function moveHighlight(delta) {
    if (!items.length) return;
    highlighted = (highlighted + delta + items.length) % items.length;
    renderList();
    const el = list.children[highlighted];
    if (el) {
      const top = el.offsetTop, bottom = top + el.offsetHeight;
      if (list.scrollTop > top) list.scrollTop = top;
      else if (list.scrollTop + list.clientHeight < bottom) list.scrollTop = bottom - list.clientHeight;
    }
  }

  function commitChoice(index) {
    if (index < 0 || index >= items.length || !lastAnchor) return;
    const choice = items[index];
    const { lineStart, insertFrom, caretAt } = lastAnchor;
    const v = ta.value;
    const before = v.slice(0, insertFrom);
    const after  = v.slice(caretAt);
    const newVal = before + choice + after;
    const newCaret = (before + choice).length;
    ta.value = newVal;
    ta.focus();
    ta.setSelectionRange(newCaret, newCaret);
    closeList();
  }

  function trySuggest() {
    const v = ta.value;
    const caret = ta.selectionStart;
    const lineStart = v.lastIndexOf('\n', Math.max(0, caret - 1)) + 1;
    const lineEnd = v.indexOf('\n', caret);
    const line = v.slice(lineStart, lineEnd === -1 ? v.length : lineEnd);
    const m = line.match(CHECKBOX_LINE);
    if (!m) { closeList(); return; }

    const textAfterCheckbox = m[1];
    const caretInLine = caret - lineStart;
    const offsetAfter = line.indexOf(textAfterCheckbox);
    if (offsetAfter === -1 || caretInLine < offsetAfter) { closeList(); return; }

    const typed = textAfterCheckbox.slice(0, Math.max(0, caretInLine - offsetAfter)).trimStart();
    if (!typed || typed.length < 1) { closeList(); return; }

    // Build suggestions: match by NAME, display as "qty size name"
    const pool = getActiveRecipeIngredientsDetailed();
    const q = typed.toLowerCase();
    const matches = pool
      .filter(obj => (obj && obj.name && obj.name.toLowerCase().startsWith(q)))
      .slice(0, 50);
    const toLabel = (o) => [o.qty, o.size, o.name].filter(Boolean).join(' ').replace(/\s+/g, ' ').trim();

    items = matches.map(toLabel);
    highlighted = items.length ? 0 : -1;

    const insertFrom = lineStart + offsetAfter + (textAfterCheckbox.length - textAfterCheckbox.trimStart().length);
    lastAnchor = { lineStart, insertFrom, caretAt: caret };
    lastQuery = typed;

    renderList();
  }

  ta.addEventListener('input', trySuggest);
  ta.addEventListener('click', trySuggest);
  ta.addEventListener('keyup', trySuggest);

  ta.addEventListener('keydown', (e) => {
    if (list.style.display === 'block') {
      if (e.key === 'ArrowDown') { e.preventDefault(); moveHighlight(+1); }
      else if (e.key === 'ArrowUp') { e.preventDefault(); moveHighlight(-1); }
      else if (e.key === 'Enter') {
        if (highlighted >= 0) { e.preventDefault(); commitChoice(highlighted); }
      } else if (e.key === 'Escape') { e.preventDefault(); closeList(); }
    }
  });

  ta.addEventListener('blur', () => setTimeout(closeList, 120));
}


/** Initialize on any step textarea we can find.
 *  If your step textareas have a known selector, replace query below with it.
 */
function initStepAutocomplete() {
  const selectors = [
    'textarea.step-text',
    'textarea[data-step-text]',
    'textarea[name="stepText"]',
    'textarea[id*="step"]'
  ];
  selectors.forEach(sel => {
    document.querySelectorAll(sel).forEach(ta => {
      if (ta.dataset.stepAcInit === '1') return; // prevent double-wrap
      attachStepAutocomplete(ta);
      ta.dataset.stepAcInit = '1';
    });
  });
}


// Run after DOM ready (safe if called multiple times)
document.addEventListener('DOMContentLoaded', initStepAutocomplete);
// If your UI adds step editors dynamically, expose a global you can call after rendering:
window.initStepIngredientAutocomplete = initStepAutocomplete;
/* ====== /Recipe Step Ingredient Autocomplete ====== */
</script>

</script>

<!-- ===== Import Recipe from JSON (adds ingredients + steps with timers) ===== -->
<input id="importJsonFile" type="file" accept="application/json" style="display:none">

<script>
(function(){
  const btn = document.getElementById('importRecipe');
  const fileInput = document.getElementById('importJsonFile');
  if (!btn || !fileInput) return;

  // Open file chooser
  btn.addEventListener('click', () => fileInput.click());

  // When file selected
  fileInput.addEventListener('change', async () => {
    const f = fileInput.files && fileInput.files[0];
    fileInput.value = ''; // reset
    if (!f) return;

    try {
      const text = await f.text();
      const json = JSON.parse(text);
      importIntoEditor(json);
    } catch (e) {
      console.error(e);
      alert('Could not read this JSON file.');
    }
  });

  // ---------- HELPERS ----------

  // Parse lower bound of a time expression → seconds
  function parseLowerTimeToSeconds(s){
    if (!s || typeof s !== 'string') return 0;
    s = s.toLowerCase();

    // mm:ss
    const mmss = s.match(/(\d{1,3})\s*:\s*(\d{1,2})/);
    if (mmss) {
      const mm = parseInt(mmss[1],10) || 0;
      const ss = Math.min(59, parseInt(mmss[2],10) || 0);
      return mm*60 + ss;
    }

    // range "6–8 min" or "6-8 min"
    const rangeMin = s.match(/(\d+(?:\.\d+)?)\s*(?:–|-|to)\s*\d+(?:\.\d+)?\s*(?:m|min|minute|minutes)\b/);
    if (rangeMin) return Math.round(parseFloat(rangeMin[1]) * 60);

    // minutes only
    const mins = s.match(/(\d+(?:\.\d+)?)\s*(?:m|min|minute|minutes)\b/);
    if (mins) return Math.round(parseFloat(mins[1]) * 60);

    // seconds only
    const secs = s.match(/(\d+(?:\.\d+)?)\s*(?:s|sec|secs|second|seconds)\b/);
    if (secs) return Math.round(parseFloat(secs[1]));

    // fallback plain number → minutes
    const num = s.match(/\b(\d+(?:\.\d+)?)\b/);
    if (num) return Math.round(parseFloat(num[1]) * 60);

    return 0;
  }

  // Normalize ingredient object
  function mapIng(raw){
    const name = (raw && raw.name) ? String(raw.name).trim() : '';
    const qty  = (raw && raw.qty) ? String(raw.qty).replace(/\s+/g,'') : ''; // no space (e.g. 30g)
    const size = (raw && raw.size) ? String(raw.size).trim() : '';
    const notes= (raw && raw.notes) ? String(raw.notes).trim() : '';
    return { name, qty, size, notes };
  }

  // Import JSON payload into the editor
  function importIntoEditor(payload){
    // Open Add Recipe modal if available
    if (typeof openRecipeModal === 'function') openRecipeModal('add');

    const $ = (id) => document.getElementById(id);

    // Name + portions
    if (payload && payload.name) $('rmName').value = String(payload.name);
    if (payload && payload.basePortions != null)
      $('rmBasePortions').value = Math.max(1, parseInt(payload.basePortions,10) || 1);

    // INGREDIENTS
    const rmIngredients = $('rmIngredients');
    if (rmIngredients) {
      rmIngredients.innerHTML = '';
      const list = Array.isArray(payload && payload.ingredients) ? payload.ingredients.map(mapIng) : [];
      if (list.length === 0) list.push({ name:'', qty:'', size:'', notes:'' });
      list.forEach(ing => {
        if (typeof window.createIngRow === 'function') {
          rmIngredients.appendChild(createIngRow(ing));
        }
      });
    }

    // STEPS (text + timer)
    const rmStepsList = $('rmStepsList');
    if (rmStepsList) {
      rmStepsList.innerHTML = '';
      const steps = Array.isArray(payload && payload.steps) ? payload.steps : [];
      steps.forEach(s => {
        const text = (s && s.text) ? String(s.text) : '';
        let timerSec = 0;

        if (typeof s.timerSeconds === 'number') {
          timerSec = Math.max(0, s.timerSeconds|0);
        } else if (s && s.timerText) {
          timerSec = parseLowerTimeToSeconds(String(s.timerText));
        } else {
          timerSec = parseLowerTimeToSeconds(text);
        }

        if (typeof window.addStepRow === 'function') {
          addStepRow({ text, timerSec });
        }
      });

      if (typeof window.rmSteps_setupDnd === 'function') rmSteps_setupDnd();
      if (typeof window.rmSteps_renumber === 'function') rmSteps_renumber();
    }

    // Mark editor dirty for save
    if (typeof window.markRecipeDirty === 'function') markRecipeDirty();

    // Focus for review
    try { $('rmName').focus(); } catch(e){}
  }
})();
</script>
<!-- ===== /Import Recipe from JSON ===== -->

</body>




  </html>


  

  
