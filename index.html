  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://firebaseinstallations.googleapis.com" crossorigin>
  <!-- Extra Firebase endpoints we touch early -->
  <link rel="preconnect" href="https://www.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://identitytoolkit.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://securetoken.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://firebasestorage.googleapis.com" crossorigin>

  <!-- Low-cost DNS prefetch fallbacks (in case preconnect is ignored) -->
  <link rel="dns-prefetch" href="https://www.gstatic.com">
  <link rel="dns-prefetch" href="https://firestore.googleapis.com">
  <link rel="dns-prefetch" href="https://firebaseinstallations.googleapis.com">
  <link rel="dns-prefetch" href="https://www.googleapis.com">
  <link rel="dns-prefetch" href="https://identitytoolkit.googleapis.com">
  <link rel="dns-prefetch" href="https://securetoken.googleapis.com">
  <link rel="dns-prefetch" href="https://firebasestorage.googleapis.com">

    <title>Kaufland Route List</title>
  <style>
  /* =========================================================
    NEON DARK THEME (with light variant)
    - Accent: hot pink
    - Dark-first design; soft glass, rounded, high contrast
    - Force theme by adding data-theme="dark" | "light" to <html>
    ========================================================= */

  /* ---------- Shared tokens ---------- */
  :root{
    --radius: 16px;
    --pad: 14px;

    --primary: #ff007f;          /* hot pink */
    --on-primary: #ffffff;

    /* defaults = LIGHT; overridden below for dark/auto-dark */
    --bg: #f7f7fb;
    --surface: #ffffff;
    --text: #111318;

    --muted: #5f6675;
    --border: #e5e7eb;
    --chip: #f2f3f6;
    --chip-border: #e6e7ef;

    --hover: rgba(0,0,0,.04);
    --press: rgba(0,0,0,.08);

    --shadow-sm: 0 6px 18px rgba(0,0,0,.06);
    --shadow-md: 0 12px 36px rgba(0,0,0,.12);

    /* focus */
    --ring: 0 0 0 3px color-mix(in oklab, var(--primary) 32%, transparent);
  }

  /* ---------- Auto dark (when you don't force a theme) ---------- */
  @media (prefers-color-scheme: dark){
    :root:not([data-theme]){
      --bg: #0f0f12;
      --surface: #17171c;
      --text: #e8e9ee;

      --muted: #a5adbb;
      --border: #2a2a33;
      --chip: #1f1f25;
      --chip-border: #2a2a33;

      --hover: rgba(255,255,255,.06);
      --press: rgba(255,255,255,.10);

      --shadow-sm: 0 10px 28px rgba(0,0,0,.35);
      --shadow-md: 0 18px 48px rgba(0,0,0,.45);
    }
  }

  /* ---------- Manual overrides ---------- */
  :root[data-theme="light"]{
    --bg: #f7f7fb;
    --surface: #ffffff;
    --text: #111318;

    --muted: #5f6675;
    --border: #e5e7eb;
    --chip: #f2f3f6;
    --chip-border: #e6e7ef;

    --hover: rgba(0,0,0,.04);
    --press: rgba(0,0,0,.08);

    --shadow-sm: 0 6px 18px rgba(0,0,0,.06);
    --shadow-md: 0 12px 36px rgba(0,0,0,.12);
  }
  :root[data-theme="dark"]{
    --bg: #0f0f12;
    --surface: #17171c;
    --text: #e8e9ee;

    --muted: #a5adbb;
    --border: #2a2a33;
    --chip: #1f1f25;
    --chip-border: #2a2a33;

    --hover: rgba(255,255,255,.06);
    --press: rgba(255,255,255,.10);

    --shadow-sm: 0 10px 28px rgba(0,0,0,.35);
    --shadow-md: 0 18px 48px rgba(0,0,0,.45);
  }

  /* =========================================================
    Base
    ========================================================= */
  *{ box-sizing: border-box; }
  :root{ color-scheme: light dark; }

  body{
    margin:0;
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans';
  }

  .wrap{ max-width: 900px; margin: 0 auto; padding: 14px; }
  h1{ font-size: 20px; margin: 6px 0 2px; }

  header{
    position: sticky; top: 0; z-index: 5;
    background: color-mix(in oklab, var(--surface) 90%, transparent);
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border);
  }

  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:end; }

  /* =========================================================
    Controls
    ========================================================= */
  input[type="text"], input[type="number"], input[type="file"], select{
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    outline: none;
    transition: border-color .12s ease, box-shadow .12s ease, background .12s ease;
  }
  input[type="text"]:focus, input[type="number"]:focus, select:focus{
    border-color: color-mix(in oklab, var(--primary) 55%, var(--border));
    box-shadow: var(--ring);
  }
  input[type="number"]{ width: 110px; }

  button{
    padding: 10px 14px;
    border-radius: 14px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    cursor: pointer;
    box-shadow: var(--shadow-sm);
    transition: background .12s ease, transform .06s ease, border-color .12s ease, box-shadow .12s ease;
  }

  button.primary{
    background: var(--primary);
    color: var(--on-primary);
    border-color: var(--primary);
    box-shadow: 0 12px 30px color-mix(in oklab, var(--primary) 30%, transparent);
  }

  /* Pills / chips */
  .pill{
    padding: 6px 12px; border-radius: 999px;
    background: var(--chip);
    border: 1px solid var(--chip-border);
    font-size: 12px;
    color: var(--text);
  }
  .muted{ color: var(--muted); font-size: 13px; }

  /* =========================================================
    Cards, toolbars, tabs
    ========================================================= */
  .card{
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: var(--pad);
    box-shadow: var(--shadow-md);
  }

  .toolbar{ display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; }
  .toolbar .group{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  .card > .toolbar{
    position: static;          /* was: sticky */
    top: auto;                 /* no offset */
    z-index: auto;             /* no stacking above content */
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 8px 0;
  }


  /* Tabs */
  .tabs{ display:flex; gap:10px; }
  .tab{
    padding: 8px 16px;
    border-radius: 999px;
    border: 1px solid var(--chip-border);
    background: var(--chip);
    color: var(--text);
    transition: background .12s ease, box-shadow .12s ease, border-color .12s ease, transform .06s ease;
  }
  .tab:hover{ background: color-mix(in oklab, var(--chip), var(--hover)); }
  .tab.active{
    background: var(--primary);
    border-color: var(--primary);
    color: var(--on-primary);
    box-shadow: 0 14px 36px color-mix(in oklab, var(--primary) 30%, transparent);
  }
  /* =========================================================
    Bottom Navigation
    ========================================================= */
  .bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    display: flex;
    gap: 8px;
    padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
    background: var(--surface);
    border-top: 1px solid var(--border);
    box-shadow: 0 -8px 24px rgba(0,0,0,.12);
    z-index: 9999;           /* ↑ ensure it sits on top of footer/overlays */
    pointer-events: auto;
  }

  .bottom-nav .tab {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    border-radius: 0;
    border: none;
    background: transparent;
    font-weight: 600;
  }
  .bottom-nav .tab.active {
    background: var(--primary);
    color: var(--on-primary);
    border-radius: 12px;
    margin: 0 4px;
  }

  /* =========================================================
    List + groups
    ========================================================= */
  /* Animated show/hide for List tab content (scoped to #listSection ONLY) */
  #listSection #list,
  #listSection #empty{
    /* Transitionable properties */
    transition:
      max-height 220ms ease,
      opacity 180ms ease,
      transform 220ms ease;
    /* Expanded defaults */
    max-height: none;       /* large enough to fit typical lists */
    opacity: 1;
    transform: translateY(0);
    overflow: hidden;         /* enables height animation without layout spill */
  }

  /* Collapsed state (driven by data-list-collapsed on #listSection) */
  #listSection[data-list-collapsed="true"] #list,
  #listSection[data-list-collapsed="true"] #empty{
    max-height: 0;
    opacity: 0;
    transform: translateY(-6px);
    pointer-events: none;     /* make content non-interactive while hidden */
  }

  /* Respect reduced-motion preferences */
  @media (prefers-reduced-motion: reduce){
    #listSection #list,
    #listSection #empty{
      transition: none !important;
    }
  }

  .list{ margin-top:10px; display:grid; gap:12px; }
  .groupHeader{ display:flex; align-items:center; gap:10px; font-weight:700; padding:4px 2px 0; }
  .groupHeader .dot{ width:8px; height:8px; border-radius:999px; background:#9aa3b2; }
  .groupBox{ display:grid; gap:8px; }

  /* =========================================================
    Item row
    ========================================================= */
  .item{
    display:grid;
    grid-template-columns: 28px 1fr auto;
    grid-template-rows: auto auto auto;  /* title / qty+size+actions / photo+notes */
    gap:10px 10px;
    align-items:center;
    padding:10px 12px;
    border:1px solid var(--border);
    border-radius:14px;
    background: var(--surface);
    transition: transform .06s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease;
  }

  .item.is-pressed{ transform: scale(.995); box-shadow: 0 8px 24px rgba(0,0,0,.25); }

  .left{ grid-column:1; grid-row:1; display:flex; align-items:center; justify-content:center; }
.item input[type="checkbox"] {
  margin-right: 8px;
  width: 18px;
  height: 18px;
}

.md-task {
  vertical-align: middle;
  margin-right: 6px;
}

  .line1{
    grid-column:2; grid-row:1;
    font-size:16px; font-weight:800; line-height:1.25;
    overflow:hidden; white-space:nowrap; text-overflow:ellipsis; min-width:0;
  }
    /* second line under the name (qty + size) */
  .line1 .meta{
    margin-top:6px;
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;            /* wrap nicely on small screens */
    font-weight:600;           /* matches your previous sep weight */
  }
  .line1 .meta .muted{ font-weight:500; }  /* keep size text lighter */

  .line1 .sep{ opacity:.7; font-weight:600; }

  .actions{ grid-column:3; grid-row:2; display:flex; gap:8px; align-items:center; justify-self:end; }

  .editbtn, .btn-icon{
    height:36px; padding:0 12px; border-radius:10px;
    border:1px solid var(--border);
    background: var(--surface);
    display:grid; place-items:center;
  }

  .icon{ width:18px; height:18px; display:inline-block; }

  /* Below row (photo + notes) */
  .below{
    grid-column:2; grid-row:2;

    display:grid; grid-template-columns:48px 1fr;
    align-items:center; column-gap:10px;
  }
  .below.hidden{ display:none; }

  .thumb{
    width:44px; height:44px; border-radius:12px; object-fit:cover;
    border:1px solid var(--border); background:#2a2a33; display:block; cursor:pointer;
  }
  .camBtn{
    width:44px; height:44px; border-radius:12px;
    border:1px dashed var(--border);
    display:flex; align-items:center; justify-content:center;
    background: var(--surface);
    cursor:pointer; padding:0;
  }

  .line2{ color: var(--muted); font-size:14px; line-height:1.35; white-space:normal; overflow-wrap:anywhere; }
  .line2:empty{ display:none; }

  /* Category dots (kept from your schema) */
  .catdot{ width:8px; height:8px; border-radius:999px; display:inline-block; margin-right:8px; background:#7b8497; vertical-align:middle; }
  .item[data-cat="produce"] .catdot{ background:#2fb344; }
  .item[data-cat="meat-poultry"] .catdot{ background:#d7263d; }
  .item[data-cat="fish-seafood"] .catdot{ background:#2a9df4; }
  .item[data-cat="dairy-eggs"] .catdot{ background:#51b3ff; }
  .item[data-cat="bakery"] .catdot{ background:#f08c2f; }
  .item[data-cat="pantry"] .catdot{ background:#a1765c; }
  .item[data-cat="frozen"] .catdot{ background:#27c3d6; }
  .item[data-cat="beverages"] .catdot{ background:#7b61ff; }
  .item[data-cat="snacks-confectionery"] .catdot{ background:#ffd43b; }
  .item[data-cat="household-cleaning"] .catdot{ background:#8795a1; }
  .item[data-cat="personal-care-health"] .catdot{ background:#ff6fa3; }
  .item[data-cat="other"] .catdot{ background:#c0c4cc; }

  /* Inline qty box inside title */
  .qty-inline {
    min-width: 7ch;              /* at least space for 10 characters */
    width: auto;                 /* let it grow */
    padding: 6px 8px;
    border: 1px solid var(--border);
    border-radius: 10px;
    font: inherit;
    background: var(--surface);
    color: var(--text);
  }


  /* Editor row (expanded) */
  .item .editor{ 
    display:none; 
    grid-column:1 / -1; 
    grid-row:4;              /* 🔴 always sits below photo/notes */
  }
  .item.editing .editor{
    display:grid;
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap:8px; 
    padding-top:8px;
  }
  .qty, .size, .notes, .route, .category{ width:100%; }


  @media (max-width:560px){
    .item.editing .editor{ grid-template-columns:1fr; }
    button, input, select{ min-height:44px; }
  }

  /* Checked effect */
  .item:has(input[type="checkbox"]:checked){
    background:
      linear-gradient(0deg, color-mix(in oklab, var(--surface) 75%, var(--hover)), color-mix(in oklab, var(--surface) 75%, var(--hover))),
      var(--surface);
    opacity:.92;
  }
  .item:has(input[type="checkbox"]:checked) .line1{ text-decoration:line-through; color: color-mix(in oklab, var(--text) 60%, #888); }

  /* =========================================================
    Autocomplete / Toast / Popups / Modals / Lightbox
    (restyled to match neon-dark)
    ========================================================= */
  .ac-list{
    position:absolute; left:0; right:0; top:100%; margin-top:6px;
    background: var(--surface);
    border:1px solid var(--border);
    border-radius:14px; box-shadow: var(--shadow-md);
    max-height:280px; overflow:auto; z-index:6;
  }
  .ac-item{ display:flex; flex-direction:column; gap:2px; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border); }
  .ac-item:last-child{ border-bottom:none; }
  .ac-item:hover{ background: color-mix(in oklab, var(--surface), var(--hover)); }
  .ac-title{ font-weight:700; }
  .ac-meta{ color: var(--muted); font-size:12px; }

  .toast{
    position: fixed;
    left: 50%;
    bottom: calc(70px + env(safe-area-inset-bottom, 0px) + 18px);
    transform: translateX(-50%) translateY(14px);
    opacity: 0;
    transition:
      transform 240ms cubic-bezier(.22,1,.36,1),
      opacity 240ms cubic-bezier(.22,1,.36,1);
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 14px;
    box-shadow: var(--shadow-md);
    padding: 10px 14px;
    font-size: 14px;
    pointer-events: auto;   /* tap to dismiss */
    z-index: 20000;
  }
  .toast.show{
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }



  .popup-backdrop{ position:fixed; inset:0; background: rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:9000000; }
  .popup-backdrop.show{ display:flex; }
  .popup{
    background: var(--surface);
    border:1px solid var(--chip-border);
    border-radius:16px; width:300px; padding:12px; box-shadow: var(--shadow-md);
  }
  .popup h3{ margin:6px 8px 10px; font-size:15px; }
  .popup .choices{ display:grid; gap:8px; }
  .popup .choices button{ width:100%; }

  /* Full-screen modal overlay */
  .modal{
    position:fixed; inset:0;
    background: rgba(0,0,0,.4);
    display:none;
    /* Stretch child to full viewport instead of centering a box */
    align-items:stretch; justify-content:stretch;
    z-index:80;
  }
  .modal.show{ display:flex; }

  /* Card fills the viewport; column layout for head/body/foot */
  .modal-card{
    width:100vw; height:100dvh;
    background: var(--surface);
    border:1px solid var(--border);
    border-radius:0;                     /* no rounded corners in full-screen */
    box-shadow: var(--shadow-md);
    display:flex; flex-direction:column; /* header, body, footer stack vertically */
  }

  /* Header stays at the top; body scrolls beneath */
  .modal-head{
    display:flex; align-items:center; justify-content:space-between;
    padding:14px 16px;
    border-bottom:1px solid var(--border);
    position:sticky; top:0; z-index:1;   /* keep close/delete visible */
    background: var(--surface);
  }

  /* Body takes remaining space and scrolls if long */
  .modal-body{
    flex:1 1 auto; min-height:0;
    padding:14px 16px;
    overflow:auto;
    display:flex; flex-direction:column; gap:16px;  /* ← add vertical spacing */
    max-height:none;
  }




  /* Footer is pinned to bottom of the card */
  .modal-foot{
    flex:0 0 auto;
    padding:12px 16px;
    border-top:1px solid var(--border);
    display:flex; gap:8px;
  }

  .input-row{ display:grid; gap:8px; grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
  /* — Prevent any image in the modal from overflowing horizontally — */
  .modal-body img{
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Extra safety: children can shrink within the modal body */
  .modal-body > * { min-width: 0; }

    .input-row > * { min-width: 0; }

    @media (max-width:560px){ .input-row{ grid-template-columns:1fr; } }

  .tag-row{ display:flex; flex-wrap:wrap; gap:8px; }
  .tagchip{
    padding:6px 10px; border:1px solid var(--chip-border); border-radius:999px; cursor:pointer; user-select:none;
    background: var(--chip); color: var(--text);
  }
  .tagchip.active{ background: var(--primary); color: var(--on-primary); border-color: var(--primary); }
  /* Prevent tag chips from causing horizontal overflow */
  #rmTags { max-width: 100%; }
  .tagchip{
    display: inline-flex;
    align-items: center;
    white-space: normal;         /* allow wrapping */
    overflow-wrap: anywhere;     /* break long words/strings */
    word-break: break-word;      /* extra safety for long tokens */
    max-width: 100%;
  }

  .preset-row{ display:flex; gap:8px; flex-wrap:wrap; }
  .preset{ padding:6px 10px; border:1px solid var(--chip-border); border-radius:999px; background: var(--chip); }
  .preset.active{ background: var(--primary); color: var(--on-primary); border-color: var(--primary); }
  /* Recipes search layout helpers */
  .rc-search { display:flex; flex-direction:column; gap:6px; }
  #rcSelected { max-width:100%; }
  #rcTopTags { max-width:100%; }
  #rcTagInput { max-width:100%; }

  .checklist{ display:grid; gap:8px; }
  .checkrow{
    display:grid; grid-template-columns:24px 1fr auto; align-items:center; gap:10px;
    border:1px solid var(--border); border-radius:12px; padding:8px 10px; background: var(--surface);
  }



    /* Reserve space so content isn't hidden behind the bottom nav */
  body { padding-bottom: calc(70px + env(safe-area-inset-bottom)); }

  /* =========================================================
    Bottom Navigation
    ========================================================= */
  .bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    display: flex;
    gap: 8px;
    padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
    background: var(--surface);
    border-top: 1px solid var(--border);
    box-shadow: 0 -8px 24px rgba(0,0,0,.12);
    z-index: 100;
  }
  .bottom-nav .tab {
    flex: 1;
    padding: 12px 0;
    border-radius: 12px;
    border: 1px solid var(--chip-border);
    background: var(--chip);
    font-weight: 700;
  }
  .bottom-nav .tab:hover { background: color-mix(in oklab, var(--chip), var(--hover)); }
  .bottom-nav .tab.active {
    background: var(--primary);
    border-color: var(--primary);
    color: var(--on-primary);
    box-shadow: 0 10px 24px color-mix(in oklab, var(--primary) 30%, transparent);
  }

  /* =========================================================
    Floating Theme Toggle (FAB)
    ========================================================= */
  .theme-fab {
    position: fixed;
    right: 16px;
    bottom: calc(70px + 16px + env(safe-area-inset-bottom)); /* sits above the nav */
    border-radius: 999px;
    padding: 10px 12px;
    border: 1px solid var(--border);
    background: var(--surface);
    box-shadow: var(--shadow-md);
    cursor: pointer;
  }
  .theme-fab:hover  { background: color-mix(in oklab, var(--surface), var(--hover)); }
  .theme-fab:active { background: color-mix(in oklab, var(--surface), var(--press)); transform: translateY(1px); }
  .lightbox {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.8);
    display: none;              /* hidden by default */
    align-items: center;
    justify-content: center;
    z-index: 20000;
  }
  .lightbox.show {
    display: flex;              /* only visible when .show is applied */
  }
  .lightbox img {
    max-width: 90%;
    max-height: 80%;
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0,0,0,.6);
  }
  .lightbox .close {
    position: absolute;
    top: 20px;
    right: 20px;
    font-size: 28px;
    background: transparent;
    border: none;
    color: white;
    cursor: pointer;
  }
  /* Recipe list thumbnail */
  .recipeThumb{
    width: 64px;
    height: 64px;
    object-fit: cover;
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
    flex-shrink: 0;
  }
  /* Smooth light/dark theme transitions across the whole app */
  html[data-theme],
  html[data-theme] *:not(.toast) {
    transition:
      background-color 0.28s ease,
      background 0.28s ease,
      color 0.28s ease,
      border-color 0.28s ease,
      box-shadow 0.28s ease,
      fill 0.28s ease,
      stroke 0.28s ease;
  }


  /* Respect users who prefer less motion */
  @media (prefers-reduced-motion: reduce) {
    html[data-theme],
    html[data-theme] * {
      transition: none !important;
    }
  }


  </style>




    <!-- Firebase SDKs from CDN -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>


    <meta name="theme-color" content="#111"/>
    <link rel="manifest" href="manifest.webmanifest"/>
  </head>
  <body>
    <!-- SVG sprite -->
    <svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden">
      <symbol id="i-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 7h16"/><path d="M9 7V5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/><path d="M6 7l1 12a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2l1-12"/><path d="M10 11v6M14 11v6"/>
      </symbol>
      <symbol id="i-cart" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 12.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/>
      </symbol>
      <symbol id="i-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3l2-3h8l2 3h3a2 2 0 0 1 2 2z"/>
        <circle cx="12" cy="13" r="4"/>
      </symbol>
    </svg>




    <main class="wrap">
      <div id="status" class="status"></div>

      <section id="listSection" class="card" data-list-collapsed="true">

        <div id="addRow" class="row">

                  <div style="flex:2; min-width:220px; position:relative;">

            <label>Item</label>
            <input id="itemName" type="text" placeholder="e.g., Milch, Bananen" />
                              <div id="autoList" class="ac-list" role="listbox" aria-label="Suggestions" style="display:none"></div>
            <div id="updateTag" class="updateTag" style="display:none"></div>

          </div>
          
          <div>
            <label>Qty</label>
            <input id="itemQty" class="qty" type="text" placeholder="e.g., 2, 500g" />
          </div>
          <div style="min-width:120px;">
            <label>Size</label>
            <input id="itemSize" class="size" type="text" placeholder="e.g., 500g, 1L" />
          </div>
          <div style="min-width:180px;">
            <label>Category</label>
            <select id="itemCategory" class="category">
              <option value="">— Select —</option>
              <option>Produce</option><option>Meat & Poultry</option><option>Fish & Seafood</option>
              <option>Dairy & Eggs</option><option>Bakery</option><option>Pantry</option>
              <option>Frozen</option><option>Beverages</option><option>Snacks & Confectionery</option>
              <option>Household & Cleaning</option><option>Personal Care & Health</option><option>Other</option>
            </select>
          </div>
          <div style="min-width:120px;">
            <label>Route</label>
            <input id="itemRoute" class="route" type="number" step="0.1" placeholder="e.g., 12" />
          </div>
          <div style="flex:1; min-width:200px;">
            <label>Notes</label>
            <input id="itemNotes" class="notes" type="text" placeholder="e.g., brand, ripeness" />
          </div>

          <!-- ONE Add photo button + filename (new-item form) -->
          <div style="min-width:220px;">
            <label>Photo</label>
            <div class="row" style="gap:8px; align-items:center;">
              <button id="newItemAddPhoto" type="button">Add photo</button>
              <span id="photoName" class="muted"></span>
                          <img id="photoPreview" class="thumb" style="display:none" alt="Preview">

            </div>
          </div>

          <div><button id="add" class="primary">Add</button></div>
        </div>

      <div id="toggleListItemsRow" class="row" style="justify-content: flex-end; margin-top: 6px;">
    <button id="toggleListItemsButton" class="pill" type="button" aria-pressed="false">🔽 Show items</button>
  </div>


        <div id="list" class="list" aria-live="polite"></div>
        <div id="empty" class="empty" style="display:none">
          <svg class="icon" aria-hidden="true"><use href="#i-cart"></use></svg>
          <div class="headline">Your list is empty</div>
          <div class="muted">Add your first item above.</div>
        </div>
      </section>
  <!-- ==================== Recipes View (shell) ==================== -->
  <section id="recipesView" class="card" style="display:none; margin-top:14px;">
    <div class="toolbar">
      <div class="group">
        <h2 style="margin:0">Recipes</h2>
        <span id="recipesCount" class="pill muted">0 recipes</span>
      </div>
          <div class="group" style="flex:1; min-width:260px;">
        <div id="rcSearchWrap" class="rc-search">
          <label for="rcTagInput" class="muted" style="font-size:12px;">Search by tags</label>

          <div class="rc-input-row" style="position:relative;">
            <input
              id="rcTagInput"
              type="text"
              placeholder="Start typing a tag or recipe name…"
              maxlength="24"
              enterkeyhint="done"
              style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--chip-border); background:var(--surface); color:var(--text);"
            />
            <button id="rcClearBtn" type="button" title="Clear filters" style="margin-left:8px; white-space:nowrap;">Clear</button>

            <div id="rcTagAC" class="ac-list" role="listbox" aria-label="Tag suggestions" style="display:none;"></div>
          </div>

          <div id="rcSelected" class="tag-row" style="margin-top:6px;"></div>

          <div class="muted" style="margin-top:6px; font-size:12px;">Common tags</div>
          <div id="rcTopTags" class="preset-row"></div>
        </div>
      </div>

      <div class="group">
        <button id="btnOpenAddRecipe" class="primary" type="button">Add Recipe</button>
      </div>
    </div>

    <div id="recipeList" class="list" style="margin-top:12px;"></div>
  </section>


      
    </main>

    

    <!-- Global hidden file inputs (reused everywhere) -->
    <input id="fileChooser" type="file" accept="image/*" style="display:none" />
    <input id="fileCamera"  type="file" accept="image/*" capture="environment" style="display:none" />

    <!-- Small popup for photo choices -->
    <div id="photoPopup" class="popup-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="popup" role="document">
        <h3>Add a photo</h3>
        <div class="choices">
          <button id="ppTake"   type="button">📷 Take photo</button>
          <button id="ppChoose" type="button">🖼️ Choose photo</button>
          <button id="ppCancel" type="button">Cancel</button>
        </div>
      </div>
    </div>
  <!-- ==================== Recipe Editor Modal (full-screen shell) ==================== -->
  <div id="recipeModal" class="modal" aria-hidden="true" style="position:fixed; inset:0; margin:0; padding:0; z-index:1000;">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="rmTitle"
        style="position:fixed; inset:0; margin:0; border-radius:0; display:flex; flex-direction:column; width:auto; height:auto;">
      
      <!-- Header stays at the very top -->
      <div class="modal-head"
          style="flex:0 0 auto; display:flex; justify-content:space-between; align-items:center; padding:12px; border-bottom:1px solid var(--border); position:sticky; top:0; background:var(--surface, #111); z-index:1;">
        <h3 id="rmTitle" style="margin:0;">Add Recipe</h3>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="rmDelete" class="danger" type="button" style="display:none">Delete</button>
          <button id="rmClose" type="button">✕</button>
        </div>
      </div>

      <!-- Body fills the rest and scrolls if needed -->
      <div class="modal-body" style="flex:1 1 auto; min-height:0; overflow:auto; padding:16px;">
        <!-- Meta -->
        <label>
          <div>Name</div>
          <input id="rmName" placeholder="e.g., Chicken Tikka" />
        </label>

        <div class="input-row">
          <label>
            <div>Base portions</div>
            <input id="rmBasePortions" type="number" min="1" value="2" />
          </label>



    <!-- Tags section (collapsible) -->
    <details id="rmTagsWrap" style="margin:0; width:100%;" data-collapsible="tags">
      <summary id="rmTagsSummary" style="list-style:none; cursor:pointer; display:flex; align-items:center; gap:8px;">
        <span style="font-weight:600; font-size:1.1rem;">Tags</span>
        <span id="rmTagsCaret" aria-hidden="true" style="margin-left:auto; transition:transform .2s;">▾</span>
      </summary>

      <div id="rmTagsBody" style="margin-top:8px;">
        <!-- Selected tags + Top 10 most-used tags will be rendered here -->
        <div id="rmTags" class="tag-row"></div>

        <!-- Add Tag control (inline input with autocomplete) -->
        <div id="rmTagAdderRow" style="margin-top:8px; position:relative;">
          <button id="rmAddTag" type="button">+ Add tag</button>
          <div id="rmTagAdderWrap" style="display:none; margin-top:8px; position:relative;">
      <input
    id="rmTagInput"
    type="text"
    placeholder="Start typing…"
    maxlength="24"
    enterkeyhint="done"
    style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--chip-border); background:var(--surface); color:var(--text);"
  />

            <div id="rmTagAC" class="ac-list" role="listbox" aria-label="Tag suggestions" style="display:none;"></div>
            <div class="muted" style="margin-top:6px; font-size:12px;">
              Press Enter to add. Up to 10 tags. New tags are created if no match.
            </div>
          </div>
        </div>
      </div>
    </details>
  </div>

  <script>
  (function(){
    const wrap  = document.getElementById('rmTagsWrap');
    if (!wrap || wrap._collapsibleInit) return;
    wrap._collapsibleInit = true;

    const caret = document.getElementById('rmTagsCaret');
    const KEY   = 'rmTags.open';

    // Restore last-open state
    try {
      const saved = localStorage.getItem(KEY);
      if (saved === '0') wrap.removeAttribute('open');
      if (saved === '1') wrap.setAttribute('open','');
    } catch(e){}

    const updateCaret = () => {
      if (!caret) return;
      caret.style.transform = wrap.hasAttribute('open') ? 'rotate(0deg)' : 'rotate(-90deg)';
    };

    updateCaret();

    wrap.addEventListener('toggle', () => {
      updateCaret();
      try { localStorage.setItem(KEY, wrap.hasAttribute('open') ? '1' : '0'); } catch(e){}
    });
  })();
  </script>



        <!-- Cover photo -->
        <div>
          <div>Cover photo</div>
          <div class="row" style="gap:8px; align-items:center;">
            <button id="rmCoverBtn" type="button">Add/Change cover</button>
            <span id="rmCoverName" class="muted"></span>
            <img id="rmCoverPreview" class="thumb" style="display:none" alt="Cover preview">
            <button id="rmCoverRemove" type="button" style="display:none">Remove</button>
          </div>
        </div>
  <!-- Ingredients section (collapsible) -->
  <details id="rmIngredientsWrap" style="margin:0; width:100%;" data-collapsible="ingredients">
    <summary id="rmIngredientsSummary" style="list-style:none; cursor:pointer; display:flex; align-items:center; gap:8px;">
      <span style="font-weight:600; font-size:1.1rem;">Ingredients</span>
      <span id="rmIngredientsCaret" aria-hidden="true" style="margin-left:auto; transition:transform .2s;">▾</span>
    </summary>

    <div id="rmIngredientsBody" style="margin-top:0;">
      <!-- Ingredient list container -->
      <div id="rmIngredients">
        <!-- Ingredient Row -->
        <div class="ing-row">
          <!-- Row 1 -->
          <div class="ing-name-wrap" style="position:relative;">
            <textarea class="ing-name" placeholder="Ingredient name"></textarea>
            <div class="ac-list ing-ac" role="listbox" aria-label="Suggestions" style="display:none"></div>
          </div>
          <input class="ing-qty" type="text" placeholder="Qty" />
          <input class="ing-size" type="text" placeholder="Size" />

          <!-- Row 2 -->
          <div></div> <!-- empty space under Name -->
          <textarea class="ing-notes" placeholder="Notes"></textarea>
          <button class="ing-del" type="button" title="Remove">✕</button>
        </div>
      </div>

      <!-- Add Ingredient button (now below all rows) -->
      <div style="margin-top:12px;">
        <button id="rmAddIngredient" type="button">+ Add Ingredient</button>
      </div>
    </div>
  </details>

  <script>
  (function(){
    const wrap = document.getElementById('rmIngredientsWrap');
    if (!wrap || wrap._collapsibleInit) return;
    wrap._collapsibleInit = true;

    const caret = document.getElementById('rmIngredientsCaret');
    const KEY = 'rmIngredients.open';

    // Restore last-open state for this editor session
    try {
      const saved = localStorage.getItem(KEY);
      if (saved === '0') wrap.removeAttribute('open');
      if (saved === '1') wrap.setAttribute('open','');
    } catch(e){}

    const updateCaret = () => {
      if (!caret) return;
      caret.style.transform = wrap.hasAttribute('open') ? 'rotate(0deg)' : 'rotate(-90deg)';
    };

    updateCaret();

    // Persist and update ARIA/visuals on toggle
    wrap.addEventListener('toggle', () => {
      updateCaret();
      try { localStorage.setItem(KEY, wrap.hasAttribute('open') ? '1' : '0'); } catch(e){}
    });
  })();
  </script>


  <!-- Steps section (collapsible) -->
  <details id="rmSteps" style="margin:0; width:100%;" data-collapsible="steps">
    <summary id="rmStepsSummary" style="list-style:none; cursor:pointer; display:flex; align-items:center; gap:8px;">
      <span style="font-weight:600; font-size:1.1rem;">Steps</span>
      <span id="rmStepsCaret" aria-hidden="true" style="margin-left:auto; transition:transform .2s;">▾</span>
    </summary>

    <div id="rmStepsBody" style="margin-top:8px;">
      <div id="rmStepsList"></div>
      <div style="margin-top:12px;">
        <button id="rmAddStep" type="button">+ Add Step</button>
      </div>
    </div>
  </details>

  <script>
  (function(){
    const wrap = document.getElementById('rmSteps');
    if (!wrap || wrap._collapsibleInit) return;
    wrap._collapsibleInit = true;

    const caret = document.getElementById('rmStepsCaret');
    const KEY = 'rmSteps.open';

    // Restore last-open state for this editor session
    try {
      const saved = localStorage.getItem(KEY);
      if (saved === '0') wrap.removeAttribute('open');
      if (saved === '1') wrap.setAttribute('open','');
    } catch(e){}

    const updateCaret = () => {
      if (!caret) return;
      caret.style.transform = wrap.hasAttribute('open') ? 'rotate(0deg)' : 'rotate(-90deg)';
    };

    updateCaret();

    // Persist and update ARIA/visuals on toggle
    wrap.addEventListener('toggle', () => {
      updateCaret();
      try { localStorage.setItem(KEY, wrap.hasAttribute('open') ? '1' : '0'); } catch(e){}
    });
  })();
  </script>


      </div>
      <div class="modal-foot">

        <div style="flex:1"></div>
        <button id="rmSave" class="primary" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- ==================== Add Recipe to List Modal (shell) ==================== -->
  <div id="addToListModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="atlTitle">
      <div class="modal-head">
        <h3 id="atlTitle" style="margin:0;">Add Recipe to List</h3>
        <button id="atlClose" type="button">✕</button>
      </div>
      <div class="modal-body">
        <div>
          <div>Portions</div>
          <div class="row" style="gap:8px; align-items:center;">
            <button id="atlDec" type="button">–</button>
            <input id="atlServings" type="number" min="1" value="2" style="width:90px; text-align:center;">
            <button id="atlInc" type="button">+</button>
          </div>
          <div class="preset-row" style="margin-top:8px;">
            <button class="preset" data-x="1">1×</button>
            <button class="preset" data-x="1.5">1.5×</button>
            <button class="preset" data-x="2">2×</button>
          </div>
        </div>

        <label style="margin-top:8px;">
          <input type="checkbox" id="atlSelectAll" checked> Select/Deselect all
        </label>

        <div id="atlList" class="checklist"></div>
      </div>
      <div class="modal-foot">
        <div style="flex:1"></div>
        <button id="atlAdd" class="primary" type="button">Add to Shopping List</button>
      </div>
    </div>
  </div>


  
  <script>
      // Register service worker for PWA installability
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js').catch(()=>{});
        });
      }
    </script>
    <script>
      // === Firebase ===
      const firebaseConfig = {
        apiKey: "AIzaSyAljIHyxs-pvJRi2pRzs2fsPARCQLFQ2Kg",
        authDomain: "grocery-list-77298.firebaseapp.com",
        projectId: "grocery-list-77298",
        storageBucket: "grocery-list-77298.firebasestorage.app", // If uploads fail, set to YOUR_PROJECT_ID.appspot.com
        messagingSenderId: "1089310382899",
        appId: "1:1089310382899:web:03b24e12f3a9e5c6d63c46"
      };

      let app, auth, db, storage;
      try {
        app = firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        db = firebase.firestore();
        storage = firebase.storage();
        db.enablePersistence({ synchronizeTabs: true }).catch(()=>{});
      } catch (e) { console.error(e); }

      const $ = id => document.getElementById(id);
      const listEl = $('list');
      const emptyEl = $('empty');
      // ——— skeleton placeholders for first paint ———
  let _listHasFirstSnapshot = false;
  let _recipesHasFirstSnapshot = false;

  function showListSkeleton(){
    if (!listEl) return;
    if (listEl._skeletonMounted) return;
    listEl._skeletonMounted = true;
    const frag = document.createDocumentFragment();
    for (let i=0;i<4;i++){
      const sk = document.createElement('div');
      sk.className = 'item skeleton';
      sk.innerHTML = `
        <div class="left"><div class="sk-box" style="width:18px;height:18px;border-radius:4px;"></div></div>
        <div class="line1">
          <div class="sk-line" style="width:60%;height:14px;"></div>
          <div class="meta" style="margin-top:8px;">
            <div class="sk-chip" style="width:72px;height:12px;"></div>
            <div class="sk-chip" style="width:48px;height:12px;"></div>
          </div>
        </div>
        <div class="actions"><div class="sk-btn" style="width:56px;height:28px;border-radius:8px;"></div></div>
      `;
      frag.appendChild(sk);
    }
    listEl.innerHTML = '';
    listEl.appendChild(frag);
    if (emptyEl) emptyEl.style.display = 'none';
  }
  function hideListSkeleton(){
    if (!listEl || !listEl._skeletonMounted) return;
    listEl._skeletonMounted = false;
    listEl.innerHTML = '';
  }

      // ——— micro-debounced renderers ———
  let _rafItems = 0, _rafRecipes = 0, _pendingItems = null, _pendingRecipes = null;
  function scheduleRenderItems(items){
    _pendingItems = items;
    if (_rafItems) return;
    _rafItems = requestAnimationFrame(() => {
      _rafItems = 0;
      const data = _pendingItems; _pendingItems = null;
      render(data);
    });
  }
  function scheduleRenderRecipes(arr){
    _pendingRecipes = arr;
    if (_rafRecipes) return;
    _rafRecipes = requestAnimationFrame(() => {
      _rafRecipes = 0;
      const data = _pendingRecipes; _pendingRecipes = null;
      renderRecipes(data);
    });
  }

    let sortModeEl = null;
  let filterModeEl = null;

      const statusEl = $('status');
  // Tabs + filter group
  const tabListBtn = $('tabList');
  const tabShoppingBtn = $('tabShopping');
  const tabRecipesBtn = $('tabRecipes');
  const filterGroup = $('filterGroup');

  // Tab state
  let activeTab = 'list';




      // Preferences

      // Preferences

      let user = null;
      let household = localStorage.getItem('household') || '';
      let unsubList = null;
      let lastSnapshotItems = [];
      let liveListQuery = ''; // live filter typed in the Item box
      let catalogCache = new Map();
      let lastAddedId = null;
  let unsubRecipes = null;
  let lastSnapshotRecipes = [];


      // ==== Recipes search state and helpers ====
  let rcQuery = { tagsMode: 'AND', tags: [], name: '' };
      try {
    const saved = JSON.parse(localStorage.getItem('recipes_query') || '{}');
    if (saved && Array.isArray(saved.tags)) {
      rcQuery.tags = saved.tags.map(rcNormTag);
    }
    if (saved && typeof saved.name === 'string') {
      rcQuery.name = rcNormTag(saved.name);
    }
  } catch {}

  function saveRcQuery(){
    try { localStorage.setItem('recipes_query', JSON.stringify({ tagsMode: rcQuery.tagsMode, tags: rcQuery.tags, name: rcQuery.name || '' })); } catch {}
  }

  let rcTagIndex = [];


  // Normalize tag text
  function rcNormTag(s){
    return String(s || '').trim().toLowerCase();
  }

  // Build {tag,count} list across recipes
  function buildRecipeTagIndex(arr){
    const counts = {};
    for (const r of (arr || [])){
      if (Array.isArray(r.tags)){
        for (const t of r.tags){
          const k = rcNormTag(t);
          if (!k) continue;
          counts[k] = (counts[k] || 0) + 1;
        }
      }
    }
    const list = Object.entries(counts).map(([tag, count]) => ({ tag, count }));
    list.sort((a,b) => (b.count - a.count) || a.tag.localeCompare(b.tag));
    return list;
  }

  // Render the search UI (chips, suggestions) and wire events once
  function renderRecipeSearchUI(){
    const selectedRow = $('rcSelected');
    const topRow = $('rcTopTags');
    const input = $('rcTagInput');
    const ac = $('rcTagAC');
    const clear = $('rcClearBtn');

    if (!selectedRow || !topRow || !input || !ac || !clear) return;

    // Selected tag chips
    selectedRow.innerHTML = '';
    for (const t of rcQuery.tags){
      const chip = document.createElement('div');
      chip.className = 'tagchip active';
      chip.textContent = t;
      chip.title = 'Remove';
      chip.onclick = () => {
    rcQuery.tags = rcQuery.tags.filter(x => x !== t);
  saveRcQuery();
  renderRecipeSearchUI();
  applyRecipeFilter();

      };
      selectedRow.appendChild(chip);
    }

    // Top 10 common tags
    topRow.innerHTML = '';
    for (const { tag, count } of rcTagIndex.slice(0, 10)){
      const chip = document.createElement('div');
      chip.className = 'preset' + (rcQuery.tags.includes(tag) ? ' active' : '');
      chip.textContent = `${tag} (${count})`;
      chip.title = 'Add filter';
      chip.onclick = () => {
        if (!rcQuery.tags.includes(tag)){
      rcQuery.tags.push(tag);
  saveRcQuery();
  renderRecipeSearchUI();
  applyRecipeFilter();

        }
      };
      topRow.appendChild(chip);
    }

    // Wire input and AC once
    if (!input._wired){
      input._wired = true;

      input.addEventListener('input', () => {
        const qRaw = input.value || '';
        const q = rcNormTag(qRaw);

        // Live name query (persist & filter)
        rcQuery.name = q;
        saveRcQuery();
        applyRecipeFilter();

        // Tag suggestions (same as before)
        const tagSugs = q
          ? rcTagIndex.map(x => x.tag).filter(t => t.startsWith(q) && !rcQuery.tags.includes(t)).slice(0, 8)
          : [];

        // Recipe name suggestions (by contains)
        const nameSugs = q && Array.isArray(lastSnapshotRecipes)
          ? Array.from(new Set(
              lastSnapshotRecipes
                .map(r => (r && r.name) ? String(r.name) : '')
                .filter(n => n && n.toLowerCase().includes(q))
            )).slice(0, 8)
          : [];

        // Build AC list (tags first, then names)
        const parts = [];
        tagSugs.forEach(s => parts.push(`<div class="ac-item" role="option" data-tag="${s}"><div>${s}</div></div>`));
        nameSugs.forEach(n => parts.push(`<div class="ac-item" role="option" data-name="${n}"><div>🔎 ${n}</div></div>`));

        ac.innerHTML = parts.join('');
        ac.style.display = parts.length ? 'block' : 'none';
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter'){
          e.preventDefault();
          const v = rcNormTag(input.value);
          if (v){
            // Keep existing behavior: Enter adds a tag (name filtering already happens live)
            if (!rcQuery.tags.includes(v)) rcQuery.tags.push(v);
  saveRcQuery();
  input.value = '';
  const q = '';
  rcQuery.name = q;
  saveRcQuery();
  const acList = $('rcTagAC');
  if (acList){ acList.style.display = 'none'; acList.innerHTML = ''; }

            renderRecipeSearchUI();
            applyRecipeFilter();
          }
        }
        if (e.key === 'Escape'){
          input.value = '';
          rcQuery.name = '';
          saveRcQuery();
          ac.style.display = 'none';
          ac.innerHTML = '';
          applyRecipeFilter();
        }
      });

      ac.addEventListener('click', (e) => {
        const el = e.target.closest('.ac-item');
        if (!el) return;
        const t = el.getAttribute('data-tag');
        const n = el.getAttribute('data-name');

        if (t && !rcQuery.tags.includes(t)){
        rcQuery.tags.push(t);
  saveRcQuery();
  input.value = '';
  rcQuery.name = '';
  saveRcQuery();
  ac.style.display = 'none';

          ac.innerHTML = '';
          renderRecipeSearchUI();
          applyRecipeFilter();
          return;
        }

        if (n){
          // Click on a name suggestion: set input to that name and filter by it
          input.value = n;
          rcQuery.name = rcNormTag(n);
          saveRcQuery();
          ac.style.display = 'none';
          ac.innerHTML = '';
          applyRecipeFilter();
          return;
        }
      });

      clear.addEventListener('click', () => {
      rcQuery.tags = [];
  saveRcQuery();
  input.value = '';
  rcQuery.name = '';
  saveRcQuery();
  const acList = $('rcTagAC');

        if (acList){
          acList.style.display = 'none';
          acList.innerHTML = '';
        }
        renderRecipeSearchUI();
        applyRecipeFilter();
      });
    }
  }


  // Apply filters to recipes and call the existing renderer
  function applyRecipeFilter(){
    const source = Array.isArray(lastSnapshotRecipes) ? lastSnapshotRecipes : [];
    const tags = rcQuery.tags || [];
    const nameQ = rcQuery.name ? rcQuery.name : '';

    let filtered = source;

    // Tag filter (AND/OR)
    if (tags.length){
      if (rcQuery.tagsMode === 'AND'){
        filtered = filtered.filter(r => {
          const rt = Array.isArray(r.tags) ? r.tags.map(rcNormTag) : [];
          return tags.every(t => rt.includes(t));
        });
      } else {
        filtered = filtered.filter(r => {
          const rt = Array.isArray(r.tags) ? r.tags.map(rcNormTag) : [];
          return tags.some(t => rt.includes(t));
        });
      }
    }

    // Name filter (contains, case-insensitive)
    if (nameQ){
      filtered = filtered.filter(r => {
        const nl = (r && (r.nameLower || (r.name || '').toLowerCase())) || '';
        return nl.includes(nameQ);
      });
    }

    renderRecipes(filtered);
  }


  // Entry point used by subscribeRecipes and by guards
  function setRecipesAndRepaint(arr){
    lastSnapshotRecipes = Array.isArray(arr) ? arr : [];
    rcTagIndex = buildRecipeTagIndex(lastSnapshotRecipes);
    renderRecipeSearchUI();
    applyRecipeFilter();
  }


      // New-item pending photo
      let newItemPhotoFile = null;
          // === Autocomplete / Update mode state ===
      let selectedItemId = null;
      let selectedItemInitialChecked = false;
      let selectedItemPhotoPath = null;

      const nameInput = $('itemName');
      const autoList = $('autoList');

      function escapeHtml(s){ 
        return (s||'').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[c]));
      }

      function suggestionMeta(it){
        const parts = [];
        if (it.category) parts.push(it.category);
        if (it.size) parts.push(it.size);
        if (it.routeOrder !== '' && !isNaN(parseFloat(it.routeOrder))) parts.push('Route ' + it.routeOrder);
        return parts.join(' • ');
      }

      function showSuggestions(q){
        if (!autoList) return;
        q = (q||'').trim().toLowerCase();
        if (!q){ autoList.style.display='none'; autoList.innerHTML=''; return; }
        const matches = lastSnapshotItems
          .filter(it => (it.name||'').toLowerCase().includes(q))
          .sort((a,b)=>{
            const an=(a.name||'').toLowerCase(), bn=(b.name||'').toLowerCase();
            const as = an.startsWith(q) ? 0 : 1;
            const bs = bn.startsWith(q) ? 0 : 1;
            if (as !== bs) return as - bs;
            return an.localeCompare(bn);
          })
          .slice(0,8);
        if (!matches.length){ autoList.style.display='none'; autoList.innerHTML=''; return; }
        autoList.innerHTML = '';
        for (const it of matches){
          const row = document.createElement('div');
          row.className = 'ac-item';
          row.setAttribute('role','option');
          row.dataset.id = it.id;
          row.innerHTML = '<div class="ac-title">'+escapeHtml(it.name||'')+'</div>' +
                          '<div class="ac-meta">'+escapeHtml(suggestionMeta(it))+'</div>';
          autoList.appendChild(row);
        }
        autoList.style.display = 'block';
      }
      
  // ===== Recipe Modal Ingredient Name Autocomplete =====
  // Uses the already-available lastSnapshotItems[] as the suggestion source.

  function buildIngMatches(q){
    q = (q||'').trim().toLowerCase();
    if (!q) return [];
    // same matching rules as list tab: starts-with first, then includes
    const matches = lastSnapshotItems
      .filter(it => (it.name||'').toLowerCase().includes(q))
      .sort((a,b)=>{
        const an=(a.name||'').toLowerCase(), bn=(b.name||'').toLowerCase();
        const as = an.startsWith(q) ? 0 : 1;
        const bs = bn.startsWith(q) ? 0 : 1;
        if (as !== bs) return as - bs;
        return an.localeCompare(bn);
      })
      .slice(0,8);
    return matches;
  }

  function renderIngAC(listEl, matches){
    listEl.innerHTML = '';
    if (!matches || !matches.length){
      listEl.style.display = 'none';
      return;
    }
    for (const it of matches){
      const row = document.createElement('div');
      row.className = 'ac-item';
      row.setAttribute('role','option');
      row._item = it;
      row.innerHTML =
        '<div class="ac-title">'+escapeHtml(it.name||'')+'</div>' +
        '<div class="ac-meta">'+escapeHtml(suggestionMeta(it))+'</div>';
      listEl.appendChild(row);
    }
    listEl.style.display = 'block';
  }

  function applyIngSuggestion(row, it){
    // Fill this ingredient row with the selected item's known data
    const name  = row.querySelector('.ing-name');
    const size  = row.querySelector('.ing-size');
    // Leave qty/notes alone; user-specific
    if (name) name.value = it.name || '';
    if (size && !size.value) size.value = it.size || '';
  }

  function bindIngredientAC(row){
    const wrap   = row.querySelector('.ing-name-wrap');
    const input  = row.querySelector('.ing-name');
    const acList = row.querySelector('.ing-ac');
    if (!input || !acList || !wrap) return;

    const closeAC = () => { acList.style.display = 'none'; acList.innerHTML = ''; };

    input.addEventListener('input', () => {
      const q = input.value;
      const matches = buildIngMatches(q);
      renderIngAC(acList, matches);
    });

    // Click on a suggestion → apply to this row
    acList.addEventListener('mousedown', (e) => {
      const el = e.target.closest('.ac-item');
      if (!el || !el._item) return;
      applyIngSuggestion(row, el._item);
      closeAC();
      e.preventDefault(); // keep focus in the textarea
    });

    // Close when clicking outside this wrapper
    document.addEventListener('click', (e) => {
      if (!wrap.contains(e.target)) closeAC();
    });

    // Esc to close
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape'){ closeAC(); }
    });
  }

  // Bind AC to the initial static row present in HTML (inside #rmIngredients)
  (function bindInitialIngredientRows(){
    const container = document.getElementById('rmIngredients');
    if (!container) return;
    container.querySelectorAll('.ing-row').forEach(row => bindIngredientAC(row));
  })();

      function clearUpdateMode(){
        selectedItemId = null;
        selectedItemInitialChecked = false;
        selectedItemPhotoPath = null;
        const tag = $('updateTag'); if (tag){ tag.style.display='none'; tag.innerHTML=''; }
        setPhotoPreview('');
      }

      function applySuggestion(item){
        selectedItemId = item.id;
        selectedItemInitialChecked = !!item.checked;
        selectedItemPhotoPath = item.photoPath || null;

        $('itemName').value = item.name || '';
        $('itemQty').value = item.qty || '';
        $('itemSize').value = item.size || '';
        $('itemNotes').value = item.notes || '';
        $('itemCategory').value = item.category || '';
        $('itemRoute').value = (item.routeOrder === '' || item.routeOrder === undefined || item.routeOrder === null) ? '' : item.routeOrder;

        setNewPhotoFile(null);
        setPhotoPreview(item.photoUrl || '');

        const tag = $('updateTag');
        if (tag){
          tag.innerHTML = 'Updating: <strong>'+escapeHtml(item.name||'')+'</strong> <button type="button" id="cancelUpdate" aria-label="Cancel">×</button>';
          tag.style.display = 'inline-flex';
          const cancel = $('cancelUpdate'); if (cancel) cancel.onclick = () => clearUpdateMode();
        }

        if (autoList){ autoList.style.display='none'; autoList.innerHTML=''; }
        const qtyField = $('itemQty'); if (qtyField) qtyField.focus();
      }

          // Wire events
      if (nameInput){
        nameInput.addEventListener('input', () => {
          const v = nameInput.value || '';
          showSuggestions(v);                     // existing autocomplete
          liveListQuery = v;                      // update live filter
          scheduleRenderItems(lastSnapshotItems || []); // re-render list with live filter
        });
        document.addEventListener('click', (e) => {
          if (!autoList) return;
          if (e.target === nameInput || (e.target.closest && e.target.closest('#autoList'))) return;
          autoList.style.display='none';
        });
      }

      if (autoList){
        autoList.addEventListener('mousedown', (e) => {
          const el = e.target.closest('.ac-item'); if (!el) return;
          const id = el.dataset.id;
          const item = lastSnapshotItems.find(x => x.id === id);
          if (item) applySuggestion(item);
          e.preventDefault();
        });
      }


    function setHouseholdUI() {
    const householdInput = $('household');
    const householdView  = $('householdView');

    if (householdInput) householdInput.value = household;
    if (householdView)  householdView.textContent = household || '–';
  }

      setHouseholdUI();

      function setControlsEnabled(enabled){
        ['add','clearChecked','sortMode','filterMode','itemName','itemQty','itemCategory','itemRoute','itemSize','itemNotes','newItemAddPhoto']
          .forEach(id => { const n = $(id); if (!n) return; n.disabled = !enabled; n.classList.toggle('disabled', !enabled); });
      }

      function updateStatus(){
    // Clear safely
    statusEl.textContent = '';
    const add = (txt) => {
      const s = document.createElement('span');
      s.innerText = txt;
      if (statusEl.childNodes.length) statusEl.append(' • ');
      statusEl.append(s);
    };

    if (!auth || !db) add('SDK not loaded');
    add(auth && auth.currentUser ? 'Signed in' : 'Not signed in');
    add('household: ' + (household || '—'));

    const ready = !!auth && !!db && !!auth.currentUser && !!household;
    setControlsEnabled(ready);
  }




      auth && auth.onAuthStateChanged(u => {
    user = u;
        
  const _si = $('signIn');
    const _so = $('signOut');
    if (_si) _si.style.display = u ? 'none' : 'inline-block';
    if (_so) _so.style.display = u ? 'inline-block' : 'none';

    // Subscribe immediately (renders from cache fast)
    subscribeList();
    subscribeRecipes();

    // Push non-critical warming to idle so it never blocks initial render
    (window.requestIdleCallback || function(cb){ return setTimeout(cb, 0); })(() => {
      try { warmCatalog(); } catch {}
    });

    updateStatus();
  });

  // === ensure parent /lists/{household} exists and is owned by current user ===
  // Ensure /lists/{household} exists and add current user to members
  async function ensureHouseholdDoc() {
    if (!auth || !auth.currentUser || !household) return;

    try {
      const uid = auth.currentUser.uid;

      // Data structure: members is a map of uid:true
      const data = {
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        members: {}
      };
      data.members[uid] = true;

      // Merge so it adds the user without overwriting existing members
      await db.collection('lists').doc(household).set(data, { merge: true });
    } catch (e) {
      console.error('ensureHouseholdDoc failed', e);
    }
  }


  async function subscribeList(){
    if (unsubList) { unsubList(); unsubList = null; }
    if (!auth || !auth.currentUser || !household) { render([]); return; }

    try {
      // Make sure the household doc exists and includes this user BEFORE any read
      await ensureHouseholdDoc();

      // Now it is safe to subscribe
      unsubList = db.collection('lists').doc(household).collection('items')
        .onSnapshot((snap) => {
          const items = [];
          snap.forEach(d => items.push({ id: d.id, ...d.data() }));
          lastSnapshotItems = items;
          hideListSkeleton();
          scheduleRenderItems(items);
        }, (err) => {
          console.error(err);
          alert('Cannot read list. Check Firestore rules and that Firestore is enabled.');
        });

    } catch (e) {
      console.error('subscribeList bootstrap failed', e);
      alert('Cannot read list. Check Firestore rules and that Firestore is enabled.');
    }
  }


  async function subscribeRecipes(){
    if (unsubRecipes) { unsubRecipes(); unsubRecipes = null; }
    if (!auth || !auth.currentUser || !household) { setRecipesAndRepaint([]); return; }

    try {
      // Make sure the household doc exists and includes this user BEFORE any read
      await ensureHouseholdDoc();

      // Now it is safe to subscribe
      unsubRecipes = db.collection('recipes').doc(household).collection('recipes')
        .where('deletedAt','==', null)
        .onSnapshot((snap) => {
          const arr = [];
          snap.forEach(d => arr.push({ id: d.id, ...d.data() }));
          arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
          setRecipesAndRepaint(arr);

          lastSnapshotRecipes = arr;
          scheduleRenderRecipes(arr);
        }, (err) => {
          console.error(err);
          alert('Cannot read recipes. Check Firestore rules.');
        });

    } catch (e) {
      console.error('subscribeRecipes bootstrap failed', e);
      alert('Cannot read recipes. Check Firestore rules.');
    }
  }




      function warmCatalog(){
        if (!auth || !auth.currentUser || !household) return;
        db.collection('catalog').doc(household).collection('items').get().then(qs => {
          catalogCache.clear();
          qs.forEach(doc => {
            const d = doc.data();
            catalogCache.set((d.name||'').toLowerCase(), { category: d.category||'', routeOrder: d.routeOrder ?? '' });
          });
        }).catch(()=>{});
      }


  function render(items){
    // Start from all items
    let filtered = items;

    // Cache latest full items snapshot for instant startup
  const _ric = window.requestIdleCallback || function(cb){ return setTimeout(cb, 0); };
  _ric(() => {
    try { localStorage.setItem('cache_items', JSON.stringify(items || [])); } catch {}
  });


    if (activeTab === 'shopping') {
      // Shopping tab: ONLY unchecked items
      filtered = items.filter(i => !i.checked);
    } else {
      // List tab: obey the dropdown filter (only all / checked / unchecked)
      const fm = (filterModeEl && filterModeEl.value) || 'all';
      if (fm === 'unchecked') {
        filtered = items.filter(i => !i.checked);
      } else if (fm === 'checked') {
        filtered = items.filter(i => !!i.checked);
      }
      // Apply live query from the Item input (case-insensitive substring match)
      const q = (liveListQuery || '').trim().toLowerCase();
      if (q) {
        filtered = filtered.filter(i => (i.name || '').toLowerCase().includes(q));
      }
    }


    // Render by chosen sort mode
    const mode = (sortModeEl && sortModeEl.value) || 'route';
    if (mode === 'category') {
      renderGroupedByCategory(filtered);
    } else if (mode === 'name') {
      // Flat list sorted by name (A→Z)
      const byName = [...filtered].sort((a,b)=> (a.name||'').localeCompare(b.name||''));
      listEl.innerHTML = '';
      if (!byName.length){ emptyEl.style.display = 'block'; return; }
      emptyEl.style.display = 'none';
      for (const it of byName) listEl.appendChild(renderRow(it));
    } else {
      renderFlatByRoute(filtered);
    }
  }




      function renderFlatByRoute(items){
        const sorted = [...items].sort((a,b)=>{
          const ra = isNaN(parseFloat(a.routeOrder)) ? -1 : parseFloat(a.routeOrder);
          const rb = isNaN(parseFloat(b.routeOrder)) ? -1 : parseFloat(b.routeOrder);
          if (ra !== rb) return ra - rb;
          return (a.name||'').localeCompare(b.name||'');
        });

        listEl.innerHTML = '';
        if (!sorted.length){ emptyEl.style.display = 'block'; return; }
        emptyEl.style.display = 'none';
        for (const it of sorted) listEl.appendChild(renderRow(it));
      }

      function renderGroupedByCategory(items){
        const groups = new Map();
        for (const it of items){
          const key = (it.category || '').trim() || 'Uncategorized';
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(it);
        }
        const catNames = [...groups.keys()].sort((a,b)=>a.localeCompare(b));
        listEl.innerHTML = '';
        if (!catNames.length){ emptyEl.style.display = 'block'; return; }
        emptyEl.style.display = 'none';

        for (const cat of catNames){
          const header = document.createElement('div');
          header.className = 'groupHeader';
          const dot = document.createElement('div'); dot.className='dot';
          const label = document.createElement('div'); label.textContent = cat;
          header.append(dot,label);
          listEl.appendChild(header);

          const box = document.createElement('div'); box.className = 'groupBox';
          const rows = groups.get(cat).sort((a,b)=>{
            const an = (a.name||''), bn = (b.name||'');
            const cmp = an.localeCompare(bn); if (cmp !== 0) return cmp;
            const ra = isNaN(parseFloat(a.routeOrder)) ? -1 : parseFloat(a.routeOrder);
            const rb = isNaN(parseFloat(b.routeOrder)) ? -1 : parseFloat(b.routeOrder);
            return ra - rb;
          });
          for (const it of rows) box.appendChild(renderRow(it));
          listEl.appendChild(box);
        }
      }
  function renderRecipes(arr){
    const list = $('recipeList');
    const count = $('recipesCount'); // optional
    if (!list) return;
    list.innerHTML = '';

    // Cache latest recipes snapshot for instant startup
    const _ric = window.requestIdleCallback || function(cb){ return setTimeout(cb, 0); };
    _ric(() => {
      try { localStorage.setItem('cache_recipes', JSON.stringify(arr || [])); } catch {}
    });

    if (count) {
      count.textContent = `${arr.length} recipe${arr.length===1?'':'s'}`;
    }

    if (!arr.length){
      const empty = document.createElement('div');
      empty.className = 'muted';
      empty.textContent = 'No recipes yet. Click "Add Recipe".';
      list.appendChild(empty);
      return;
    }

    for (const r of arr){
      const row = document.createElement('div');
      row.className = 'recipeRow';
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.maxWidth = '100%';
      row.style.gap = '8px';

      const left = document.createElement('div');
      left.innerHTML = `<strong>${escapeHtml(r.name||'Untitled')}</strong> 
        <span class="muted">(${r.basePortions||1} portions)</span>`;

      if (r.tags && r.tags.length){
        const tags = document.createElement('span');
        tags.className = 'muted';
        tags.textContent = ' ' + r.tags.join(', ');
        left.appendChild(tags);
      }

      // Helper to inject the full-overlay pink "Cook Mode" button into a hover target
        // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (2-tap flow)
      // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (true 2-tap flow)
      // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (true 2-tap flow; no auto-hide)
        // Helper to inject the full-overlay pink "Cook Mode" button into a tap target (true 2-tap flow; stays visible)
    function attachCookOverlay(hoverTarget){
    hoverTarget.style.position = hoverTarget.style.position || 'relative';

    const cookBtn = document.createElement('button');
    cookBtn.type = 'button';
    cookBtn.textContent = 'Cook Mode';
    cookBtn.setAttribute('aria-label', 'Open Cook Mode for ' + (r.name||'Recipe'));
    cookBtn.className = 'btn-pink';
    cookBtn.style.position = 'absolute';
    cookBtn.style.inset = '0';
    cookBtn.style.width = '100%';
    cookBtn.style.height = '100%';
    cookBtn.style.display = 'none';            // initially hidden
    cookBtn.style.opacity = '0';               // for fade
    cookBtn.style.transition = 'opacity 200ms ease';
    cookBtn.style.borderRadius = '10px';
    cookBtn.style.fontSize = '14px';
    cookBtn.style.fontWeight = '600';
    cookBtn.style.zIndex = '2';
    cookBtn.style.alignItems = 'center';
    cookBtn.style.justifyContent = 'center';
    cookBtn.style.textAlign = 'center';
    cookBtn.style.cursor = 'pointer';

    let ignoreNextClick = false;
    let hideTimer = null;
    let fadeTimer = null;

    const showBtn = () => {
      ignoreNextClick = true;

      // cancel any pending hides
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
      if (fadeTimer) { clearTimeout(fadeTimer); fadeTimer = null; }

      // show + fade in
      cookBtn.style.display = 'flex';
      // force next frame, then raise opacity
      requestAnimationFrame(() => { cookBtn.style.opacity = '1'; });

      // auto-hide after 2s if not clicked again
      hideTimer = setTimeout(() => { hideBtn(); }, 1000);
    };

    const hideBtn = () => {
      ignoreNextClick = false;
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }

      // fade out, then set display:none when done
      cookBtn.style.opacity = '0';
      fadeTimer = setTimeout(() => {
        cookBtn.style.display = 'none';
        fadeTimer = null;
      }, 220); // a hair longer than the 200ms transition
    };

    hoverTarget.appendChild(cookBtn);

    // First tap shows the pink overlay (doesn't open Cook Mode yet)
    hoverTarget.addEventListener('pointerdown', () => {
      if (cookBtn.style.display === 'none') showBtn();
    });

    // Second tap (on the pink overlay) opens Cook Mode
    cookBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (ignoreNextClick) { ignoreNextClick = false; return; }
      if (window.cookMode && typeof window.cookMode.open === 'function') {
        window.cookMode.open(r, 0);
        hideBtn();
      } else {
        alert('Cook Mode module is not available.');
      }
    });
  }







      // If the recipe has a cover image, prepend a thumbnail and use the text box as hover target
      if (r.coverUrl){
        left.style.display = 'flex';
        left.style.alignItems = 'center';
        left.style.gap = '10px';

        const img = document.createElement('img');
        img.className = 'recipeThumb';
        img.loading = 'lazy';
        img.decoding = 'async';
        img.src = r.coverUrl;
        img.alt = (r.name || 'Recipe') + ' cover';
        img.style.cursor = 'pointer';
        img.onclick = () => openLightbox(r.coverUrl);

        // Move existing text nodes into a wrapper so image sits to the left
        const textBox = document.createElement('div');
        while (left.firstChild) textBox.appendChild(left.firstChild);
        left.append(img, textBox);

        // FULL-OVERLAY Cook Mode button on text area
        attachCookOverlay(textBox);
      } else {
        // No cover image: use the whole left block as the hover target
        attachCookOverlay(left);
      }

      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.gap = '6px';

      const editBtn = document.createElement('button');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openRecipeModal('edit', r);

      const addBtn = document.createElement('button');
      addBtn.textContent = 'Add to List';
      addBtn.onclick = () => openAddToListModal(r);

      // Inline Cook button removed — overlay Cook Mode button remains on the text area
      right.append(editBtn, addBtn);

      row.append(left, right);
      list.appendChild(row);


    }
  }





      // ==== PHOTO: shared popup + global inputs ====
      const fileChooser = $('fileChooser');
      const fileCamera  = $('fileCamera');
      const popupEl = $('photoPopup');
      const btnTake = $('ppTake');
      const btnChoose = $('ppChoose');
      const btnCancel = $('ppCancel');

      // openPhotoPicker({ onFile: (File)=>void })
      function openPhotoPicker(ctx){
        if (!ctx || typeof ctx.onFile !== 'function') return;
        popupEl.classList.add('show');
        popupEl.setAttribute('aria-hidden','false');

        const cleanup = () => {
          popupEl.classList.remove('show');
          popupEl.setAttribute('aria-hidden','true');
          btnTake.onclick = btnChoose.onclick = btnCancel.onclick = null;
          document.removeEventListener('keydown', onEsc);
          fileChooser.onchange = null; fileCamera.onchange = null;
        };
        const onEsc = e => { if (e.key === 'Escape') cleanup(); };
        document.addEventListener('keydown', onEsc);
        popupEl.onclick = (e)=>{ if (e.target === popupEl) cleanup(); };

        const attachAndClick = (inputEl) => {
          inputEl.onchange = () => {
            const f = inputEl.files && inputEl.files[0];
            cleanup();
            if (f) ctx.onFile(f);
            inputEl.value = ''; // reset for next time
          };
          // On some browsers, must be inside a user gesture: use setTimeout 0
          setTimeout(()=> inputEl.click(), 0);
        };

        btnTake.onclick = () => attachAndClick(fileCamera);
        btnChoose.onclick = () => attachAndClick(fileChooser);
        btnCancel.onclick = cleanup;
      }

        function setNewPhotoFile(f){
        newItemPhotoFile = f || null;
        const photoName = $('photoName');
        if (photoName) photoName.textContent = f ? (f.name || '1 image selected') : '';
        if (f) setPhotoPreview(''); // hide existing preview if choosing a new file
      }
      function setPhotoPreview(url){
        const img = $('photoPreview'); if (!img) return;
        if (url){ img.src = url; img.style.display = 'block'; }
        else { img.removeAttribute('src'); img.style.display = 'none'; }
      }

    

      // Photo upload helpers for items
      async function uploadItemPhoto(file, itemId, prevPath){
        if (!auth || !auth.currentUser || !household) throw new Error('Sign in and set household first.');
        const clean = (file.name || 'photo').replace(/[^a-zA-Z0-9._-]/g,'_');
        const path = `${household}/${itemId}/${Date.now()}-${clean}`;
        const ref = storage.ref().child(path);
        const metadata = { contentType: file.type || 'image/jpeg', customMetadata: { uid: auth.currentUser.uid, itemId } };
        const snap = await ref.put(file, metadata);
        const url = await snap.ref.getDownloadURL();
        await db.collection('lists').doc(household).collection('items').doc(itemId).set({
          photoUrl: url, photoPath: path, photoUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
        if (prevPath && prevPath !== path) { try { await storage.ref().child(prevPath).delete(); } catch(e){} }
        return { url, path };
      }

      async function removeItemPhoto(itemId, photoPath){
        if (!auth || !auth.currentUser || !household) throw new Error('Sign in and set household first.');
        if (photoPath) { try { await storage.ref().child(photoPath).delete(); } catch(e){} }
        await db.collection('lists').doc(household).collection('items').doc(itemId).set({
          photoUrl: firebase.firestore.FieldValue.delete(),
          photoPath: firebase.firestore.FieldValue.delete(),
          photoUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
      }
    // Photo upload helper for RECIPE cover
  async function uploadRecipeCover(file, recipeId, prevPath){
    if (!auth || !auth.currentUser || !household || !recipeId) throw new Error('Not ready');
    const clean = (file.name || 'cover').replace(/[^a-zA-Z0-9._-]/g,'_');
    const path = `${household}/recipes/${recipeId}/cover-${Date.now()}-${clean}`;
    const ref = storage.ref().child(path);
    const metadata = { contentType: file.type || 'image/jpeg', customMetadata: { uid: auth.currentUser.uid, recipeId } };
    const snap = await ref.put(file, metadata);
    const url = await snap.ref.getDownloadURL();

    await db.collection('recipes').doc(household).collection('recipes').doc(recipeId)
      .set({
        coverUrl: url,
        coverPath: path,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
      }, { merge: true });

    if (prevPath && prevPath !== path) { try { await storage.ref().child(prevPath).delete(); } catch(e){} }
    return { url, path };
  }

  /** Upload a single STEP photo to Storage; return { url, path }.
   *  Does NOT write Firestore directly — caller merges into the steps[] array. */
  async function uploadStepPhoto(file, recipeId, stepId, prevPath){
    if (!auth || !auth.currentUser || !household || !recipeId || !stepId) throw new Error('Not ready');
    const clean = (file.name || 'step').replace(/[^a-zA-Z0-9._-]/g,'_');
    const path = `${household}/recipes/${recipeId}/steps/${stepId}-${Date.now()}-${clean}`;
    const ref = storage.ref().child(path);
    const metadata = { contentType: file.type || 'image/jpeg', customMetadata: { uid: auth.currentUser.uid, recipeId, stepId } };
    const snap = await ref.put(file, metadata);
    const url = await snap.ref.getDownloadURL();

    // Remove the old file if changing photo
    if (prevPath && prevPath !== path) { try { await storage.ref().child(prevPath).delete(); } catch(e){} }

    return { url, path };
  }



      function renderRow(it){
        const row = document.createElement('div');
        row.className = 'item';
        row.dataset.cat = ((it.category || '').trim().toLowerCase().replace(/[^a-z0-9]+/g, '-'));

        /* 1) Checkbox */
        const left = document.createElement('div');
        left.className = 'left';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = !!it.checked;
  cb.onchange = async () => {
    const isChecked = !!cb.checked;
    const patch = {
      checked: isChecked,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    // If the user checks the box, zero the qty
    if (isChecked) {
      patch.qty = '0';
    }

    try {
      await updateItem(it.id, patch);

      // reflect local state
      it.checked = isChecked;
      if (isChecked) {
        it.qty = '0';
        // Update the inline qty input on this row (if present)
        const qi = row.querySelector('.qty-inline');
        if (qi) qi.value = '0';
      }
    } catch (e) {
      console.error('Checkbox update failed:', e);
      showToast('Failed to update item');
    }
  };




        left.appendChild(cb);

        /* 2) Title */
        const line1 = document.createElement('div');
        line1.className = 'line1';
        const catdot = document.createElement('span'); catdot.className = 'catdot';
        const nameEl = document.createElement('span');
  nameEl.className = 'name';
  nameEl.textContent = it.name || '';

  // Show red flag if routeOrder is missing or invalid
  const routeMissing = (
    it.routeOrder === undefined ||
    it.routeOrder === null ||
    it.routeOrder === '' ||
    isNaN(parseFloat(it.routeOrder))
  );
  if (routeMissing) {
    const flag = document.createElement('span');
    flag.textContent = ' 🚩';
    flag.title = 'No route number set';
    flag.style.color = 'red';
    nameEl.appendChild(flag);
  }

  line1.append(catdot, nameEl);
    // Second line under the name: Qty input + optional Size text
  const meta = document.createElement('div');
  meta.className = 'meta';

  // Qty input
  const qtyInline = document.createElement('input');
  qtyInline.type = 'text';
  qtyInline.inputMode = 'decimal';
  qtyInline.placeholder = 'Qty';
  qtyInline.className = 'qty-inline';
  qtyInline.value = it.qty || '';
        // === Auto-size width to content ===
  function autoSizeInput(el) {
    // Minimum width = 4ch; grows with content
    const len = (el.value && el.value.length) ? el.value.length : 1;
    const ch = Math.max(len + 1, 4); // 4ch floor
    el.style.width = ch + 'ch';
  }

  autoSizeInput(qtyInline);
  qtyInline.addEventListener('input', () => autoSizeInput(qtyInline));


  // Save qty changes (same logic as before)
  qtyInline.addEventListener('change', async () => {
    const newQty = (qtyInline.value || '').trim();

    const asNum = (s) => (typeof parseNum === 'function' ? parseNum(s) : NaN);
    const wasZeroish = !it.qty || asNum(it.qty) === 0;

    const n = asNum(newQty);
    const nowPositive = (Number.isFinite(n) && n > 0) || (!Number.isFinite(n) && newQty !== '');

    const shouldUncheck = !!it.checked && wasZeroish && nowPositive;

    try {
      const patch = {
        qty: newQty,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (shouldUncheck) patch.checked = false;

      await updateItem(it.id, patch);

      it.qty = newQty;
      if (shouldUncheck) {
        cb.checked = false;
        it.checked = false;
        showToast('Moved back to Shopping');
      }
    } catch (e) {
      console.error('Qty inline update failed:', e);
      showToast('Failed to update qty');
    }
  });

  meta.appendChild(qtyInline);

  // Optional size text
  if (it.size) {
    const sizeSpan = document.createElement('span');
    sizeSpan.className = 'muted';
    sizeSpan.textContent = it.size;
    meta.appendChild(sizeSpan);
  }

  // attach the second line under the name
  line1.append(meta);



      /* 3) Actions */
  let actions = null;

  // Only show Edit/Delete on LIST tab (hide on SHOPPING tab)
  if (activeTab !== 'shopping') {
    actions = document.createElement('div');
    actions.className = 'actions';

    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'editbtn';
    editBtn.textContent = 'Edit';
    editBtn.onclick = (ev) => {
      ev.stopPropagation();
      const editing = row.classList.toggle('editing');
      editBtn.textContent = editing ? 'Close' : 'Edit';
      
    };

  const delBtn = document.createElement('button');
  delBtn.type = 'button';
  delBtn.className = 'btn-icon';
  delBtn.title = 'Delete item';
  delBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-trash"></use></svg>';
  delBtn.style.display = 'none';   // 🔴 hide by default
  delBtn.onclick = () => removeItem(it.id);

  actions.append(editBtn, delBtn);

  // Toggle editing: show/hide trash button
  editBtn.onclick = (ev) => {
    ev.stopPropagation();
    const editing = row.classList.toggle('editing');
    editBtn.textContent = editing ? 'Close' : 'Edit';
    delBtn.style.display = editing ? '' : 'none';   // 🔴 only show in editing mode
    
  };

  }


        /* 4) Below row: media + notes */
        const below = document.createElement('div');
        below.className = 'below';

        const mediaCell = document.createElement('div');

        const mountCameraBtn = () => {
          mediaCell.innerHTML = '';
          const camBtn = document.createElement('button');
          camBtn.type = 'button';
          camBtn.className = 'camBtn';
          camBtn.title = 'Add photo';
          camBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-camera"></use></svg>';
          camBtn.onclick = () => {
            openPhotoPicker({
              onFile: async (file) => {
                if (!file) return;
                try {
                  showToast('Uploading photo…');
                  const { url, path } = await uploadItemPhoto(file, it.id, it.photoPath || null);
                  it.photoUrl = url; it.photoPath = path;
                  mountThumb(url);
                  below.classList.remove('hidden');
                  showToast('Photo updated');
                  removePhotoBtn.disabled = false;

                } catch(e){ alert('Upload failed: ' + (e.message || e)); }
              }
            });
          };
          mediaCell.appendChild(camBtn);
        };

        const mountThumb = (url) => {
          mediaCell.innerHTML = '';
          const thumb = document.createElement('img');
          thumb.className = 'thumb';
          thumb.src = url;
          thumb.alt = it.name || 'photo';
          thumb.onclick = () => openLightbox(url);
          mediaCell.appendChild(thumb);
        };

        if (it.photoUrl) mountThumb(it.photoUrl); else mountCameraBtn();

        const line2 = document.createElement('div');
        line2.className = 'line2';
        line2.textContent = it.notes || '';

        below.append(mediaCell, line2);

        if (!it.photoUrl && !it.notes) below.classList.add('hidden');

        /* 5) Editor row */
        const editor = document.createElement('div');
        editor.className = 'editor';

        const qty = document.createElement('input');
        qty.className = 'qty'; qty.placeholder = 'Qty'; qty.value = it.qty || '';
        qty.onchange = () => updateItem(it.id, { qty: qty.value });

        const size = document.createElement('input');
        size.className = 'size'; size.placeholder = 'Size'; size.value = it.size || '';
        size.onchange = () => updateItem(it.id, { size: size.value });

        const notes = document.createElement('input');
        notes.className = 'notes'; notes.placeholder = 'Notes'; notes.value = it.notes || '';
        notes.onchange = () => updateItem(it.id, { notes: notes.value });

        const cat  = document.createElement('select'); cat.className = 'category';
        ["", "Produce", "Meat & Poultry", "Fish & Seafood", "Dairy & Eggs", "Bakery", "Pantry", "Frozen", "Beverages", "Snacks & Confectionery", "Household & Cleaning", "Personal Care & Health", "Other"].forEach(opt => {
          const o = document.createElement('option'); o.value = opt; o.textContent = opt || '— Select —';
          if ((it.category||'') === opt) o.selected = true; cat.appendChild(o);
        });
        cat.onchange = () => updateItemAndCatalog(it, { category: cat.value });

        const route = document.createElement('input');
        route.className = 'route'; route.type = 'number'; route.step = '0.1'; route.placeholder = 'Route'; route.value = it.routeOrder ?? '';
        route.onchange = () => updateItemAndCatalog(it, { routeOrder: route.value ? Number(route.value) : '' });

        const changePhoto = document.createElement('button');
        changePhoto.type = 'button'; changePhoto.textContent = it.photoUrl ? 'Change photo' : 'Add photo';
        changePhoto.onclick = () => {
          openPhotoPicker({
            onFile: async (file) => {
              if (!file) return;
              try {
                showToast('Uploading photo…');
                const { url, path } = await uploadItemPhoto(file, it.id, it.photoPath || null);
                it.photoUrl = url; it.photoPath = path;
                mountThumb(url);
                below.classList.remove('hidden');
                showToast('Photo updated');
                removePhotoBtn.disabled = false;

              } catch(e){ alert('Upload failed: ' + (e.message || e)); }
            }
          });
        };

        const removePhotoBtn = document.createElement('button');
        removePhotoBtn.type = 'button'; removePhotoBtn.textContent = 'Remove photo';
        removePhotoBtn.disabled = !it.photoPath;
        removePhotoBtn.onclick = async () => {
          try {
            await removeItemPhoto(it.id, it.photoPath || null);
            it.photoUrl = ''; it.photoPath = '';
            mountCameraBtn();
            below.classList.toggle('hidden', !it.notes);
            showToast('Photo removed');
          } catch(e){
            alert('Failed to remove photo: ' + (e.message || e));
          }
        };

        editor.append(qty, size, notes, cat, route, changePhoto, removePhotoBtn);

        /* Assemble row */
      // Assemble row (omit actions on Shopping tab)
  if (actions) {
    row.append(left, line1, actions, below, editor);
  } else {
    row.append(left, line1, below, editor);
  }


        // Flash if just added
        if (it.id === lastAddedId) {
          requestAnimationFrame(() => {
            row.classList.add('flash');
            row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            setTimeout(() => row.classList.remove('flash'), 900);
            lastAddedId = null;
          });
        }

        return row;
      }

      async function updateItem(id, patch){
        if (!auth || !auth.currentUser || !household) return alert('Sign in and set household first.');
        const ref = db.collection('lists').doc(household).collection('items').doc(id);
        await ref.set(patch, { merge: true });
      }

      async function updateItemAndCatalog(it, patch){
        await updateItem(it.id, patch);
        const name = (it.name||'').trim(); if (!name) return;
        const key = name.toLowerCase();
        const catRef = db.collection('catalog').doc(household).collection('items').doc(key);
        const data = { name, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
        if (patch.category !== undefined) data.category = patch.category || '';
        if (patch.routeOrder !== undefined) data.routeOrder = (patch.routeOrder === '' ? '' : Number(patch.routeOrder));
        await catRef.set(data, { merge: true });
        catalogCache.set(key, { category: data.category ?? '', routeOrder: data.routeOrder ?? '' });
      }

      async function removeItem(id){
        if (!auth || !auth.currentUser || !household) return;
        // best-effort: delete attached photo too
        try{
          const doc = await db.collection('lists').doc(household).collection('items').doc(id).get();
          const d = doc.exists ? doc.data() : null;
          if (d && d.photoPath) { try { await storage.ref().child(d.photoPath).delete(); } catch(e){} }
        }catch(e){}
        await db.collection('lists').doc(household).collection('items').doc(id).delete();
      }

  const _clearBtn = $('clearChecked'); if (_clearBtn) _clearBtn.onclick = async () => {
    if (!auth || !auth.currentUser || !household) return alert('Sign in and set household first.');

    // Uncheck all checked items; do NOT delete docs or photos.
    const qs = await db.collection('lists').doc(household).collection('items')
      .where('checked','==',true).get();

    if (qs.empty) { showToast('Nothing to clear'); return; }

    const batch = db.batch();
    qs.forEach(doc => {
      batch.set(doc.ref, { checked: false, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
    });

    await batch.commit();
    showToast('Unchecked all items');
  };


      // === Add new item ===
      $('newItemAddPhoto').onclick = () => {
        openPhotoPicker({
          onFile: (file) => {
            setNewPhotoFile(file);
            showToast('Photo selected');
          }
        });
      };

          $('add').onclick = async () => {
        if (!auth || !auth.currentUser || !household) return alert('Click Sign in, then set the household code.');
        const name = $('itemName').value.trim(); if (!name) return alert('Type an item name.');
        const qty = $('itemQty').value.trim();
        const size = $('itemSize').value.trim();
        let category = $('itemCategory').value.trim ? $('itemCategory').value.trim() : $('itemCategory').value;
        let routeOrder = $('itemRoute').value ? Number($('itemRoute').value) : '';
        const notes = $('itemNotes').value.trim();
        const photoFile = newItemPhotoFile || null;

        const known = catalogCache.get(name.toLowerCase());
        if (known){
          if (!category && known.category) category = known.category;
          if ((routeOrder === '' || isNaN(routeOrder)) && (known.routeOrder || known.routeOrder===0)) routeOrder = known.routeOrder;
        }

        // === UPDATE existing item if a suggestion was selected ===
        if (selectedItemId){
          try{
            await updateItem(selectedItemId, {
              name,
              qty,
              size,
              notes,
              category: category || '',
              routeOrder: routeOrder === '' ? '' : Number(routeOrder),
              checked: false, // force unchecked so it shows on the active list
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            if (photoFile){
              try {
                await uploadItemPhoto(photoFile, selectedItemId, selectedItemPhotoPath || null);
              } catch(e){ console.warn('Photo upload during update failed:', e.message); }
            }

            // Update catalog (same as create path)
            try{
              await db.collection('catalog').doc(household).collection('items')
                .doc(name.toLowerCase())
                .set({
                  name,
                  category: category || '',
                  routeOrder: routeOrder === '' ? '' : Number(routeOrder),
                  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
              catalogCache.set(name.toLowerCase(), {
                category: category || '',
                routeOrder: routeOrder === '' ? '' : Number(routeOrder)
              });
            } catch(e){ console.warn('Catalog save failed:', e.message); }

            showToast(selectedItemInitialChecked ? `Unchecked and updated '${name}'.` : `Updated '${name}'.`);
          } catch(e){
            alert('Failed to update: ' + (e.message || e));
            return;
          }

                   // Clear form + state
          $('itemName').value=''; $('itemQty').value=''; $('itemSize').value='';
          $('itemCategory').value=''; $('itemRoute').value=''; $('itemNotes').value='';
          
          liveListQuery = '';                          // reset live filter
          scheduleRenderItems(lastSnapshotItems || []); // re-render full list

          newItemPhotoFile = null;
          const pn = $('photoName'); if (pn) pn.textContent = '';
          setPhotoPreview('');
          clearUpdateMode();
          return;

        }

        // === CREATE new item (existing behavior) ===
        let newId = null;
        try {
          const ref = db.collection('lists').doc(household).collection('items').doc();
          newId = ref.id;
          await ref.set({
            name, qty, size, notes,
            category: category || '',
            routeOrder: routeOrder === '' ? '' : Number(routeOrder),
            checked: false,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
          lastAddedId = newId;
        } catch(e){
          return alert('Add failed: ' + (e.message || e));
        }

        if (photoFile && newId){
          try{
            await uploadItemPhoto(photoFile, newId, null);
          } catch(e){ console.warn('Photo upload failed:', e.message); }
        }

        // Save to catalog for next time
        if (name){
          try{
            await db.collection('catalog').doc(household).collection('items')
              .doc(name.toLowerCase())
              .set({
                name,
                category: category || '',
                routeOrder: routeOrder === '' ? '' : Number(routeOrder),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
              }, { merge: true });
            catalogCache.set(name.toLowerCase(), {
              category: category || '',
              routeOrder: routeOrder === '' ? '' : Number(routeOrder)
            });
          } catch(e){ console.warn('Catalog save failed:', e.message); }
        }

               // clear form (existing)
        $('itemName').value=''; $('itemQty').value=''; $('itemSize').value='';
        $('itemCategory').value=''; $('itemRoute').value=''; $('itemNotes').value='';
        
        liveListQuery = '';                          // reset live filter
        scheduleRenderItems(lastSnapshotItems || []); // re-render full list

        // clear pending new photo
        newItemPhotoFile = null;
        const pn = $('photoName'); if (pn) pn.textContent = '';
        setPhotoPreview('');

      };

      

  function setActiveTab(tab){ // 'list' | 'shopping' | 'recipes'
    activeTab = tab;
    const isShopping = tab === 'shopping';
    const isRecipes  = tab === 'recipes';

    // Re-query the buttons NOW (they didn’t exist when the first consts ran)
    const tList     = document.getElementById('tabList');
    const tShopping = document.getElementById('tabShopping');
    const tRecipes  = document.getElementById('tabRecipes');

    // Clear all, then set the active one
    [tList, tShopping, tRecipes].forEach(b => b && b.classList.remove('active'));
    if (tList)     tList.classList.toggle('active', tab === 'list');
    if (tShopping) tShopping.classList.toggle('active', isShopping);
    if (tRecipes)  tRecipes.classList.toggle('active', isRecipes);

    // Sections
    const listSection = $('listSection');
    const recipesView = $('recipesView');
    if (listSection) listSection.style.display = isRecipes ? 'none' : '';
    if (recipesView) recipesView.style.display = isRecipes ? '' : 'none';

    // List-only controls
    const addRow   = $('addRow');
    const clearBtn = $('clearChecked');
    if (addRow)   addRow.style.display   = (tab === 'list') ? '' : 'none';
    if (clearBtn) clearBtn.style.display = (tab === 'list') ? '' : 'none';
    // Ensure the "hide items" state only applies on the List tab

  if (listSection){
    if (tab === 'list'){
      // Re-apply the saved preference when entering the List tab
      const saved = localStorage.getItem('listCollapsed'); // "true" | "false" | null
      if (saved === 'false') {
        listSection.removeAttribute('data-list-collapsed');
      } else {
        // default hidden if missing or "true"
        listSection.setAttribute('data-list-collapsed', 'true');
      }
    } else {
      // Leaving the List tab: clear the attribute so Shopping/Recipes are never affected
      listSection.removeAttribute('data-list-collapsed');
    }
  }

  const toggleRow = $('toggleListItemsRow');
  if (toggleRow) toggleRow.style.display = (tab === 'list') ? '' : 'none';

    // Filters & “how it works”
  if (filterGroup) {
    filterGroup.style.display = (tab === 'list' || tab === 'shopping') ? '' : 'none';
  }

    const how = $('howItWorks');
    if (how) how.style.display = (tab === 'list') ? '' : 'none';

    // Persist + re-render list view
    localStorage.setItem('activeTab', tab);
    render(lastSnapshotItems || []);
  }



    
    
  // ==== Recipes: modal wiring (shell only) ====
      let editingRecipeId = null; // null = add mode, otherwise recipeId
  // Cover state + elements
  let rmCoverFile = null;
  let rmRemoveCover = false;
  let rmExistingCoverPath = null;

  const rmCoverBtn       = document.getElementById('rmCoverBtn');
  const rmCoverName      = document.getElementById('rmCoverName');
  const rmCoverPreview   = document.getElementById('rmCoverPreview');
  const rmCoverRemoveBtn = document.getElementById('rmCoverRemove');
  // === INGREDIENTS: Add Ingredient button ===
  const rmAddIngredientBtn = document.getElementById('rmAddIngredient');
  const rmIngredients = document.getElementById('rmIngredients');
  if (rmIngredients) {
  rmIngredients.addEventListener('click', (e) => {
    const delBtn = e.target.closest('.ing-del');
    if (!delBtn) return;
    const row = delBtn.closest('.ing-row');
    if (row) {
      row.remove();
      markRecipeDirty();
    }
  });
}


  // Factory: build one ingredient row
  function createIngRow(prefill=null){
    const row = document.createElement('div');
    row.className = 'ing-row';

    row.innerHTML = `
      <!-- Row 1 -->
      <div class="ing-name-wrap" style="position:relative;">
        <textarea class="ing-name" placeholder="Ingredient name"></textarea>
        <div class="ac-list ing-ac" role="listbox" aria-label="Suggestions" style="display:none"></div>
      </div>
      <input class="ing-qty" type="text" placeholder="Qty" />
      <input class="ing-size" type="text" placeholder="Size" />

      <!-- Row 2 -->
      <div></div> <!-- empty space under Name -->
      <textarea class="ing-notes" placeholder="Notes"></textarea>
      <button class="ing-del" type="button" title="Remove">✕</button>
    `;

    // Prefill if provided
    if (prefill){
      if (typeof prefill.name  === 'string') row.querySelector('.ing-name').value  = prefill.name;
      if (typeof prefill.qty   === 'string') row.querySelector('.ing-qty').value   = prefill.qty;
      if (typeof prefill.size  === 'string') row.querySelector('.ing-size').value  = prefill.size;
      if (typeof prefill.notes === 'string') row.querySelector('.ing-notes').value = prefill.notes;
    }

    // Wire delete button
    row.querySelector('.ing-del').onclick = () => { row.remove(); markRecipeDirty(); };

    // Bind autocomplete to this row
    bindIngredientAC(row);

    return row;
  }

  if (rmAddIngredientBtn) {
  rmAddIngredientBtn.onclick = () => {
    if (!rmIngredients){
      alert('Missing #rmIngredients container in the modal.');
      return;
    }
    const row = createIngRow();
    rmIngredients.appendChild(row);
    markRecipeDirty();
    const name = row.querySelector('.ing-name');
    if (name) name.focus();
  };
}




  if (rmCoverBtn) {
    rmCoverBtn.onclick = () => {
      openPhotoPicker({
        onFile: (file) => {
          rmCoverFile = file;
          rmRemoveCover = false;
          if (rmCoverName) rmCoverName.textContent = file.name || '1 image selected';
          if (rmCoverPreview) {
            rmCoverPreview.src = URL.createObjectURL(file);
            rmCoverPreview.style.display = 'block';
          }
          if (rmCoverRemoveBtn) rmCoverRemoveBtn.style.display = '';
          showToast('Cover selected');
          markRecipeDirty();
        }
      });
    };
  }

  if (rmCoverRemoveBtn) {
    rmCoverRemoveBtn.onclick = () => {
      rmCoverFile = null;
      rmRemoveCover = true;
      if (rmCoverPreview) { rmCoverPreview.removeAttribute('src'); rmCoverPreview.style.display = 'none'; }
      if (rmCoverName) rmCoverName.textContent = '';
      showToast('Cover will be removed');
      markRecipeDirty();
    };
  }

  // ===== TAGS: Top-10 + Add with autocomplete =====
  const rmTagsEl        = $('rmTags');
  const rmAddTagBtn     = $('rmAddTag');
  const rmTagAdderWrap  = $('rmTagAdderWrap');
  const rmTagInput      = $('rmTagInput');
  const rmTagAC         = $('rmTagAC');

  const MAX_TAGS_PER_RECIPE = 10;
  const TAG_MAXLEN = 24;
  // allowed chars: letters, numbers, space, dash, ampersand
  const TAG_OK = /^[A-Za-z0-9 \-&]{1,24}$/;

  // Fallback suggestions if you have <10 tags in your data
  const DEFAULT_TAGS = [
    'vegan', 'vegetarian', 'gluten-free', 'dairy-free', 'quick',
    'dessert', 'breakfast', 'dinner', 'spicy', 'kid-friendly'
  ];

  // Small helper (self-contained so we don’t depend on global one)
  function escapeHtml(str){
    return String(str)
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#39;");
  }

  // Build a map of all tags across loaded recipes
  function getAllTagStats(){
    const map = new Map(); // key = lower, val = {nameSample, count}
    (lastSnapshotRecipes || []).forEach(r => {
      const arr = Array.isArray(r.tags) ? r.tags : [];
      arr.forEach(t => {
        if (!t) return;
        const lower = t.toLowerCase();
        const prev = map.get(lower) || { nameSample: t, count: 0 };
        prev.count += 1;
        if (!map.has(lower)) prev.nameSample = t;
        map.set(lower, prev);
      });
    });
    return map;
  }

  function computeTopTags(limit=10){
    const stats = getAllTagStats();

    // Start with real usage, sorted by count desc then alpha
    const used = Array.from(stats.entries())
      .map(([lower, obj]) => ({ lower, label: obj.nameSample, count: obj.count }))
      .sort((a,b) => b.count - a.count || a.label.localeCompare(b.label));

    // If fewer than 'limit', pad with DEFAULT_TAGS (no duplicates)
    const haveLow = new Set(used.map(t => t.lower));
    for (const d of DEFAULT_TAGS){
      if (used.length >= limit) break;
      const low = d.toLowerCase();
      if (!haveLow.has(low)){
        used.push({ lower: low, label: d, count: 0 });
        haveLow.add(low);
      }
    }

    return used.slice(0, limit);
  }

  // Render the chip row: selected first, then top tags (non-duplicates)
  function renderTagsUI(selectedTags){
    if (!rmTagsEl) return;
    rmTagsEl.innerHTML = '';

    const sel = Array.isArray(selectedTags) ? selectedTags.slice(0, MAX_TAGS_PER_RECIPE) : [];
    const selLow = new Set(sel.map(s => s.toLowerCase()));

    // Header badge
    const hdr = document.createElement('span');
    hdr.className = 'tag-badge';
    hdr.textContent = 'Top tags';
    rmTagsEl.appendChild(hdr);

    // Selected chips first (active)
    sel.forEach(t => rmTagsEl.appendChild(makeTagChip(t, true)));

    // Then top tags (skip those already selected)
    const top = computeTopTags(10);
    top.forEach(t => {
      if (!selLow.has(t.lower)) rmTagsEl.appendChild(makeTagChip(t.label, false));
    });
  }

  function makeTagChip(label, active){
    const chip = document.createElement('span');
    chip.className = 'tagchip' + (active ? ' active' : '');
    chip.dataset.tag = label;
    chip.textContent = label;

    // small “x” to remove if active
    if (active){
      const x = document.createElement('span');
      x.className = 'x';
      x.textContent = '×';
      x.title = 'Remove';
      chip.appendChild(x);
    }

    chip.onclick = (e) => {
      const isClose = e.target.classList.contains('x');
      if (isClose){
        chip.remove();
        markRecipeDirty(); 
        return;
      }
      // toggle selection
      chip.classList.toggle('active');
      enforceTagLimit();
      markRecipeDirty();  
    };

    return chip;
  }

  function enforceTagLimit(){
    // if more than MAX_TAGS_PER_RECIPE active, turn off extras (keep earliest)
    const act = Array.from(document.querySelectorAll('#rmTags .tagchip.active'));
    if (act.length <= MAX_TAGS_PER_RECIPE) return;
    act.slice(MAX_TAGS_PER_RECIPE).forEach(el => el.classList.remove('active'));
  }

  // Public helpers used by Save
  function getActiveTags(){
    const chips = document.querySelectorAll('#rmTags .tagchip.active');
    return Array.from(chips).map(el => el.dataset.tag).filter(Boolean);
  }
  function clearActiveTags(){
    document.querySelectorAll('#rmTags .tagchip.active').forEach(el => el.classList.remove('active'));
  }

  // ——— Add Tag input / autocomplete ———
  if (rmAddTagBtn){
    rmAddTagBtn.onclick = () => {
      rmTagAdderWrap.style.display = '';
      rmTagInput.value = '';
      rmTagAC.style.display = 'none';
      rmTagAC.innerHTML = '';
      rmTagInput.focus();
    };
  }

  if (rmTagInput){
    const closeAC = () => { rmTagAC.style.display = 'none'; rmTagAC.innerHTML = ''; };

    rmTagInput.addEventListener('input', () => {
      const q = (rmTagInput.value || '').trim().toLowerCase();
      const stats = getAllTagStats();
      const all = Array.from(stats.values()).map(v => v.nameSample);

      // filter not already active
      const selectedLow = new Set(getActiveTags().map(t => t.toLowerCase()));
      const matches = all
        .filter(t => t.toLowerCase().includes(q))
        .filter(t => !selectedLow.has(t.toLowerCase()))
        .sort((a,b) => a.localeCompare(b))
        .slice(0, 8);

      if (!q && !matches.length){ closeAC(); return; }

      rmTagAC.innerHTML = '';
      matches.forEach(m => {
        const row = document.createElement('div');
        row.className = 'ac-item';
        row.textContent = m;
        row.onclick = () => { addTagToSelection(m); closeAC(); };
        rmTagAC.appendChild(row);
      });

      // Offer to create a new tag if no exact match
      if (q && !all.some(t => t.toLowerCase() === q) && TAG_OK.test(rmTagInput.value)){
        const createRow = document.createElement('div');
        createRow.className = 'ac-item';
        createRow.innerHTML = `Create “${escapeHtml(rmTagInput.value.trim())}”`;
        createRow.onclick = () => { addTagToSelection(rmTagInput.value.trim()); closeAC(); };
        rmTagAC.appendChild(createRow);
      }

      rmTagAC.style.display = rmTagAC.childElementCount ? 'block' : 'none';
    });

  rmTagInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === 'Done' || e.keyCode === 13){
      e.preventDefault();
      const txt = (rmTagInput.value || '').trim();
      if (!txt) return;
      addTagToSelection(txt);
      rmTagInput.value = '';
      rmTagAC.style.display = 'none';
      rmTagAC.innerHTML = '';
      return;
    }
    if (e.key === 'Escape'){
      rmTagAdderWrap.style.display = 'none';
      rmTagAC.style.display = 'none';
    }
  });


    document.addEventListener('click', (e) => {
      if (!rmTagAdderWrap.contains(e.target) && e.target !== rmAddTagBtn){
        rmTagAC.style.display = 'none';
      }
    });
  }

  function addTagToSelection(raw){
    let label = (raw || '').trim().toLowerCase();
    if (!label) return;
    if (!TAG_OK.test(label)){
      alert('Tag can only use lowercase letters, numbers, spaces, “-”, “&” and up to 24 characters.');
      return;
    }

    // de-duplicate (case-insensitive)
    const current = getActiveTags();
    const lowSet = new Set(current.map(t => t.toLowerCase()));
    if (lowSet.has(label)) return;

    // create chip as active (selected)
    rmTagsEl.insertBefore(
      makeTagChip(label, true),
      rmTagsEl.firstChild ? rmTagsEl.firstChild.nextSibling : null /* after badge */
    );
    enforceTagLimit();
    markRecipeDirty();
  }



  const recipesView = $('recipesView');
  const btnOpenAddRecipe = $('btnOpenAddRecipe');

  const recipeModal = $('recipeModal');
  const rmClose = $('rmClose');
  const rmSave = $('rmSave');
  const rmDelete = $('rmDelete');
    // === Dirty state for Recipe Modal ===
  let recipeDirty = false;

  function updateRecipeSaveButton(){
    if (!rmSave) return;
    if (recipeDirty){
      rmSave.textContent = 'Save';
      rmSave.classList.add('btn-pink');
    } else {
      rmSave.textContent = 'Close';
      rmSave.classList.remove('btn-pink');
    }

  }


  function markRecipeDirty(){
    if (!recipeDirty){
      recipeDirty = true;
      updateRecipeSaveButton();
    }
  }

  // Any user edits inside the recipe modal will mark it dirty
  if (recipeModal){
    recipeModal.addEventListener('input', markRecipeDirty, true);
    recipeModal.addEventListener('change', markRecipeDirty, true);
  }

      // Add-step button
  const rmAddStepBtn = $('rmAddStep');
if (rmAddStepBtn) rmAddStepBtn.onclick = () => { addStepRow(); markRecipeDirty(); };




  function openRecipeModal(mode='add', data=null){
      // defensive: deep-clone so we never mutate the original recipe object used elsewhere
    data = data ? JSON.parse(JSON.stringify(data)) : null;

    $('rmTitle').textContent = mode === 'edit' ? 'Edit Recipe' : 'Add Recipe';
    editingRecipeId = (mode === 'edit' && data && data.id) ? data.id : null;
    // Show Delete only in edit mode
  if (rmDelete) {
    rmDelete.style.display = editingRecipeId ? '' : 'none';
      // Reset dirty state after initial field population
    recipeDirty = false;
    // Ensure modal buttons are pink-styled
  const rmSaveBtn  = document.getElementById('rmSaveBtn')  || recipeModal.querySelector('.rm-save')  || recipeModal.querySelector('.modal-footer button:last-child');
  const rmCloseBtn = document.getElementById('rmCloseBtn') || recipeModal.querySelector('.rm-close') || recipeModal.querySelector('.modal-footer button:first-child');

  [rmSaveBtn, rmCloseBtn].forEach(b => b && b.classList.add('btn-pink'));

    updateRecipeSaveButton();

  }


    // reset fields
    $('rmName').value = (data && data.name) || '';
    $('rmBasePortions').value = (data && data.basePortions) || 2;

  // tags (render top + preselect from recipe)
  const preset = (data && Array.isArray(data.tags)) ? data.tags : [];
  renderTagsUI(preset);

  // Cover: reset state + preview
  rmCoverFile = null;
  rmRemoveCover = false;
  rmExistingCoverPath = (data && data.coverPath) ? data.coverPath : null;

  const p = $('rmCoverPreview');
  const rmRemoveBtn = $('rmCoverRemove');
  const rmNameLbl  = $('rmCoverName');

  if (p){
    if (data && data.coverUrl){
      p.src = data.coverUrl;
      p.style.display='block';
      if (rmRemoveBtn) rmRemoveBtn.style.display = '';
      if (rmNameLbl)  rmNameLbl.textContent = '';
    } else {
      p.src = '';
      p.style.display='none';
      if (rmRemoveBtn) rmRemoveBtn.style.display = 'none';
      if (rmNameLbl)  rmNameLbl.textContent = '';
    }
  }
  // Rebuild the ingredient rows in the editor
  if (rmIngredients) {
    rmIngredients.innerHTML = '';

    // If editing and there are saved ingredients, render those; otherwise render one empty row
    const list = (data && Array.isArray(data.ingredients) && data.ingredients.length)
      ? data.ingredients
      : [ { name:'', qty:'', size:'', notes:'' } ];

    for (const ing of list) {
      rmIngredients.appendChild(createIngRow(ing));
    }
  }

  // Rebuild the steps in the editor
  const rmStepsList = document.getElementById('rmStepsList');
  if (rmStepsList) {
    rmStepsList.innerHTML = '';
    const stepsList = (data && Array.isArray(data.steps) && data.steps.length)
      ? data.steps
      : [];

    for (const step of stepsList) {
      addStepRow(step);
    }

    // Ensure drag is active and titles are numbered for existing steps
    if (typeof rmSteps_setupDnd === 'function') rmSteps_setupDnd();
    if (typeof rmSteps_renumber === 'function') rmSteps_renumber();
  }



    




    // show modal
    recipeModal.classList.add('show');
    recipeModal.setAttribute('aria-hidden','false');
    // ensure nothing is focused (also blurs whatever was focused on the list)
  setTimeout(() => {
    const ae = document.activeElement;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT' || ae.isContentEditable)) {
      ae.blur();
    }
  }, 0);

  }
  function closeRecipeModal(){
    recipeModal.classList.remove('show');
    recipeModal.setAttribute('aria-hidden','true');
  }

  if (btnOpenAddRecipe) btnOpenAddRecipe.onclick = () => openRecipeModal('add');
  if (rmClose) rmClose.onclick = closeRecipeModal;
    // Delete button: soft delete by default; ALT+Click => hard delete
  if (rmDelete) rmDelete.onclick = async (ev) => {
    if (!auth || !auth.currentUser || !household || !editingRecipeId) return;

    const hard = !!ev.altKey; // hold Alt for hard delete
    if (!hard) {
      const ok = confirm('Delete this recipe? It will be hidden from the list (soft delete).');
      if (!ok) return;

      try {
        const ref = db.collection('recipes').doc(household)
          .collection('recipes').doc(editingRecipeId);

        await ref.set({
          deletedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
        }, { merge: true });

        showToast('Recipe deleted');
        closeRecipeModal();
      } catch (e) {
        console.error(e);
        alert('Delete failed: ' + (e.message || e));
      }
    } else {
      const ok = confirm('HARD DELETE? This will permanently remove the recipe, its steps and ingredients, and the cover file. This cannot be undone.');
      if (!ok) return;
      try {
        await hardDeleteRecipe(editingRecipeId);
        closeRecipeModal();
      } catch (e) {
        console.error(e);
        alert('Hard delete failed: ' + (e.message || e));
      }
    }
  };


  if (rmSave) rmSave.onclick = async () => {
      // If nothing changed, behave like a Close button
    if (!recipeDirty) { closeRecipeModal(); return; }

    if (!auth || !auth.currentUser || !household) { alert('Sign in and set the household first.'); return; }
    


    const name = ($('rmName').value || '').trim();
    const basePortions = Math.max(1, parseInt(($('rmBasePortions').value || '1'), 10));
    const tags = getActiveTags();
    if (!name) { alert('Please enter a recipe name.'); $('rmName').focus(); return; }

    const nameLower = name.toLowerCase();

    try {
      const col = db.collection('recipes').doc(household).collection('recipes');

      // Duplicate-name guard (ignore the same doc if editing)
      const qs = await col.where('nameLower','==', nameLower).get();
      const dup = qs.docs.find(d => {
        const data = d.data() || {};
        const isDeleted = !!data.deletedAt;
        const isSame = editingRecipeId && d.id === editingRecipeId;
        return !isDeleted && !isSame;
      });
        if (dup) {
        alert('A recipe with that name already exists.');
        return;
      }

    // Close the modal immediately (keeps UI snappy)
  closeRecipeModal();
  await new Promise(r => setTimeout(r, 0));

  const now = firebase.firestore.FieldValue.serverTimestamp();
  const who = (auth.currentUser.email || auth.currentUser.uid || 'unknown');

  let recipeDocRef;

  // CREATE
  if (!editingRecipeId) {
    recipeDocRef = col.doc(); // pre-generate id

    await recipeDocRef.set({
      id: recipeDocRef.id,
      name,
      nameLower,
      basePortions,
      tags,
      coverUrl: null,
      coverPath: null,
      lastUsedServings: basePortions,
      createdAt: now,
      createdBy: who,
      updatedAt: now,
      updatedBy: who,
      deletedAt: null
    });

    showToast('Recipe created');
  }
  // UPDATE
  else {
    recipeDocRef = col.doc(editingRecipeId);

    await recipeDocRef.set({
      name,
      nameLower,
      basePortions,
      tags,
      updatedAt: now,
      updatedBy: who
    }, { merge: true });

    showToast('Recipe updated');
  }


  // === Save ingredients & steps (replace-all strategy) ===
  try {
    // Gather current editor state
    const ingredients = readIngredientsFromEditor();
    const steps = readStepsFromEditor();

    // Map stepId -> DOM row to access any selected File and previous path
    const listEl = document.getElementById('rmStepsList');
    const rowMap = new Map();
    if (listEl){
      Array.from(listEl.children).forEach(r => rowMap.set(r.dataset.stepId, r));
    }

    // Ensure we have a recipe id available for Storage paths
    const recipeIdForUpload = (typeof recipeDocRef !== 'undefined' && recipeDocRef && recipeDocRef.id)
      ? recipeDocRef.id
      : null;

    // Upload any newly chosen step photos, then patch the steps array
    if (recipeIdForUpload && Array.isArray(steps) && steps.length){
      for (const s of steps){
        const row = rowMap.get(s.id);
        if (row && row._file){
          try {
            const prevPath = row.dataset.photoPath || null;
            const { url, path } = await uploadStepPhoto(row._file, recipeIdForUpload, s.id, prevPath);
            s.photoUrl = url;
            s.photoPath = path;
            // reflect back to the DOM row so subsequent saves keep the info
            row.dataset.photoUrl = url;
            row.dataset.photoPath = path;
            row._file = null; // clear reference
          } catch (e) {
            console.warn('Step photo upload failed for', s.id, e);
            // keep existing s.photoUrl/path as-is if upload fails
          }
        }
      }
    }

    await recipeDocRef.set({
      ingredients,
      steps,
      updatedAt: now,
      updatedBy: who
    }, { merge: true });
  } catch (e) {
    console.error(e);
    alert('Saving ingredients/steps failed: ' + (e.message || e));
  }

  // We’ll reuse this for the cover background tasks
  const recipeId = recipeDocRef.id;





      
      // === Cover file changes (background, non-blocking) ===
  try {
    // Inform the user immediately; we won't await the upload/remove
    

    // Define tasks (but do NOT await here)
    const removeTask = (rmRemoveCover && !rmCoverFile) ? (async () => {
      await db.collection('recipes').doc(household).collection('recipes').doc(recipeId)
        .set({
          coverUrl: null,
          coverPath: null,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
        }, { merge: true });

      if (rmExistingCoverPath) { try { await storage.ref().child(rmExistingCoverPath).delete(); } catch(e){} }
    }) : null;

    const uploadTask = rmCoverFile ? (async () => {
      await uploadRecipeCover(rmCoverFile, recipeId, rmExistingCoverPath || null);
    }) : null;

    // Kick off tasks in a microtask after this click handler finishes,
    // so the modal can close right away.
  Promise.resolve().then(async () => {
    const coverChanged = Boolean(removeTask || uploadTask);
    try {
      if (removeTask) await removeTask();
      if (uploadTask) await uploadTask();
      if (coverChanged) showToast('Cover updated');
    } catch (e) {
      console.warn('Background cover update failed:', e);
      if (coverChanged) showToast('Cover update failed');
    }
  });

  } catch (e) {
    console.warn('Failed to schedule background cover update:', e);
  }


    



      closeRecipeModal();


    } catch (e) {
      console.error(e);
      alert('Save failed: ' + (e.message || e));
    }
  };



  // ==== Add-to-List modal wiring (full) ====
  const addToListModal = $('addToListModal');
  const atlClose       = $('atlClose');
  const atlListEl      = $('atlList');
  const atlServingsEl  = $('atlServings');
  const atlInc         = $('atlInc');
  const atlDec         = $('atlDec');
  const atlPresets     = document.querySelectorAll('.preset-row .preset');
  const atlSelectAll   = $('atlSelectAll');
  const atlAddBtn      = $('atlAdd');
  let atlIngredients = [];

  let atlRecipe = null;          // recipe meta being added
  let atlBasePortions = 2;       // base portions (from recipe)

  let atlServings = 2;           // current servings in the modal

  // --- Qty helpers (preserve units like "g", "kg", "ml", etc.)
  function parseNum(s){
    const n = parseFloat((s||'').toString().trim().replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  }
  function fmtNum(n){
    // Always round up to the nearest whole number
    return Math.ceil(n).toString();
  }
  // Split into numeric part + the exact trailing text (units/spaces kept as typed)
  function parseQtyParts(s){
    if (s == null) return { num: null, tail: '' };
    const str = String(s);
    const m = str.trim().match(/^([+-]?\d+(?:[.,]\d+)?)(.*)$/);
    if (!m) return { num: null, tail: '' };
    const num = parseFloat(m[1].replace(',', '.'));
    return Number.isFinite(num) ? { num, tail: m[2] || '' } : { num: null, tail: m[2] || '' };
  }
  // Scale number and re-attach the original tail (so "150g" -> "300g")
  function scaleQtyStr(qtyStr, factor){
    const { num, tail } = parseQtyParts(qtyStr);
    if (num === null) return qtyStr || '';
    return fmtNum(num * factor) + (tail || '');
  }
  // Add two qty strings, but only combine numbers if the unit-tails match
  // Add/merge two qty strings, consolidating ALL same-unit segments in combos.
  // Examples:
  //   "1 + 150g + 50 g" + "200g" → "1 + 400g"
  //   "2kg + 300 g + note" + "0.2 kg" → "2.2kg + 300 g + note"
  //   "pack + 150g" + "pack" (non-numeric) → "pack + 150g + pack"
  // Add/merge two qty strings, consolidating ALL same-unit segments in combos.
  // Examples:
  //   "1 + 150g + 50 g" + "200g" → "1 + 400g"
  //   "2kg + 300 g + note" + "0.2 kg" → "2.2kg + 300 g + note"
  //   "pack + 150g" + "pack" (non-numeric) → "pack + 150g + pack"
  function addQtyStr(aStr, bStr){
    const A = (aStr || '').trim();
    const B = (bStr || '').trim();

    // Split A into segments if it's a combo, else treat as single
    const Aparts = A ? A.split('+').map(s => s.trim()).filter(Boolean) : [];

    // Buckets
    const nonNumeric = [];                 // keep free text pieces
    const unitOrder = [];                  // preserve first-seen order of units
    const unitMap = Object.create(null);   // unitKey -> { sum:number, displayTail:string }

    // Helpers
    const norm = t => (t || '').trim().toLowerCase();

    // Early rule: if A is explicitly zero, overwrite with B (previous behavior)
    const Afirst = parseQtyParts(A);
    if (A === '0' || (Afirst.num !== null && Afirst.num === 0)){
      return B || '';
    }

    // 1) Consume existing A: group numeric segments by unit; keep other text
    const Asegments = Aparts.length ? Aparts : (A ? [A] : []);
    for (const seg of Asegments){
      const p = parseQtyParts(seg);
      if (p.num === null){
        nonNumeric.push(seg);
        continue;
      }
      const key = norm(p.tail);
      if (!(key in unitMap)){
        unitMap[key] = { sum: 0, displayTail: (p.tail || '') };
        unitOrder.push(key);
      }
      unitMap[key].sum += p.num;
    }

    // 2) Fold in B
    const Pb = parseQtyParts(B);
    if (Pb.num === null){
      if (B) nonNumeric.push(B);     // free text term → append later
    } else {
      const key = norm(Pb.tail);
      if (!(key in unitMap)){
        unitMap[key] = { sum: 0, displayTail: (Pb.tail || '') };
        unitOrder.push(key);
      }
      unitMap[key].sum += Pb.num;
      if (!unitMap[key].displayTail) unitMap[key].displayTail = (Pb.tail || '');
    }

    // If nothing numeric at all, fall back to simple join rules
    const hasNumeric = unitOrder.length > 0;
    if (!hasNumeric && nonNumeric.length){
      if (!A) return B;
      if (!B) return A;
      return (A ? A : '') + (A && B ? ' + ' : '') + (B ? B : '');
    }

    // 3) Rebuild: numeric groups first (preserving unit order), then non-numeric terms
    const numericOut = [];
    for (const key of unitOrder){
      const { sum, displayTail } = unitMap[key];
      if (sum === 0) continue;                  // drop zero totals
      numericOut.push(fmtNum(sum) + (displayTail || ''));
    }

    const out = [...numericOut, ...nonNumeric].join(' + ').trim();
    return out || '';
  }




  // Find existing list item (case-insensitive name match)
  function findExistingItem(nameKey){
    const key = (nameKey||'').trim().toLowerCase();
    return lastSnapshotItems.find(it => (it.name||'').trim().toLowerCase() === key) || null;
  }

  // Build the checklist rows for current servings
  function renderAtlList(){
    if (!atlListEl) return;
    atlListEl.innerHTML = '';

    const factor = Math.max(1, atlServings) / Math.max(1, atlBasePortions);

    for (const ing of atlIngredients){
      const scaledQty = scaleQtyStr(ing.qty || '', factor);
      const existing  = findExistingItem(ing.nameKey || ing.name);
      const haveTxt   = existing && (existing.qty || existing.size) 
        ? (existing.qty || '') 
        : '';

      const row = document.createElement('div');
      row.className = 'checkrow';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = true;

      const label = document.createElement('div');
      const main = document.createElement('div');
      main.innerHTML = '<strong>'+escapeHtml(ing.name)+'</strong>' +
        (ing.size ? ' <span class="muted">• '+escapeHtml(ing.size)+'</span>' : '');
      const sub  = document.createElement('div');
      sub.className = 'muted';
      sub.textContent = 'Qty: ' + (scaledQty || '—');
      if (haveTxt){
        const hint = document.createElement('span');
        hint.className = 'muted';
        hint.textContent = '  (have ' + haveTxt + ' already)';
        sub.appendChild(hint);
      }
      label.append(main, sub);

      row.append(cb, label, document.createElement('div'));
      // store refs on DOM for readback
      row._ing = ing;
      row._cb  = cb;
      row._scaledQty = scaledQty;

      atlListEl.appendChild(row);
    }
  }
  // Read the current ingredient rows from the recipe editor modal
  function readIngredientsFromEditor(){
    const rows = Array.from(document.querySelectorAll('#rmIngredients .ing-row'));
    return rows.map(row=>{
      const name  = (row.querySelector('.ing-name')?.value || '').trim();
      const qty   = (row.querySelector('.ing-qty')?.value || '').trim();
      const size  = (row.querySelector('.ing-size')?.value || '').trim();
      const notes = (row.querySelector('.ing-notes')?.value || '').trim();
      if (!name) return null;
      return {
        name,
        nameKey: name.toLowerCase(),
        qty,
        size,
        notes
      };
    }).filter(Boolean);
  }

  /* ===== Steps editor helpers (titles + drag reorder) ===== */

  // Small helper: generate a simple id
  function uid8(){
    try {
      const a = new Uint8Array(8);
      (self.crypto || window.crypto).getRandomValues(a);
      return Array.from(a, x => x.toString(16).padStart(2,'0')).join('');
    } catch(e) {
      return (Date.now().toString(36) + Math.random().toString(36).slice(2,6)).toLowerCase();
    }
  }

  // Global drag state (kept simple)
  let rmSteps_draggingRow = null;

  // Update "Step N" titles based on visual order
  function rmSteps_renumber(){
    const list = document.getElementById('rmStepsList');
    if (!list) return;
    Array.from(list.children).forEach((row, idx) => {
      const t = row.querySelector('.step-title');
      if (t) t.textContent = `Step ${idx + 1}`;
    });
  }

  // One-time setup of container-level drag handlers (guarded)
  function rmSteps_setupDnd(){
    const list = document.getElementById('rmStepsList');
    if (!list || list.dataset.dndInit === '1') return;

    list.addEventListener('dragover', (e) => {
      if (!rmSteps_draggingRow) return;
      e.preventDefault();
      const after = (() => {
        const rows = [...list.querySelectorAll('.step-row')].filter(r => r !== rmSteps_draggingRow);
        let closest = null;
        let closestOffset = Number.NEGATIVE_INFINITY;
        for (const r of rows){
          const rect = r.getBoundingClientRect();
          const offset = e.clientY - (rect.top + rect.height/2);
          if (offset < 0 && offset > closestOffset){
            closestOffset = offset;
            closest = r;
          }
        }
        return closest;
      })();

      if (after == null){
        list.appendChild(rmSteps_draggingRow);
      } else {
        list.insertBefore(rmSteps_draggingRow, after);
      }
    });

    list.addEventListener('drop', (e) => {
      if (!rmSteps_draggingRow) return;
      e.preventDefault();
      rmSteps_draggingRow.classList.remove('dragging');
      rmSteps_draggingRow = null;
      rmSteps_renumber();
    });

    list.dataset.dndInit = '1';
  }

  // Build one step row (prefills supported)
  function createStepRow(prefill = null) {
    const row = document.createElement('div');
    row.className = 'step-row';
    row.dataset.stepId = prefill?.id || uid8();

    row.innerHTML = `
      <div class="step-grid" style="display:grid; grid-template-rows:auto auto auto auto; gap:10px; align-items:start; margin-bottom:12px; padding:8px; border:1px solid var(--c-border,#444); border-radius:10px; max-width:100%; box-sizing:border-box; min-width:0; overflow-x:hidden;">
        <!-- Title -->
        <div class="step-header" style="display:flex; align-items:center;">
          <div class="step-title" style="font-weight:600;">Step ?</div>
          <div class="step-controls" style="margin-left:auto; display:flex; gap:8px;">
            <button type="button" class="step-up" title="Move up">▲</button>
            <button type="button" class="step-down" title="Move down">▼</button>
            <button type="button" class="step-del" title="Delete">✕</button>
          </div>
        </div>

                 <!-- Toolbar -->
        <div class="step-toolbar" style="display:flex; flex-wrap:wrap; gap:6px;">
          <button type="button" class="step-tool" data-act="task" title="Insert checkbox">Checkbox</button>
          <button type="button" class="step-tool" data-act="bullet" title="Insert bullet">• Bullet</button>
          <button type="button" class="step-tool" data-act="bold" title="Bold">Bold</button>
          <button type="button" class="step-tool" data-act="italic" title="Italic">Italic</button>
        </div>

        <!-- Textarea -->
  <textarea class="step-text" placeholder="Step instructions (Markdown supported with [ ] checkboxes)" rows="7" style="width:100%; resize:vertical; box-sizing:border-box;"></textarea>

        <!-- Timer -->
        <div class="step-timer" style="display:flex; gap:8px; align-items:center; min-width:0;">
          <label>Timer:</label>
          <input class="step-mm" type="number" min="0" max="999" inputmode="numeric" placeholder="mm" style="width:68px;">
          <span>:</span>
          <input class="step-ss" type="number" min="0" max="59"  inputmode="numeric" placeholder="ss" style="width:68px;">
        </div>

        <!-- Photo picker + preview (uses shared openPhotoPicker) -->
        <div class="step-photo" style="display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap; min-width:0;">
          <button type="button" class="step-photo-btn">Add photo</button>
          <img class="step-preview" alt="Step photo" style="max-width:120px; max-height:120px; display:none; border-radius:8px; border:1px solid var(--c-border,#444);" />
        </div>

      </div>
    `;

    // Prefill values
    if (prefill) {
      if (typeof prefill.text === 'string') row.querySelector('.step-text').value = prefill.text;
      const mm = Math.max(0, Math.floor((prefill.timerSec || 0) / 60));
      const ss = Math.max(0, (prefill.timerSec || 0) % 60);
      row.querySelector('.step-mm').value = mm ? String(mm) : '';
      row.querySelector('.step-ss').value = ss ? String(ss) : '';

      // Show existing photo preview if any
      if (prefill.photoUrl) {
        const p = row.querySelector('.step-preview');
        p.src = prefill.photoUrl;
        p.style.display = 'block';
        // Keep known paths on the row so read/save can carry them through
        row.dataset.photoUrl = prefill.photoUrl;
        if (prefill.photoPath) row.dataset.photoPath = prefill.photoPath;
        // Button label reflects existing photo
        const b = row.querySelector('.step-photo-btn');
        if (b) b.textContent = 'Change photo';
      }

    }

   // Delete
row.querySelector('.step-del').onclick = () => {
  row.remove();
  rmSteps_renumber();
  markRecipeDirty();
};

// Reorder (buttons)
row.querySelector('.step-up').onclick = () => {
  const parent = row.parentElement;
  if (parent && row.previousElementSibling) parent.insertBefore(row, row.previousElementSibling);
  rmSteps_renumber();
  markRecipeDirty();
};
row.querySelector('.step-down').onclick = () => {
  const parent = row.parentElement;
  if (parent && row.nextElementSibling) parent.insertBefore(row.nextElementSibling, row);
  rmSteps_renumber();
  markRecipeDirty();
};

// Use shared photo picker popup; preview + remember File for later upload
{
  const photoBtn = row.querySelector('.step-photo-btn');
  const img = row.querySelector('.step-preview');
  if (photoBtn) {
    photoBtn.onclick = () => {
      openPhotoPicker({
        onFile: (file) => {
          if (!file) return;
          const u = URL.createObjectURL(file);
          img.src = u;
          img.style.display = 'block';
          row._file = file; // keep the chosen file on the row for upload step
          // Clear any stale stored path when selecting a new file
          delete row.dataset.photoUrl;
          delete row.dataset.photoPath;
          // Update button label
          photoBtn.textContent = 'Change photo';
          markRecipeDirty();
        }
      });
    };
  }
}

// Step toolbar bindings
{
  const ta = row.querySelector('.step-text');
  const tools = Array.from(row.querySelectorAll('.step-tool'));

  const insert = (before = '', after = '') => {
    if (!ta) return;
    const s = ta.selectionStart ?? ta.value.length;
    const e = ta.selectionEnd ?? s;
    const val = ta.value;
    const sel = val.slice(s, e);
    const next = val.slice(0, s) + before + sel + after + val.slice(e);
    ta.value = next;

    // Caret logic:
    // - If no selection: place caret immediately after the *opening* token (inside the pair)
    // - If there was a selection: place caret after the whole inserted block
    const hadSelection = e > s;
    const pos = hadSelection ? (s + before.length + sel.length + after.length)
                             : (s + before.length);

    ta.focus({ preventScroll: true });
    try { ta.setSelectionRange(pos, pos); } catch(e) {}

    if (typeof markRecipeDirty === 'function') markRecipeDirty();
  };

  const insertLinePrefix = (prefix) => {
    if (!ta) return;
    const s = ta.selectionStart ?? 0;
    const e = ta.selectionEnd ?? 0;
    const val = ta.value;

    const lineStart = val.lastIndexOf('\n', s - 1) + 1;
    const lineEnd   = val.indexOf('\n', e);
    const end = lineEnd === -1 ? val.length : lineEnd;

    const selected = val.slice(lineStart, end);
    const replaced = selected.split('\n').map(l => (l ? prefix + l : prefix)).join('\n');

    const next = val.slice(0, lineStart) + replaced + val.slice(end);
    ta.value = next;

    // Place caret immediately after the *inserted prefix* on the FIRST affected line
    const pos = lineStart + prefix.length;

    ta.focus({ preventScroll: true });
    try { ta.setSelectionRange(pos, pos); } catch(e) {}

    if (typeof markRecipeDirty === 'function') markRecipeDirty();
  };

  tools.forEach(b => {
    b.addEventListener('click', () => {
      const act = b.dataset.act;
      if (act === 'task')   return insertLinePrefix('[ ] ');
      if (act === 'bullet') return insertLinePrefix('• ');
      if (act === 'bold')   return insert('**','**');
      if (act === 'italic') return insert('*','*');
    });
  });
}





    return row;
  }






  

  // Add one step (blank or prefill)
  function addStepRow(prefill=null){
    const list = document.getElementById('rmStepsList');
    if (!list) return;
    rmSteps_setupDnd();
    const row = createStepRow(prefill);
    list.appendChild(row);
    rmSteps_renumber();

    // ---- Auto-assign default photo for NEW steps (no photo yet) ----
    // Tries “step N” with common extensions and base paths. If you provide files,
    // place them (for example) in /assets/steps/ as: Step 1.jpg, Step 2.png, etc.
    // If you want a custom rule, define window.resolveDefaultStepPhoto(n) => URL.
    (function autoAssignDefaultStepPhoto(){
      // Only assign when creating a NEW step or a prefill without a photo
      const hasExisting = !!(row.dataset.photoUrl || row._file);
      const fromPrefillHasPhoto = !!(prefill && prefill.photoUrl);
      if (hasExisting || fromPrefillHasPhoto) return;

      const children = Array.from(list.children);
      const index = children.indexOf(row);
      const n = index >= 0 ? (index + 1) : 0;
      if (!n) return;

      // 1) If user provided a resolver, use it
      if (typeof window.resolveDefaultStepPhoto === 'function') {
        const url = window.resolveDefaultStepPhoto(n);
        if (url && typeof url === 'string') {
          const probe = new Image();
          probe.onload = () => {
            const img = row.querySelector('.step-preview');
            if (img) {
              img.src = url;
              img.style.display = 'block';
            }
            row.dataset.photoUrl = url;
            row.dataset.photoPath = ''; // not from Storage
            const b = row.querySelector('.step-photo-btn');
            if (b) b.textContent = 'Change photo';
            if (typeof markRecipeDirty === 'function') markRecipeDirty();
          };
          probe.src = url;
          return;
        }
      }

      // 2) Fallback: try common locations and extensions
      const bases = ['', './', '/assets/steps/'];
      const names = [`Step ${n}.webp`, `Step ${n}.jpg`, `Step ${n}.jpeg`, `Step ${n}.png`];
      let i = 0;

      const tryNext = () => {
        if (i >= bases.length * names.length) return;
        const base = bases[Math.floor(i / names.length)];
        const file = names[i % names.length];
        i++;

        const url = base + file;
        const probe = new Image();
        probe.onload = () => {
          const img = row.querySelector('.step-preview');
          if (img) {
            img.src = url;
            img.style.display = 'block';
          }
          row.dataset.photoUrl = url;
          row.dataset.photoPath = ''; // not from Storage
          const b = row.querySelector('.step-photo-btn');
          if (b) b.textContent = 'Change photo';
          if (typeof markRecipeDirty === 'function') markRecipeDirty();
        };
        probe.onerror = tryNext;
        probe.src = url;
      };

      tryNext();
    })();
    // ----------------------------------------------------------------

    return row;
  }


  // Read all steps from editor into schema:
  // { id, text, timerSec|null, photoUrl|null, photoPath|null }
  function readStepsFromEditor(){
    const list = document.getElementById('rmStepsList');
    const rows = Array.from(list ? list.children : []);
    const steps = rows.map((row) => {
      const id = row.dataset.stepId || uid8();
      const text = (row.querySelector('.step-text')?.value || '').trim();
      const mm = parseInt(row.querySelector('.step-mm')?.value || '0', 10) || 0;
      const ss = parseInt(row.querySelector('.step-ss')?.value || '0', 10) || 0;
      const total = Math.max(0, (mm * 60) + Math.min(59, ss));
      if (!text) return null;

      // Keep whatever is already known on the row; uploads will update these later
      const photoUrl = row.dataset.photoUrl || null;
      const photoPath = row.dataset.photoPath || null;

      return {
        id,
        text,
        timerSec: total > 0 ? total : null,
        photoUrl,
        photoPath
      };
    }).filter(Boolean);

    return steps;
  }





  /* (removed duplicate) Using the main “Steps editor helpers (titles + drag reorder)” block above.
    This avoids overriding the version that renders the bold “Step N” title and the ≡ drag handle. */


  // Open modal for a recipe
  async function openAddToListModal(recipe){
    // Store recipe & servings info
    atlRecipe = recipe || null;
    atlBasePortions = (recipe && recipe.basePortions) ? Number(recipe.basePortions) : 2;
    atlServings = atlBasePortions;   // Always start at base portions (1×)

    // Build the ingredient list for the ATL modal:
    // 1) Prefer recipe.ingredients if provided,
    // 2) else read the current editor rows (so it still works while editing).
    if (recipe && Array.isArray(recipe.ingredients) && recipe.ingredients.length){
      atlIngredients = recipe.ingredients.map(ing => ({
        name:  (ing.name  || '').trim(),
        nameKey: (ing.name || '').toLowerCase(),
        qty:   (ing.qty   || '').trim(),
        size:  (ing.size  || '').trim(),
        notes: (ing.notes || '').trim()
      })).filter(x => x.name);
    } else {
      atlIngredients = readIngredientsFromEditor();
    }

    // Reset UI
    atlServingsEl.value = atlServings;
    if (atlSelectAll) atlSelectAll.checked = true;

    // Render the checklist based on atlIngredients
    renderAtlList();

    // Show modal
    addToListModal.classList.add('show');
    addToListModal.setAttribute('aria-hidden','false');

    // Focus servings input for quick scaling
    atlServingsEl.focus();
  }


  function closeAddToListModal(){
    addToListModal.classList.remove('show');
    addToListModal.setAttribute('aria-hidden','true');
  }

  // wire close
  if (atlClose) atlClose.onclick = closeAddToListModal;

  // servings +/- buttons
  if (atlInc) atlInc.onclick = () => {
    atlServings = Math.max(1, Number(atlServingsEl.value||atlServings) + 1);
    atlServingsEl.value = atlServings;
    renderAtlList();
  };
  if (atlDec) atlDec.onclick = () => {
    atlServings = Math.max(1, Number(atlServingsEl.value||atlServings) - 1);
    atlServingsEl.value = atlServings;
    renderAtlList();
  };

  // presets (1×, 1.5×, 2× relative to base portions)
  atlPresets.forEach(btn=>{
    btn.onclick = () => {
      const mult = parseFloat(btn.dataset.x);
      if (!Number.isFinite(mult)) return;
      atlServings = Math.max(1, Math.round(atlBasePortions * mult));
      atlServingsEl.value = atlServings;
      renderAtlList();
      // simple visual state
      atlPresets.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
    };
  });

  // keyboard ↑/↓ in servings
  if (atlServingsEl){
    atlServingsEl.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowUp'){ e.preventDefault(); atlInc.click(); }
      if (e.key === 'ArrowDown'){ e.preventDefault(); atlDec.click(); }
    });
    atlServingsEl.addEventListener('change', ()=>{
      const v = parseInt(atlServingsEl.value||atlServings, 10);
      atlServings = Number.isFinite(v) && v>0 ? v : atlServings;
      atlServingsEl.value = atlServings;
      renderAtlList();
    });
  }

  // select/deselect all
  if (atlSelectAll){
    atlSelectAll.onchange = () => {
      document.querySelectorAll('#atlList .checkrow input[type="checkbox"]').forEach(cb=>{
        cb.checked = atlSelectAll.checked;
      });
    };
  }

  // Commit: add selected ingredients (merged) to shopping list
  if (atlAddBtn) atlAddBtn.onclick = async () => {
    if (!auth || !auth.currentUser || !household) { alert('Sign in and set the household first.'); return; }
    try{
      const factor = Math.max(1, atlServings) / Math.max(1, atlBasePortions);

      const rows = Array.from(document.querySelectorAll('#atlList .checkrow'));
      const chosen = rows.filter(r => r._cb && r._cb.checked);

      if (!chosen.length){ showToast('Nothing selected'); return; }

      const batch = db.batch();

      for (const row of chosen){
        const ing = row._ing;
        const scaledQty = scaleQtyStr(ing.qty || '', factor);

        // Find existing list item
        const existing = findExistingItem(ing.nameKey || ing.name);
        if (existing){
          // merge qty
          const newQty = addQtyStr(existing.qty || '', scaledQty);
          const ref = db.collection('lists').doc(household).collection('items').doc(existing.id);
          batch.set(ref, {
            qty: newQty,
            // optionally fill size/notes if empty
            size: existing.size || ing.size || '',
            notes: existing.notes || ing.notes || '',
            checked: false, // force it back onto the Shopping list
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
        } else {
          // new item; pull category/route from catalogCache if available
          const catKnown = catalogCache.get((ing.name||'').toLowerCase()) || {};
          const ref = db.collection('lists').doc(household).collection('items').doc();
          batch.set(ref, {
            name: ing.name,
            qty: scaledQty,
            size: ing.size || '',
            notes: ing.notes || '',
            category: catKnown.category || '',
            routeOrder: (catKnown.routeOrder === 0 || catKnown.routeOrder) ? catKnown.routeOrder : '',
            checked: false,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        }
      }

      // Update recipe lastUsedServings
      if (atlRecipe && atlRecipe.id){
        const rref = db.collection('recipes').doc(household).collection('recipes').doc(atlRecipe.id);
        batch.set(rref, {
          lastUsedServings: atlServings,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: (auth.currentUser.email || auth.currentUser.uid || 'unknown')
        }, { merge: true });
      }

      await batch.commit();
      showToast('Added to shopping list');
      closeAddToListModal();
    } catch(e){
      console.error(e);
      alert('Add failed: ' + (e.message || e));
    }
  };

    </script>

    <script>
      // Subtle haptic on taps
      document.addEventListener('pointerdown', (e) => {
        const btn = e.target.closest('button,[role="button"]');
        if (!btn) return;
        if (btn.dataset && btn.dataset.haptic === 'off') return;
        if (navigator.vibrate) navigator.vibrate(10);
      });
    </script>
    <script>
      // Press animation on rows
      document.addEventListener('pointerdown', (e) => { const row = e.target.closest('.item'); if (row) row.classList.add('is-pressed'); });
      const clearPress = () => { document.querySelectorAll('.item.is-pressed').forEach(r => r.classList.remove('is-pressed')); };
      document.addEventListener('pointerup', clearPress);
      document.addEventListener('pointercancel', clearPress);
    </script>
  <script>
    // Minimal toast helper (smooth + tap-to-dismiss + restartable)
    (function(){
      const t = document.createElement('div');
      t.id = 'toast';
      t.className = 'toast';
      t.setAttribute('role','status');
      t.setAttribute('aria-live','polite');
      document.body.appendChild(t);

      let hideTimer = null;

      window.showToast = function(msg, {timeout = 4000} = {}){
        t.textContent = String(msg || '');
        t.classList.add('show');
        if (hideTimer) clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
          t.classList.remove('show');
          hideTimer = null;
        }, timeout);
      };

      t.addEventListener('click', () => {
        if (hideTimer) clearTimeout(hideTimer);
        t.classList.remove('show');
        hideTimer = null;
      });
    })();
  </script>


    <script>
      // Lightbox
      (function(){
        const lb = document.createElement('div');
        lb.className = 'lightbox';
        lb.innerHTML = '<img alt=""><button class="close" aria-label="Close">×</button>';
        document.body.appendChild(lb);
        const img = lb.querySelector('img');
        const close = () => lb.classList.remove('show');
        lb.addEventListener('click', (e)=>{ if (e.target===lb || e.target.classList.contains('close')) close(); });
        window.openLightbox = (src) => { img.src = src; lb.classList.add('show'); };
      })();
    </script>
    <script>
      // Enter key = Add
      (['itemName','itemQty','itemSize','itemCategory','itemRoute','itemNotes']).forEach(id => {
        const n = document.getElementById(id); if (!n) return;
        n.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.isComposing) { e.preventDefault(); const addBtn = document.getElementById('add'); if (addBtn) addBtn.click(); }
        });
      });
    </script>
  <!-- ==================== Bottom Navigation ==================== -->
  <nav class="bottom-nav" id="bottomNav">
    <!-- Left: Menu -->
    <button id="menuBtn" class="tab" type="button" aria-label="Menu">⋮</button>

    <!-- Middle: Tabs -->
    <button id="tabList" class="tab" type="button">List</button>
    <button id="tabShopping" class="tab" type="button">Shopping</button>
    <button id="tabRecipes" class="tab" type="button">Recipes</button>

    <!-- Right: Filter controls -->
    <button id="filterBtn" class="tab" type="button" aria-label="Filters">⚙️</button>
  </nav>

  <!-- ============ Settings Menu Sheet ============ -->
  <div id="menuSheet" class="menu-sheet" aria-hidden="true">
    <div class="menu-card">
      <h3>Settings</h3>

      <label style="display:block; margin-top:10px;">
        <div>Household</div>
        <input id="household" type="text" placeholder="Household code" style="width:100%; margin-top:4px;">
      </label>
      <button id="setHousehold" style="margin-top:6px;">Set</button>

      <div style="margin-top:12px;">
        <button id="signIn" class="primary">Sign in</button>
        <button id="signOut" style="display:none">Sign out</button>
      </div>

      <div style="margin-top:12px;">
        <button id="themeToggle" type="button">🌙 Dark</button>
      </div>


      <div style="margin-top:20px; text-align:right;">
        <button id="menuClose">Close</button>
      </div>
    </div>
  </div>

  <!-- ============ Filter Sheet ============ -->
  <div id="filterSheet" class="menu-sheet" aria-hidden="true">
    <div class="menu-card">
      <h3>Filters</h3>

      <div style="margin-top:10px;">
        <label>Sort by</label>
        <select id="sortMode">
          <option value="route">Route</option>
          <option value="category">Category</option>
          <option value="name">Name</option>
        </select>
      </div>

    

      <div style="margin-top:12px;">
        <label>Filter</label>
      <select id="filterMode">
    <option value="all">All</option>
    <option value="unchecked">Unchecked</option>
    <option value="checked">Checked</option>
  </select>

      </div>

      <div style="margin-top:20px; text-align:right;">
        <button id="filterClose">Close</button>
      </div>
    </div>
  </div>

  <style>
  /* ====== Shared Menu Sheet (settings + filter) ====== */
  .menu-sheet {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.5);
    display: none;
    align-items: flex-end;
    justify-content: center;
    z-index: 10000;
  }
  .menu-sheet.show { display: flex; }

  .menu-card {
    width: 100%;
    max-width: 480px;
    background: var(--surface);
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
    box-shadow: var(--shadow-md);
    padding: 16px;
    animation: slideUp .2s ease;
  }
  @keyframes slideUp {
    from { transform: translateY(100%); opacity: 0; }
    to   { transform: translateY(0); opacity: 1; }
  }
    /* Make each ingredient row stack on small screens */
  @media (max-width: 560px) {
    .ing-row {
      grid-template-columns: 1fr; /* stack fields vertically */
    }
    /* Optional: tighten inputs a bit on phones */
    .ing-row input { min-height: 40px; }
  }


    /* ==== INGREDIENT ROW: 2×2 grid (no sideways scroll) ==== */
  .ing-row{
    display: grid;                /* JS also sets this; CSS here is the source of truth */
    grid-template-columns: minmax(0,.8fr) minmax(0,1fr);
    grid-template-rows: auto auto;
    grid-template-areas:
      "name rightTop"
      "name rightBottom";
    gap: 8px 10px;
    align-items: center;
    max-width: 100%;
  }
    /* Allow all grid children to actually shrink in their tracks */
  .ing-row > * { min-width: 0; }

  /* Belt-and-suspenders for the name wrapper/input */
  .ing-name-wrap,
  .ing-name-wrap input { min-width: 0; width: 100%; }

  /* Allow everything inside the grid to shrink when needed */
  .ing-row, .ing-row * { min-width: 0; max-width: 100%; }

  /* Explicitly uncap both left and right wrappers */
  .ing-name-wrap,
  .ing-right,
  .ing-rightTop,
  .ing-rightBottom { min-width: 0; }


  .ing-row, .ing-row * {
    min-width: 0;                 /* allow children to shrink inside grid cells */
    max-width: 100%;              /* nothing may exceed the row width */
  }

  /* Left column (spans two rows) */
  .ing-name-wrap{ grid-area: name; }
  /* Allow the name column to actually shrink */
  .ing-name-wrap { min-width: 0; }

  /* Right column, row 1: Qty + Size (wraps nicely on small widths) */
  .ing-right-top{
    grid-area: rightTop;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .ing-right-top > input{
    flex: 1 1 140px;              /* grow/shrink; start around 140px */
    width: 100%;
  }

  /* Right column, row 2: Notes + × aligned right */
  .ing-right-bottom{
    grid-area: rightBottom;
    display: grid;
    grid-template-columns: 1fr auto;   /* notes | delete */
    gap: 8px;
    align-items: center;
  }
  .ing-right-bottom .ing-notes{
    width: 100%;
  }



  /* Let any long text/tokens wrap rather than push layout wider */
  .ing-row .ing-updateTag{
    grid-column: 1 / -1;          /* show below notes+× when visible */
    white-space: normal;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  /* Mobile: single-column stack — Name → Qty/Size → Notes + × */
  @media (max-width:560px){
    .ing-row{
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto;
      grid-template-areas:
        "name"
        "rightTop"
        "rightBottom";
    }

    .ing-right-top{
      gap: 8px;
    }

    .ing-right-top > input{
      flex: 1 1 180px;           /* a bit more space on phones */
    }
  }

  @media (max-width: 560px) {
    .ing-row {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    .ing-row input {
      max-width: 100%;  /* so they wrap instead of overflowing */
    }
  }
  /* Prevent qty inputs from collapsing on short values */
  input.qtyInline{
    min-width: 4ch; /* matches JS floor */
  }
  /* === Tags UI helpers === */
  .tagchip { user-select: none; }
  .tagchip .x {
    margin-left: 6px;
    opacity: .7;
    cursor: pointer;
    font-weight: 700;
  }

  .tag-badge {
    display: inline-block;
    margin-right: 6px;
    padding: 2px 8px;
    border: 1px solid var(--chip-border);
    border-radius: 999px;
    font-size: 11px;
    opacity: .8;
    background: var(--chip);
  }

  /* === Recipe Editor: Ingredient Row (2 rows, fixed % columns) === */
  /* Row 1: [ Name 35% | Qty 32.5% | Size 32.5% ]
    Row 2: [ (empty) | Notes 55% | Delete 10% ] */
  .ing-row {
    display: grid;
    grid-template-columns: 35% 32.5% 32.5%;
    grid-template-rows: auto auto;
    gap: 3px;
    align-items: start;
    width: 100%;
  }

  /* Row 1 mapping */
  .ing-name { grid-column: 1; grid-row: 1; min-width: 0; }
  .ing-qty  { grid-column: 2; grid-row: 1; }
  .ing-size { grid-column: 3; grid-row: 1; }

  /* Row 2 mapping */
  .ing-notes {
    grid-column: 2 / 4;  /* span columns 2 and 3 */
    grid-row: 2;
    min-width: 0;
  }

  .ing-del   { grid-column: 1; grid-row: 2; justify-self: end; }
  /* Make the fields fill their grid columns */
  .ing-name,
  .ing-qty,
  .ing-size,
  .ing-notes {
    width: 100%;
    max-width: none;
    min-width: 0;
    box-sizing: border-box;
  }


  /* Inputs/textarea reset INSIDE the ingredient row */
  .ing-row textarea,
  .ing-row input {
    width: 100%;
    max-width: 100%;
    padding: 8px;
    border: 1px solid var(--chip-border);
    border-radius: 12px;
    font: inherit;
    box-sizing: border-box;
  }

  /* Tall, wrapping fields */
  .ing-name,
  .ing-notes {
    resize: none;
    height: 3.6em;      /* ~2 lines */
    line-height: 1.4;
  }

  /* Delete button appearance */
  .ing-del {
    background: var(--surface);
    border: 1px solid var(--chip-border);
    border-radius: 12px;
    padding: 8px 12px;
    cursor: pointer;
    height: 100%;
    box-sizing: border-box;
  }

  /* Optional: keep tiny mobile screens from forcing horizontal scroll */
  .ing-row > * { min-width: 0; }
  /* --- Pink buttons for the recipe modal --- */
  .btn-pink {
    background: #ff2f7d;           /* solid pink */
    color: #fff;
    border: none;
    border-radius: 10px;
    padding: 10px 14px;
    font-weight: 600;
    transition: transform .08s ease, opacity .2s ease, background-color .2s ease;
  }
  .btn-pink:hover { transform: translateY(-1px); }
  .btn-pink:active { transform: translateY(0); }
  .btn-pink[disabled] {
    opacity: .55;
    pointer-events: none;
  }

  </style>

  <script>
  /* ===== Open/Close Menu Sheet ===== */
  function openSheet(sheet) {
    sheet.classList.add('show');
    sheet.setAttribute('aria-hidden','false');
  }
  function closeSheet(sheet) {
    sheet.classList.remove('show');
    sheet.setAttribute('aria-hidden','true');
  }

  const menuBtn    = document.getElementById('menuBtn');
  const menuSheet  = document.getElementById('menuSheet');
  const menuClose  = document.getElementById('menuClose');

  const filterBtn   = document.getElementById('filterBtn');
  const filterSheet = document.getElementById('filterSheet');
  const filterClose = document.getElementById('filterClose');

  if (menuBtn) menuBtn.onclick = () => openSheet(menuSheet);
  if (menuClose) menuClose.onclick = () => closeSheet(menuSheet);
  if (menuSheet) menuSheet.addEventListener('click', (e)=>{ if(e.target===menuSheet) closeSheet(menuSheet); });

  if (filterBtn) filterBtn.onclick = () => {
    const filterModeSel = document.getElementById('filterMode');
    const filterBlock = filterModeSel && filterModeSel.closest('div');
    if (filterBlock) {
      // Show Filter only on List tab
      filterBlock.style.display = (activeTab === 'list') ? '' : 'none';
    }

    const sortModeSel = document.getElementById('sortMode');
    const sortBlock = sortModeSel && sortModeSel.closest('div');
    if (sortBlock) {
      // Show Sort on List + Shopping, hide on Recipes
      sortBlock.style.display = (activeTab === 'list' || activeTab === 'shopping') ? '' : 'none';
    }

    openSheet(filterSheet);
  };


  if (filterClose) filterClose.onclick = () => closeSheet(filterSheet);
  if (filterSheet) filterSheet.addEventListener('click', (e)=>{ if(e.target===filterSheet) closeSheet(filterSheet); });

  if (menuBtn && menuSheet) {
      menuBtn.onclick = () => {
        menuSheet.classList.add('show');
        menuSheet.setAttribute('aria-hidden','false');
      };
    }
    if (menuClose) {
      menuClose.onclick = () => {
        menuSheet.classList.remove('show');
        menuSheet.setAttribute('aria-hidden','true');
      };
    }
    // Close if clicking backdrop
    if (menuSheet) {
      menuSheet.addEventListener('click', (e)=>{
        if (e.target === menuSheet) {
          menuSheet.classList.remove('show');
          menuSheet.setAttribute('aria-hidden','true');
        }
      });
    }

    // ===== Bottom nav tabs (single source of truth) =====
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#tabList, #tabShopping, #tabRecipes');
    if (!btn) return;

    const idToTab = { tabList: 'list', tabShopping: 'shopping', tabRecipes: 'recipes' };
    const tab = idToTab[btn.id];
    if (!tab) return;

    // Let setActiveTab() handle both the highlight and the view
    if (typeof setActiveTab === 'function') setActiveTab(tab);
  });


    // ===== THEME TOGGLE (moved into menu) =====
    const root = document.documentElement;
    const themeBtn = document.getElementById('themeToggle');

    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
      root.setAttribute('data-theme', 'dark');
      themeBtn.textContent = '☀️ Light';
    } else {
      root.setAttribute('data-theme', 'light');
      themeBtn.textContent = '🌙 Dark';
    }

    themeBtn.onclick = () => {
      const current = root.getAttribute('data-theme');
      if (current === 'dark') {
        root.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
        themeBtn.textContent = '🌙 Dark';
      } else {
        root.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        themeBtn.textContent = '☀️ Light';
      }
    };
  </script>







  <script>
    // Handle clicks for the bottom nav (single listener)
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tabList, #tabShopping, #tabRecipes');
      if (!btn) return;

      const idToTab = { tabList: 'list', tabShopping: 'shopping', tabRecipes: 'recipes' };
      const tab = idToTab[btn.id];
      if (!tab) return;

      // Visual state
      document.querySelectorAll('.bottom-nav .tab').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      // Persist + render using your existing function
      localStorage.setItem('activeTab', tab);
      if (typeof setActiveTab === 'function') setActiveTab(tab);
    });

    // Sync the active highlight on page load
    (function syncBottomNav(){
      const current = localStorage.getItem('activeTab') || 'list';
      const el = {
        list: document.getElementById('tabList'),
        shopping: document.getElementById('tabShopping'),
        recipes: document.getElementById('tabRecipes')
      }[current];
      if (el) el.classList.add('active');
    })();
  </script>


  <script>
  document.addEventListener('DOMContentLoaded', () => {
      // === Bind Sort/Filter now that the Filter Sheet is in the DOM ===
    sortModeEl = document.getElementById('sortMode');
    filterModeEl = document.getElementById('filterMode');

  // === Bind Sort/Filter now that the Filter Sheet is in the DOM ===
  sortModeEl   = document.getElementById('sortMode');
  filterModeEl = document.getElementById('filterMode');

  // Sort
  if (sortModeEl) {
    const savedSort = localStorage.getItem('sortMode');
    if (savedSort) sortModeEl.value = savedSort;
    sortModeEl.onchange = () => {
      localStorage.setItem('sortMode', sortModeEl.value);
      scheduleRenderItems(lastSnapshotItems || []);
    };
  }

  // Filter
  if (filterModeEl) {
    const savedFilter = localStorage.getItem('filterMode');
    if (savedFilter) filterModeEl.value = savedFilter;
    filterModeEl.onchange = () => {
      localStorage.setItem('filterMode', filterModeEl.value);
      // Use the same renderer you use elsewhere
      scheduleRenderItems(lastSnapshotItems || []);
    };
  }


    if (filterModeEl) {
      const savedFilter = localStorage.getItem('filterMode');
      if (savedFilter) filterModeEl.value = savedFilter;

      filterModeEl.onchange = () => {
        localStorage.setItem('filterMode', filterModeEl.value);
        render(lastSnapshotItems || []);
      };
    }

  // Single delegated click handler so duplicates of buttons still work
    document.addEventListener('click', async (e) => {
      // Set household
      if (e.target.closest('#setHousehold')) {
        household = document.getElementById('household').value.trim();
        localStorage.setItem('household', household);
        setHouseholdUI();
        subscribeList();
        subscribeRecipes();
        ensureHouseholdDoc().catch(()=>{});
        updateStatus();
        return;
      }

    // Sign in
  if (e.target.closest('#signIn')) {
    try {
      const email = prompt("Enter email:");
      const password = prompt("Enter password:");
      if (!email || !password) return;
      await auth.signInWithEmailAndPassword(email, password);
  if (typeof closeSheet === 'function') { const ms = document.getElementById('menuSheet'); if (ms) closeSheet(ms); }

      // Always show the generic toast
      showToast("Signed in as " + email);

      // 🔴 Custom toast for Ines
      if (email.toLowerCase() === "ines@ines.com") {
        showToast("Logged in as Schnucki.  Ich liebe dich!!! 💖");
      }

        } catch (e2) {
          if (e2.code === 'auth/user-not-found') {
            alert("No user found. Ask admin to add you in Firebase.");
          } else if (e2.code === 'auth/wrong-password') {
            alert("Wrong password.");
          } else {
            alert("Sign-in failed: " + (e2.message || e2));
          }
        }
        return;
      }

      // Sign out
      if (e.target.closest('#signOut')) {
        try {
          await auth.signOut();
          showToast("Signed out");
        } catch (e3) {
          alert("Sign-out failed: " + (e3.message || e3));
        }
        return;
      }
    });

  }); // <-- correctly close DOMContentLoaded

  const savedTab = localStorage.getItem('activeTab') || 'list';
  if (typeof setActiveTab === 'function') setActiveTab(savedTab);


  try {
    const cachedItems = JSON.parse(localStorage.getItem('cache_items') || '[]');
    if (Array.isArray(cachedItems) && cachedItems.length) {
      lastSnapshotItems = cachedItems;
      render(cachedItems);
    }
  } catch {}
  // If no cache, show skeleton until Firestore snapshot lands
  if (!lastSnapshotItems || !lastSnapshotItems.length) {
    showListSkeleton();
  }

  try {
    const cachedRecipes = JSON.parse(localStorage.getItem('cache_recipes') || '[]');
    if (Array.isArray(cachedRecipes) && cachedRecipes.length) {
      lastSnapshotRecipes = cachedRecipes;
      renderRecipes(cachedRecipes);
    }
  } catch {}
  </script>


  <style>
  /* ——— skeleton styles (lightweight) ——— */
  .item.skeleton { pointer-events:none; opacity:.85; }
  .item.skeleton .sk-line,
  .item.skeleton .sk-box,
  .item.skeleton .sk-chip,
  .item.skeleton .sk-btn {
    background: linear-gradient(90deg,
      color-mix(in oklab, var(--chip) 92%, transparent) 25%,
      color-mix(in oklab, var(--chip) 80%, transparent) 37%,
      color-mix(in oklab, var(--chip) 92%, transparent) 63%
    );
    background-size: 400% 100%;
    animation: sk-shimmer 1.2s ease-in-out infinite;
    border-radius: 8px;
  }
  @keyframes sk-shimmer {
    0% { background-position: 100% 0; }
    100% { background-position: 0 0; }
  }
  </style>
  <style>
  /* ——— layout stabilizers ——— */
  .item { min-height: 70px; }                   /* row won’t collapse during first paint */
  .line1 { min-height: 22px; display:block; }   /* title line steady */
  .thumb { width:44px; height:44px; }           /* avoid reflow when images load */
  .qty-inline { min-height: 32px; }             /* consistent control height */
  </style>
  <script>
  // ===================== List Show/Hide toggle (with persistence) =====================
  (function(){
    // Elements
    var listSection = document.getElementById('listSection');
    var toggleBtn   = document.getElementById('toggleListItemsButton');

    // Safety: if the button isn't present yet, do nothing
    if (!listSection || !toggleBtn) return;

    // LocalStorage key
    var LS_KEY = 'listCollapsed'; // "true" or "false" as strings

    // Helper: apply a given collapsed boolean to DOM + button label
    function applyCollapsed(collapsed){
      // 1) Attribute on section (drives CSS hide rule)
      if (collapsed) {
        listSection.setAttribute('data-list-collapsed', 'true');
      } else {
        listSection.removeAttribute('data-list-collapsed');
      }

      // 2) Button label + aria state
      if (collapsed) {
        toggleBtn.textContent = '🔽 Show items';
        toggleBtn.setAttribute('aria-pressed', 'false');
      } else {
        toggleBtn.textContent = '🔼 Hide items';
        toggleBtn.setAttribute('aria-pressed', 'true');
      }
    }

    // Read saved preference
    var saved = localStorage.getItem(LS_KEY);

    // Starting state logic:
    // - If saved is "true" or "false", use it.
    // - If nothing saved, default to collapsed (hidden).
    var startCollapsed;
    if (saved === 'true') {
      startCollapsed = true;
    } else if (saved === 'false') {
      startCollapsed = false;
    } else {
      startCollapsed = true; // default hidden
    }

    // Apply starting state (this also corrects the button text)
    applyCollapsed(startCollapsed);

    // Click to toggle
    toggleBtn.addEventListener('click', function(){
      var currentlyCollapsed = listSection.hasAttribute('data-list-collapsed');
      var nextCollapsed = !currentlyCollapsed;

      applyCollapsed(nextCollapsed);
      localStorage.setItem(LS_KEY, String(nextCollapsed));
    });
  })();
  </script>

  </script>

  <script id="markdown-sanitize">
  /*
    Minimal Markdown → Safe HTML utilities:
    - Supported: **bold**, *italic*, `code`, [text](url), hard line breaks
    - Task markers `[ ]` and `[x]` are preserved as plain text for step 4
    - Sanitizer allow-list blocks scripts, event handlers, javascript: URLs, etc.
    - Usage: const html = window.renderMarkdownSafe(stepText);
  */
  (function(){
    // Basic HTML escape
    function escapeHtml(str){
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    // Very small Markdown subset → HTML (no HTML passthrough)
    function mdToHtml(md){
      if (!md) return "";
      // Work on an escaped base to avoid raw HTML injection
      let s = escapeHtml(md);

      // Inline code: `code`
      s = s.replace(/`([^`]+)`/g, "<code>$1</code>");

      // Bold: **text**
      s = s.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");

      // Italic: *text* (simple form; avoids overlap with **bold**)
      s = s.replace(/(^|[^\*])\*([^*\n]+)\*(?!\*)/g, "$1<em>$2</em>");

      // Links: [text](url)  — allow only http(s) protocols
      s = s.replace(/\[([^\]]+)\]\(([^)\s]+)\)/g, function(_, text, href){
        try {
          const u = new URL(href, location.href);
          const safe = (u.protocol === "http:" || u.protocol === "https:");
          return safe ? '<a href="' + escapeHtml(u.href) + '" rel="noopener noreferrer" target="_blank">' + escapeHtml(text) + '</a>'
                      : escapeHtml("[" + text + "](" + href + ")");
        } catch(e){
          return escapeHtml("[" + text + "](" + href + ")");
        }
      });

      // Preserve single newlines as <br> and double newlines as paragraph breaks
      // Split into paragraphs by two or more newlines
      const parts = s.split(/\n{2,}/).map(p => p.replace(/\n/g, "<br>"));
      return parts.map(p => "<p>" + p + "</p>").join("");
    }

    // Strict sanitizer for the HTML we produce
    function sanitizeHtml(html){
      // Create a detached DOM to sanitize
      const tpl = document.createElement("template");
      tpl.innerHTML = html;

      const ALLOWED_TAGS = new Set(["P","BR","STRONG","EM","CODE","A"]);
      const ALLOWED_ATTR = {
        "A": new Set(["href","rel","target"])
      };

      function isSafeUrl(url){
        try {
          const u = new URL(url, location.href);
          return (u.protocol === "http:" || u.protocol === "https:");
        } catch(e){
          return false;
        }
      }

      (function walk(node){
        // Remove disallowed elements
        if (node.nodeType === 1) {
          const tag = node.tagName;
          if (!ALLOWED_TAGS.has(tag)) {
            // Replace unknown element with its textContent
            const txt = document.createTextNode(node.textContent || "");
            node.replaceWith(txt);
            return;
          }

          // Strip all attributes not on the allow-list, and strip event handlers
          for (const attr of Array.from(node.attributes)) {
            const name = attr.name.toLowerCase();
            const allowed = ALLOWED_ATTR[tag] && ALLOWED_ATTR[tag].has(attr.name);
            const isEvent = name.startsWith("on");
            if (isEvent) {
              node.removeAttribute(attr.name);
              continue;
            }
            if (!allowed) {
              node.removeAttribute(attr.name);
              continue;
            }
            // For <a>, validate href protocol; otherwise drop
            if (tag === "A" && name === "href" && !isSafeUrl(attr.value)) {
              node.removeAttribute(attr.name);
            }
          }
        }

        // Recurse
        for (const child of Array.from(node.childNodes)) {
          walk(child);
        }
      })(tpl.content);

      return tpl.innerHTML;
    }

    function renderMarkdownSafe(mdText){
      const raw = mdToHtml(mdText || "");
      const safe = sanitizeHtml(raw);

      // Convert [ ] and [x] into checkboxes (unchecked/checked)
      // This must run AFTER sanitization
      return safe
        .replace(/\[ \]/g, '<input type="checkbox" class="md-task" />')
        .replace(/\[x\]/gi, '<input type="checkbox" class="md-task" checked />');
    }

    // Expose for app use
    window.sanitizeHtml = sanitizeHtml;
    window.renderMarkdownSafe = renderMarkdownSafe;
  })();
  </script>

  </script>

  <script id="cook-session-state">
  /*
    Cook Session state for task checkboxes (+ 12h session expiry).
    - Persists in localStorage under "cookSession.v1"
    - Cross-tab sync via BroadcastChannel "cookSession"
    - Backward compatible with prior shape: value could be a plain map OR { map, lastUsedAt }.
    - Usage:
        const html = renderMarkdownSafe(text);
        container.innerHTML = html;
        cookSession.attachTaskCheckboxBinding(container, "recipe:<recipeId>:step:<stepId>");
  */
  (function(){
    const LS_KEY = "cookSession.v1";
    const CH_NAME = "cookSession";
    const SESSION_TTL_MS = 12 * 60 * 60 * 1000; // 12 hours
    const bc = ("BroadcastChannel" in self) ? new BroadcastChannel(CH_NAME) : null;

    function now(){ return Date.now(); }

    function readStore(){
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
      catch(e){ return {}; }
    }
    function writeStore(store){
      localStorage.setItem(LS_KEY, JSON.stringify(store));
      if (bc) bc.postMessage({ type:"storeUpdated" });
    }

    // Normalize an entry for a given context key.
    // Returns { map:Object<string,bool>, lastUsedAt:number|null }
    function readEntry(contextKey){
      const s = readStore();
      const v = s[contextKey];
      if (!v) return { map: {}, lastUsedAt: null };
      if (v && typeof v === 'object' && v.map && (typeof v.map === 'object')) {
        return { map: v.map || {}, lastUsedAt: Number(v.lastUsedAt || 0) || null };
      }
      // legacy shape: plain map of indices -> boolean
      return { map: (typeof v === 'object' ? v : {}), lastUsedAt: null };
    }

    function isExpired(entry){
      if (!entry) return false;
      if (!entry.lastUsedAt) return false; // legacy entries without timestamp are treated as active until first touch
      return (now() - entry.lastUsedAt) > SESSION_TTL_MS;
    }

    // Public-style helpers that keep backward compatibility
    function getContext(contextKey){
      const entry = readEntry(contextKey);
      // If expired, return empty — attach() will refresh/store & notify.
      return isExpired(entry) ? {} : entry.map;
    }

    function setContext(contextKey, map){
      const s = readStore();
      s[contextKey] = { map: map || {}, lastUsedAt: now() };
      writeStore(s);
    }

    function clearContext(contextKey){
      const s = readStore();
      if (s.hasOwnProperty(contextKey)) {
        delete s[contextKey];
        writeStore(s);
      }
    }

    // Ensure a fresh session for this context key.
    // If expired, clears and writes an empty fresh entry, and returns true (meaning it reset).
    function ensureFresh(contextKey){
      const s = readStore();
      const entry = readEntry(contextKey);
      if (isExpired(entry)) {
        s[contextKey] = { map: {}, lastUsedAt: now() };
        writeStore(s);
        // Friendly one-line notice if the host app has a toast function
        try { if (typeof window.showToast === 'function') window.showToast('Started a fresh cooking session — checkmarks reset.'); } catch {}
        return true;
      }
      // Touch the timestamp so an actively-open session doesn’t expire mid-cook
      s[contextKey] = { map: entry.map || {}, lastUsedAt: now() };
      writeStore(s);
      return false;
    }

    // Attach behavior to a container that already has .md-task inputs
    function attachTaskCheckboxBinding(containerEl, contextKey){
      if (!containerEl || !contextKey) return;

      // Auto-expire/refresh if needed (also updates lastUsedAt)
      ensureFresh(contextKey);

      const inputs = Array.from(containerEl.querySelectorAll('input.md-task'));
      const saved = getContext(contextKey);

      // Index each checkbox (stable order in current render)
      inputs.forEach((inp, idx) => {
        if (!inp.dataset.taskIndex) inp.dataset.taskIndex = String(idx);
        const i = inp.dataset.taskIndex;
        if (Object.prototype.hasOwnProperty.call(saved, i)) {
          inp.checked = !!saved[i];
        }
      });

      // Change handler (delegated per container)
      const onChange = (ev) => {
        const t = ev.target;
        if (!(t instanceof HTMLInputElement)) return;
        if (!t.classList.contains('md-task')) return;
        const i = t.dataset.taskIndex || "0";
        const map = getContext(contextKey);
        map[i] = !!t.checked;
        setContext(contextKey, map); // updates lastUsedAt on every interaction
      };

      // Avoid duplicate listeners
      detach(containerEl);
      containerEl.addEventListener('change', onChange);
      containerEl._cookTaskHandler = onChange;

      // Return a cleanup function for callers (e.g., when closing Cook Mode)
      return () => detach(containerEl);
    }

    function detach(containerEl){
      if (containerEl && containerEl._cookTaskHandler) {
        containerEl.removeEventListener('change', containerEl._cookTaskHandler);
        delete containerEl._cookTaskHandler;
      }
    }

    // Optional: react to cross-tab updates (no-op unless a view wants to re-apply)
    if (bc) {
      bc.onmessage = (e) => {
        // Views can re-apply saved states if necessary.
        // Cook Mode rebinds on slide show; nothing needed here.
      };
    }

    // Expose API
    window.cookSession = {
      attachTaskCheckboxBinding,
      clearContext
    };
  })();
  </script>


  <!-- ==================== Cook Mode Modal (full-screen) ==================== -->
  <style id="cook-mode-styles">
    #cookModeModal { position: fixed; inset: 0; display: none; z-index: 100002; }
    #cookModeOverlay { position:absolute; inset:0; background:rgba(0,0,0,.6); }
    #cookModeSheet {
      position:absolute; inset:0;
      background: var(--cook-bg, #0b0b0b);
      color: var(--cook-fg, #f0f0f0);
      display:flex; flex-direction:column;
    }
    #cookModeHeader {
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.2); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    #cookModeTitle { font-weight:600; font-size:16px; opacity:.9; }
    #cookModeClose { border:1px solid rgba(255,255,255,.2); background:#111; color:#eee; border-radius:10px; padding:8px 10px; }
    #cookModeBody { flex:1; overflow:auto; -webkit-overflow-scrolling:touch; }
    .cookStepPage { display:flex; flex-direction:column; gap:12px; padding:14px; min-height:100%; }
    .cookPhoto { width:100%; max-height:40vh; object-fit:cover; border-radius:12px; border:1px solid rgba(255,255,255,.08); background:#111; }

    /* Timer card */
    #cookTimerCard {
      border:1px solid rgba(255,255,255,.15); background:#101010; border-radius:12px; padding:10px 12px;
      display:flex; flex-direction:column; gap:8px;
    }
    #cookTimerTop { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    #cookTimerLabel { font-weight:600; }
    #cookTimerMeta { font-size:12px; opacity:.85; }
    #cookTimerProgress { height:6px; background:#161616; border-radius:6px; overflow:hidden; border:1px solid rgba(255,255,255,.1); }
    #cookTimerProgress > div { height:100%; width:0%; background:#3a86ff; }
    #cookTimerRow { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .cookBtn {
      border:1px solid rgba(255,255,255,.2); background:#121212; color:#eee;
      padding:10px 14px; border-radius:12px;
    }
    .tbtn { border:1px solid rgba(255,255,255,.25); background:#151515; color:#eee; border-radius:10px; padding:6px 10px; font-size:13px; }

    .cookMeta { display:flex; align-items:center; justify-content:space-between; font-size:14px; opacity:.9; }
    .cookNav { display:flex; gap:8px; }
    #cookStepBody { font-size:16px; line-height:1.5; }
    #cookStepBody p { margin: 0 0 10px; }
    #cookStepBody code { padding:0 4px; border-radius:6px; background:#111; border:1px solid rgba(255,255,255,.15); }
    #cookStepBody a { color:#8ab4ff; text-decoration:underline; }
    #cookSwipeRegion { position:absolute; inset:0; pointer-events:none; }
  </style>

  <div id="cookModeModal" aria-hidden="true">
    <div id="cookModeOverlay"></div>
    <div id="cookModeSheet" role="dialog" aria-modal="true" aria-label="Cook Mode">
      <div id="cookModeHeader">
    <div id="cookModeTitle">Cook Mode</div>
    <div class="cookNav">
      <button id="cookModeClose" type="button">Close</button>
    </div>
  </div>


      <div id="cookModeBody">
        <div class="cookStepPage">
          <img id="cookStepPhoto" class="cookPhoto" alt="" />

          <!-- Timer controls (per-step) -->
          <div id="cookTimerCard">
            <div id="cookTimerTop">
              <div id="cookTimerLabel">Timer</div>
              <div id="cookTimerMeta">--:--</div>
            </div>
            <div id="cookTimerProgress"><div></div></div>
            <div id="cookTimerRow">
    <button id="cookTimerStart" class="tbtn" type="button">Start</button>
    <button id="cookTimerPause" class="tbtn" type="button" style="display:none;">Pause</button>
    <button id="cookTimerResume" class="tbtn" type="button" style="display:none;">Resume</button>
    <button id="cookTimerReset" class="tbtn" type="button" style="display:none;">Reset</button>

    <div class="tbtn" id="cookM10s" role="button">–10s</div>
    <div class="tbtn" id="cookM1" role="button">–1m</div>

    <div class="tbtn" id="cookS1" role="button">+1m</div>
    <div class="tbtn" id="cookS3" role="button">+3m</div>
    <div class="tbtn" id="cookS5" role="button">+5m</div>
    <div class="tbtn" id="cookS10" role="button">+10m</div>
    <button id="cookTimerStop" class="tbtn" type="button" style="margin-left:auto;">Stop</button>
  </div>

          </div>

          <div class="cookMeta"><div id="cookStepCount">Step –</div></div>
          <div id="cookStepBody"></div>
        </div>
        <div id="cookSwipeRegion"></div>
      </div>
    </div>
  </div>

  <script id="cook-mode-module">
  /*
    Cook Mode with per-step Timer controls
    - window.cookMode.open(recipe, startIndex=0)
    - Integrates with global window.timers store
    - NOTE: Scope all queries to the *last* Cook Mode modal in the DOM to avoid duplicate-ID conflicts.
  */
  (function(){
    // --- Singleton guard: avoid binding Cook Mode twice when duplicate blocks exist.
    if (window.__cookModeSingletonLoaded) { return; }
    window.__cookModeSingletonLoaded = true;

    // Always target the *last* Cook Mode modal (the one with timers/text/photo wired up)
    const modals = document.querySelectorAll('#cookModeModal');
    const modal  = modals[modals.length - 1];

    // Scope all element lookups *within* that modal
    const overlay   = modal.querySelector('#cookModeOverlay');
    const sheet     = modal.querySelector('#cookModeSheet');
    const btnClose  = modal.querySelector('#cookModeClose');
    const elCount   = modal.querySelector('#cookStepCount');
    const elBody    = modal.querySelector('#cookStepBody');
    const elPhoto   = modal.querySelector('#cookStepPhoto');
    // Listen for touch on the scrollable body instead of the overlay (which is non-blocking)
    const swipeRegion = modal.querySelector('#cookModeBody');



  // Timer UI refs (scoped to the selected modal)
  const tLabel  = modal.querySelector('#cookTimerLabel');
  const tMeta   = modal.querySelector('#cookTimerMeta');
  const tProg   = modal.querySelector('#cookTimerProgress > div');
  const btnStart  = modal.querySelector('#cookTimerStart');
  const btnPause  = modal.querySelector('#cookTimerPause');
  const btnResume = modal.querySelector('#cookTimerResume');
  const btnReset  = modal.querySelector('#cookTimerReset');
  const btnStop   = modal.querySelector('#cookTimerStop');
  const btnM10s   = modal.querySelector('#cookM10s');
  const btnM1     = modal.querySelector('#cookM1');
  const btnS1     = modal.querySelector('#cookS1');
  const btnS3     = modal.querySelector('#cookS3');
  const btnS5     = modal.querySelector('#cookS5');
  const btnS10    = modal.querySelector('#cookS10');



    let state = {
      recipe: null,
      index: 0,
      cleanupTasksBinding: null,
      listenersBound: false,
      touch: { startX:0, startY:0, active:false },
      unsubTimers: null
    };

    // Helpers
    function fmt(ms){
      ms = Math.max(0, ms|0);
      const s = Math.floor(ms/1000);
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      return (hh>0? (String(hh).padStart(2,'0')+':'):'') + String(mm).padStart(2,'0')+':'+String(ss).padStart(2,'0');
    }
    function now(){ return Date.now(); }
    function remainingFor(t){
      if (!t) return 0;
      if (t.isPaused) return Math.max(0, t.remainingMs|0);
      if (t.endsAt == null) return 0;
      return Math.max(0, t.endsAt - now());
    }
    function progressFor(t){
      if (!t) return 0;
      const total = t.durationMs || (t.remainingMs||0);
      if (!total) return 0;
      const rem = remainingFor(t);
      const done = total - rem;
      return Math.max(0, Math.min(1, done/total));
    }
    function findTimerForStep(recipeId, stepId, stepIndex){
      if (!window.timers || typeof window.timers.list !== 'function') return null;
      const arr = window.timers.list();
      return arr.find(t => t.context
        && String(t.context.recipeId||'') === String(recipeId||'')
        && String(t.context.stepId||'') === String(stepId||'')
        && Number(t.context.stepIndex||0) === Number(stepIndex||0)
      ) || null;
    }

    function open(recipe, startIndex=0){
      if (!recipe) return;

      // Allow recipes with no steps; treat as empty array
      const stepsArr = Array.isArray(recipe.steps) ? recipe.steps : [];

      // Shallow-clone to avoid mutating the caller; ensure steps is always an array
      state.recipe = Object.assign({}, recipe, { steps: stepsArr });

      // Clamp index; if no steps, index will be 0 and UI will show "No steps"
      state.index = Math.max(0, Math.min(startIndex|0, stepsArr.length ? (stepsArr.length - 1) : 0));

        render();
      show();
      if (window.timers && typeof window.timers.unlockAudio === 'function') {
        window.timers.unlockAudio();
      }


      if (!state.listenersBound) {
        bindListeners();
        state.listenersBound = true;
      }

      // Subscribe to global timers for structural changes (pause/resume/stop/snooze)
      if (window.timers && typeof window.timers.subscribe === 'function') {
        if (state.unsubTimers) state.unsubTimers();
        state.unsubTimers = window.timers.subscribe(() => updateTimerUI());
      }

      // Lightweight UI tick so the countdown/progress animates between store writes
      if (!window.__cookUITick){
        let last = 0, raf = 0;
        const loop = (ts) => {
          if (!modal || modal.style.display !== 'block') { window.__cookUITick = null; cancelAnimationFrame(raf); return; }
          if (!last || (ts - last) >= 200) { // ~5 fps
            updateTimerUI();
            last = ts;
          }
          raf = requestAnimationFrame(loop);
        };
        window.__cookUITick = true;
        raf = requestAnimationFrame(loop);
      }
    }


    

    function show(){
      modal.style.display = 'block';
      sheet.focus?.();
      document.documentElement.style.overflow = 'hidden';
    }

    function hide(){
      modal.style.display = 'none';
      document.documentElement.style.overflow = '';
    }

    function close(){
      if (typeof state.cleanupTasksBinding === 'function') {
        state.cleanupTasksBinding();
        state.cleanupTasksBinding = null;
      }
      if (state.unsubTimers) { state.unsubTimers(); state.unsubTimers = null; }
      // stop local UI tick (it self-stops on next frame when modal hidden, but be explicit)
      try { if (window.__cookUITick) { window.__cookUITick = null; } } catch {}
      unbindListeners();
      state.listenersBound = false;
      state.recipe = null;
      state.index = 0;
      hide();
    }


    function next(){
      if (!state.recipe) return;
      if (state.index < state.recipe.steps.length - 1) setIndex(state.index + 1);
    }

    function prev(){
      if (!state.recipe) return;
      if (state.index > 0) setIndex(state.index - 1);
    }

    function setIndex(i){
      if (typeof state.cleanupTasksBinding === 'function') {
        state.cleanupTasksBinding();
        state.cleanupTasksBinding = null;
      }
      state.index = i;
      render();
      updateTimerUI();
    }

    function render(){
      const steps = state.recipe.steps || [];
      const step = steps[state.index] || { text:"", photoUrl:null };
      const total = steps.length;
      const n = state.index + 1;

      // Photo
      if (step.photoUrl) {
        elPhoto.src = step.photoUrl;
        elPhoto.style.display = '';
        elPhoto.alt = state.recipe.name ? `${state.recipe.name} – Step ${n}` : `Step ${n}`;
      } else {
        elPhoto.removeAttribute('src');
        elPhoto.style.display = 'none';
        elPhoto.alt = '';
      }

      // Count
      elCount.textContent = (total > 0) ? `Step ${n} of ${total}` : 'No steps';

      // Body (Markdown → safe HTML with clickable checkboxes)
      elBody.innerHTML = (window.renderMarkdownSafe ? window.renderMarkdownSafe(step.text || '') : (step.text || ''));
      const recipeId = state.recipe.id || 'temp';
      const stepId = step.id || String(state.index);
      const contextKey = `recipe:${recipeId}:step:${stepId}`;
      if (window.cookSession && typeof window.cookSession.attachTaskCheckboxBinding === 'function') {
        state.cleanupTasksBinding = window.cookSession.attachTaskCheckboxBinding(elBody, contextKey);
      }

      // Timer label default
      tLabel.textContent = step.timerSec ? `Timer • ${Math.floor(step.timerSec/60)}m ${step.timerSec%60}s` : 'Timer';
      updateTimerUI();
    }

    // ----- Timer UI + actions -----
    function currentStepContext(){
      const steps = state.recipe.steps || [];
      const step = steps[state.index] || {};
      return {
        recipeId: state.recipe.id || 'temp',
        stepId: step.id || String(state.index),
        stepIndex: state.index,
        // Optional hook for drawer "Open Step"
        goTo: () => { window.cookMode && window.cookMode.setIndex && window.cookMode.setIndex(state.index); }
      };
    }

      function updateTimerUI(){
      const steps = state.recipe?.steps || [];
      const step = steps[state.index] || {};
      const ctx = currentStepContext();
      const timer = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);

      if (!timer) {
        // No active timer: show Start (uses step.timerSec if present; else 1m default)
        btnStart.style.display = '';
        btnPause.style.display = 'none';
        btnResume.style.display = 'none';
        btnReset.style.display = 'none';
        if (btnStop) {
          btnStop.textContent = 'Stop';
          if (btnStop.classList) btnStop.classList.remove('btn-pink');
        }
        tMeta.textContent = step.timerSec ? fmt(step.timerSec * 1000) : '--:--';
        tProg.style.width = '0%';
        return;
      }

      const rem = remainingFor(timer);
      const p = Math.round(progressFor(timer) * 100);
      const isDone = !!timer.isDone;

      tMeta.textContent = (timer.isPaused ? 'Paused · ' : '') + fmt(rem);
      tProg.style.width = p + '%';

      // Toggle controls
      btnStart.style.display = 'none';
      btnPause.style.display = timer.isPaused || isDone ? 'none' : '';
      btnResume.style.display = timer.isPaused && !isDone ? '' : 'none';
      btnReset.style.display = isDone ? 'none' : ''; // hide Reset if done (we're offering Silence & Reset on Stop)

        // Change Stop button label when finished (swap style to match other pink buttons)
      if (btnStop) {
        if (isDone) {
          btnStop.textContent = 'Silence & Reset';
          btnStop.className = 'btn-pink';
        } else {
          btnStop.textContent = 'Stop';
          btnStop.className = 'tbtn';
        }
      }

    }



    function createStepTimer(){
      const steps = state.recipe.steps || [];
      const step = steps[state.index] || {};
      const ctx = currentStepContext();
      const label = (state.recipe.name ? state.recipe.name + ' – ' : '') + `Step ${state.index+1}`;
      const durationMs = (Number.isFinite(step.timerSec) ? step.timerSec*1000 : 60_000);
      // Include recipe snapshot for optional “Open Step” from the drawer
      const context = { ...ctx, recipe: { id: state.recipe.id, name: state.recipe.name, steps: state.recipe.steps } };
      const id = window.timers.create({ label, durationMs, context });
      return id;
    }

    function resetStepTimer(){
      const steps = state.recipe.steps || [];
      const step = steps[state.index] || {};
      const ctx = currentStepContext();
      const timer = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
      if (timer) window.timers.stop(timer.id);
      createStepTimer();
    }

    // Bind timer buttons
  btnStart.addEventListener('click', () => {   if (window.timers && window.timers.unlockAudio) window.timers.unlockAudio();   createStepTimer();   updateTimerUI(); });

  btnPause.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t) window.timers.pause(t.id);
  });

  btnResume.addEventListener('click', () => {
    if (window.timers && window.timers.unlockAudio) window.timers.unlockAudio();
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t) window.timers.resume(t.id);
  });


  btnReset.addEventListener('click', () => {
    if (window.timers && window.timers.unlockAudio) window.timers.unlockAudio();
    resetStepTimer();
  });

  btnStop.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (!t) { updateTimerUI(); return; }

    // Always just stop the timer — when done this serves as "Silence & Reset"
    window.timers.stop(t.id);

    updateTimerUI();
  });




  // –10s / –1m
  if (btnM10s) btnM10s.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t && window.timers.adjust) window.timers.adjust(t.id, -10*1000);
  });
  if (btnM1) btnM1.addEventListener('click', () => {
    const ctx = currentStepContext();
    const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex);
    if (t && window.timers.adjust) window.timers.adjust(t.id, -60*1000);
  });

  // +N minutes
  btnS1.addEventListener('click', () => {
    const ctx = currentStepContext(); const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex); if (t) window.timers.snooze(t.id,1);
  });
  btnS3.addEventListener('click', () => {
    const ctx = currentStepContext(); const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex); if (t) window.timers.snooze(t.id,3);
  });
  btnS5.addEventListener('click', () => {
    const ctx = currentStepContext(); const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex); if (t) window.timers.snooze(t.id,5);
  });
  btnS10.addEventListener('click', () => {
    const ctx = currentStepContext(); const t = findTimerForStep(ctx.recipeId, ctx.stepId, ctx.stepIndex); if (t) window.timers.snooze(t.id,10);
  });


    // Navigation + swipe
    function bindListeners(){
    btnClose.addEventListener('click', close);
    overlay.addEventListener('click', close);
    document.addEventListener('keydown', onKey);

    swipeRegion.addEventListener('touchstart', onTouchStart, { passive:true });
    swipeRegion.addEventListener('touchmove', onTouchMove, { passive:true });
    swipeRegion.addEventListener('touchend', onTouchEnd);
  }
  function unbindListeners(){
    btnClose.removeEventListener('click', close);
    overlay.removeEventListener('click', close);
    document.removeEventListener('keydown', onKey);
    swipeRegion.removeEventListener('touchstart', onTouchStart);
    swipeRegion.removeEventListener('touchmove', onTouchMove);
    swipeRegion.removeEventListener('touchend', onTouchEnd);
  }

    function onKey(e){
      if (modal.style.display !== 'block') return;
      if (e.key === 'ArrowRight') next();
      else if (e.key === 'ArrowLeft') prev();
      else if (e.key === 'Escape') close();
    }
    function onTouchStart(ev){
      const t = ev.changedTouches && ev.changedTouches[0];
      if (!t) return;
      state.touch.active = true;
      state.touch.startX = t.clientX;
      state.touch.startY = t.clientY;
    }
    function onTouchMove(ev){}
    function onTouchEnd(ev){
      if (!state.touch.active) return;
      const t = ev.changedTouches && ev.changedTouches[0];
      state.touch.active = false;
      if (!t) return;
      const dx = t.clientX - state.touch.startX;
      const dy = t.clientY - state.touch.startY;
      if (Math.abs(dx) > 50 && Math.abs(dx) > Math.abs(dy)) { if (dx < 0) next(); else prev(); }
    }

    // Public API
    window.cookMode = { open, close, next, prev, setIndex };
  })();
  </script>


  <!-- ==================== Timers: Chip + Drawer ==================== -->
  <style id="timer-ui-styles">
  
  #timerChip {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100000;
  }
      background:#121212; color:#eee; border:1px solid rgba(255,255,255,.2);
      border-radius: 999px; padding:8px 12px; display:flex; align-items:center; gap:8px;
      box-shadow: 0 4px 18px rgba(0,0,0,.4);
    }
    #timerChip[hidden]{ display:none; }
    #timerChip .dot {
      width:10px; height:10px; border-radius:50%; background:#3ddc97; border:1px solid rgba(255,255,255,.2);
    }
    #timerChipCount { font-weight:600; }

    #timerDrawer { position: fixed; inset:auto 0 0 0; z-index: 100000; display:none; }
    #timerDrawer[open]{ display:block; }
    #timerDrawerOverlay { position:fixed; inset:0; background:rgba(0,0,0,5); }
    #timerDrawerSheet {
      position:fixed; left:0; right:0; bottom:0;
      background:#0b0b0b; color:#eee; border-top-left-radius:16px; border-top-right-radius:16px;
      box-shadow: 0 -8px 28px rgba(0,0,0,6); max-height:75vh; overflow:auto;
    }
    #timerDrawerHeader {
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding:12px 14px; border-bottom:1px solid rgba(255,255,255,08);
    }
    #timerDrawerTitle { font-weight:700; }
    #timerDrawerClose {
      border:1px solid rgba(255,255,255,25); background:#121212; color:#eee; border-radius:10px; padding:8px 10px;
    }
    #timerList { padding:10px 12px; display:flex; flex-direction:column; gap:10px; }

    /* FIX: stack content + wrap actions to avoid clipping on small widths */
    .timerCard {
      border:1px solid rgba(255,255,255,15); border-radius:12px; padding:10px 12px; background:#101010;
      display:grid; grid-template-columns: 1fr; gap:10px; align-items:center;
    }
    .timerMain { display:flex; flex-direction:column; gap:6px; }
    .timerLabel { font-weight:600; }
    .timerMeta { font-size:12px; opacity:.8; }
    .timerRow { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .timerProgress {
      height:6px; background:#161616; border-radius:6px; overflow:hidden; border:1px solid rgba(255,255,255,1);
    }
    .timerProgress > div { height:100%; width:0%; background:#3a86ff; }
    .tbtn {
      border:1px solid rgba(255,255,255,25); background:#151515; color:#eee; border-radius:10px; padding:6px 10px; font-size:13px;
    }

    /* Optional: on wider screens, return to two columns */
    @media (min-width: 520px){
      .timerCard { grid-template-columns: 1fr auto; }
    }

    /* --- Sticky “Timer Done” bar --- */
  #timerDoneBar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--surface);
    border-top: 2px solid var(--border);
    padding: 10px;
    display: none;
    z-index: 999999; /* ensure it sits over Cook Mode */
  }

    #timerDoneBar.show { display: block; }
    #timerDoneBar .inner {
      display:flex; align-items:center; gap:10px; padding:10px 12px;
    }
    #timerDoneMsg { font-weight:600; flex:1; }
    #timerDoneBar .bar-btn {
      border:1px solid rgba(255,255,255,.25); background:#111; color:#eee; border-radius:10px; padding:8px 12px;
    }
    
  </style>


  <button id="timerChip" type="button" hidden>
    <span class="dot"></span>
    <span id="timerChipCount">0</span>
    <span>Timers</span>
  </button>

  <div id="timerDrawer">
    <div id="timerDrawerOverlay"></div>
    <div id="timerDrawerSheet" role="dialog" aria-modal="true" aria-label="Timers">
      <div id="timerDrawerHeader">
        <div id="timerDrawerTitle">Timers</div>
        <button id="timerDrawerClose" type="button">Close</button>
      </div>
      <div id="timerList"></div>
    </div>
  </div>

  <!-- Sticky “Timer Done” bar (hidden until a timer finishes) -->
  <div id="timerDoneBar" role="alert" aria-live="assertive">
    <div class="inner">
      <div id="timerDoneMsg">Timer done</div>
      <button id="timerDoneOpen" class="bar-btn" type="button">Open</button>
      <button id="timerDoneAck" class="bar-btn" type="button" aria-label="Acknowledge alarm">Acknowledge</button>
    </div>
  </div>

  <script id="timer-core-module">
  /*
    Timers core + UI (Chip + Drawer) — with DONE alarm + notifications
    - Persistence: localStorage "timers.v1" (backward compatible; adds optional isDone:boolean)
    - Cross-tab: BroadcastChannel "timers"
    - Countdown derived from endsAt (avoid drift)
    - Alarm: WebAudio loop (unlocked on first user gesture), Notification API + vibration, sticky “Timer Done” bar
    - Public API (window.timers):
        create({label, durationMs, context}) -> id
        pause(id) / resume(id) / stop(id) / snooze(id, minutes)
        list() / subscribe(cb) -> unsubscribe()
        unlockAudio() / requestNotifyPermission()
  */
  (function(){
    // --- Singleton guard: if another copy of this script exists in the page, do nothing.
    if (window.__timersSingletonLoaded) { return; }
    window.__timersSingletonLoaded = true;

    const LS_KEY = "timers.v1";
    const CH_NAME = "timers";
    const bc = ("BroadcastChannel" in self) ? new BroadcastChannel(CH_NAME) : null;

    // ===== Alarm sound file (MP3/WAV/OGG) =====
    // Put your file next to index.html as "alarm.mp3", or set this to a Firebase Storage download URL.
  const ALARM_URL = 'alarm.mp3';

    const chip = document.getElementById('timerChip');
    const chipCount = document.getElementById('timerChipCount');
    const drawer = document.getElementById('timerDrawer');
    const drawerOverlay = document.getElementById('timerDrawerOverlay');
    const drawerClose = document.getElementById('timerDrawerClose');
    const listEl = document.getElementById('timerList');

    // Sticky “done” bar
    const doneBar = document.getElementById('timerDoneBar');
    const doneMsg = document.getElementById('timerDoneMsg');
    const doneAck = document.getElementById('timerDoneAck');
    const doneOpen = document.getElementById('timerDoneOpen');

    // ---------- Store ----------
    function uid8(){
      try {
        const a = new Uint8Array(8);
        (self.crypto||window.crypto).getRandomValues(a);
        return Array.from(a,x=>x.toString(16).padStart(2,'0')).join('');
      } catch(e){
        return (Date.now().toString(36)+Math.random().toString(36).slice(2,10)).slice(0,16);
      }
    }

    function now(){ return Date.now(); }

    function readStore(){
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); }
      catch(e){ return []; }
    }
    function writeStore(arr){
      localStorage.setItem(LS_KEY, JSON.stringify(arr));
      if (bc) bc.postMessage({ type:"storeUpdated" });
      notify();
    }

    function list(){ return readStore(); }
    function getById(id){ return list().find(t => t.id === id); }

    function create({label, durationMs, context}){
      const id = uid8();
      const createdAt = now();
      const t = {
        id, label: String(label||'Timer'),
        durationMs: Math.max(0, durationMs|0),
        // Calculate endsAt from now (running)
        endsAt: createdAt + Math.max(0, durationMs|0),
        remainingMs: null,
        isPaused: false,
        isDone: false,          // NEW (back-compat; absent means false)
        context: context || null,
        createdAt
      };
      const arr = list();
      arr.push(t);
      writeStore(arr);
      return id;
    }

    function pause(id){
      const arr = list();
      const i = arr.findIndex(t => t.id === id);
      if (i === -1) return;
      const t = arr[i];
      if (!t.isPaused && !t.isDone) {
        const rem = Math.max(0, (t.endsAt||0) - now());
        t.remainingMs = rem;
        t.endsAt = null;
        t.isPaused = true;
        arr[i] = t;
        writeStore(arr);
      }
    }

    function resume(id){
      const arr = list();
      const i = arr.findIndex(t => t.id === id);
      if (i === -1) return;
      const t = arr[i];
      if (t.isPaused && !t.isDone) {
        const rem = Math.max(0, t.remainingMs|0);
        t.endsAt = now() + rem;
        t.remainingMs = null;
        t.isPaused = false;
        arr[i] = t;
        writeStore(arr);
      }
    }

    function stop(id){
      const arr = list().filter(t => t.id !== id);
      writeStore(arr);
      if (!list().some(x => x.isDone)) stopAlarm(); // if no more done timers, stop alarm
      if (!list().length) hideDoneBar();
    }

    function snooze(id, minutes){
      const add = Math.max(1, minutes|0) * 60_000;
      const arr = list();
      const i = arr.findIndex(t => t.id === id);
      if (i === -1) return;
      const t = arr[i];
      // Snoozing a done timer restarts it
      if (t.isDone) {
        t.isDone = false;
        t.isPaused = false;
        t.remainingMs = null;
        t.endsAt = now() + add;
      } else if (t.isPaused) {
        t.remainingMs = Math.max(0, (t.remainingMs||0) + add);
      } else {
        const rem = Math.max(0, (t.endsAt||0) - now()) + add;
        t.endsAt = now() + rem;
      }
      arr[i] = t;
      writeStore(arr);
      hideDoneBar();
      if (!list().some(x => x.isDone)) stopAlarm();
    }

  // Adjust remaining time by an arbitrary delta (ms). Negative = subtract.
  function adjust(id, deltaMs){
    const delta = (deltaMs|0);
    const arr = list();
    const i = arr.findIndex(t => t.id === id);
    if (i === -1) return;
    const t = arr[i];
    if (t.isDone) return; // no-op for completed timers
    if (t.isPaused) {
      t.remainingMs = Math.max(0, (t.remainingMs||0) + delta);
    } else if (t.endsAt != null) {
      const rem = Math.max(0, (t.endsAt||0) - now()) + delta;
      t.endsAt = now() + Math.max(0, rem);
    }
    arr[i] = t;
    writeStore(arr);
  }

    // ---------- Subscriptions ----------
    const subs = new Set();


    function subscribe(cb){
      subs.add(cb);
      cb(list());
      return () => subs.delete(cb);
    }
    function notify(){
      for (const cb of Array.from(subs)) cb(list());
    }
    if (bc) bc.onmessage = (e) => {
      if (e && e.data && e.data.type === 'storeUpdated') notify();
    };

    // ---------- Alarm engine (WebAudio) ----------
    let audioUnlocked = false;
    let ac = null;
    // File-based alarm nodes
    let alarmBuffer = null;     // decoded AudioBuffer
    let alarmSrc = null;        // current AudioBufferSourceNode
    let alarmGain = null;       // GainNode to control volume/fades
    let alarmTimer = 0;         // legacy interval (not used for file playback; kept for safety)


  async function unlockAudio(){
      if (audioUnlocked) return;
      try {
        ac = ac || new (window.AudioContext || window.webkitAudioContext)();
        try { if (ac.state === 'suspended') await ac.resume(); } catch(e){}
        const n = ac.createOscillator();
        const g = ac.createGain();
        n.type = 'sine';
        n.frequency.value = 880;
        g.gain.value = 0;
        n.connect(g); g.connect(ac.destination);
        n.start();
        // brief click to unlock
        g.gain.setValueAtTime(0.0001, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.05);
        setTimeout(() => { try{ n.stop(); }catch(e){} }, 120);
        audioUnlocked = (ac.state === 'running');
      } catch(e){}
    }

        async function playAlarm(){
      // Ensure AudioContext exists and is running
      if (!ac) {
        try { ac = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}
      }
      if (!ac) return;
      try { if (ac.state === 'suspended') await ac.resume(); } catch(e){}

      // If already playing, do nothing (idempotent guard)
      if (alarmSrc) {
        return;
      }

      // Load & decode the alarm buffer once (cached)
      async function ensureAlarmBuffer(){
        if (alarmBuffer) return alarmBuffer;
        try {
          const res = await fetch(ALARM_URL, { cache: 'force-cache' });
          const arr = await res.arrayBuffer();
          // Some browsers require callback form; try promise first, fallback below
          if (ac.decodeAudioData.length === 1) {
            alarmBuffer = await ac.decodeAudioData(arr);
          } else {
            alarmBuffer = await new Promise((resolve, reject) => {
              ac.decodeAudioData(arr, resolve, reject);
            });
          }
        } catch(e){
          console.error('Failed to load alarm sound:', e);
          alarmBuffer = null;
        }
        return alarmBuffer;
      }

      const buf = await ensureAlarmBuffer();
      if (!buf) return;

      // Build a fresh graph and start looping the audio file
      try {
        alarmSrc = ac.createBufferSource();
        alarmSrc.buffer = buf;
        alarmSrc.loop = true;

        alarmGain = ac.createGain();
        // Small fade-in to avoid click
        const t = ac.currentTime;
        alarmGain.gain.cancelScheduledValues(t);
        alarmGain.gain.setValueAtTime(0.0001, t);
        alarmGain.gain.exponentialRampToValueAtTime(0.8, t + 0.08);

        alarmSrc.connect(alarmGain);
        alarmGain.connect(ac.destination);
        alarmSrc.start();
      } catch(e){
        console.error('Failed to start alarm playback:', e);
      }

      // Clear any legacy interval (no pulsing needed for file playback)
      clearInterval(alarmTimer);
      alarmTimer = 0;
    }



    function stopAlarm(){
      clearInterval(alarmTimer);
      alarmTimer = 0;

      // Smooth fade-out, then stop and tear down the file source
      if (alarmGain && ac) {
        try {
          const t = ac.currentTime;
          alarmGain.gain.cancelScheduledValues(t);
          alarmGain.gain.setValueAtTime(alarmGain.gain.value || 0.8, t);
          alarmGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);
        } catch(e){}
      }

      // Stop after the short fade
      setTimeout(() => {
        try { if (alarmSrc) alarmSrc.stop(); } catch(e){}
        try { if (alarmSrc) alarmSrc.disconnect(); } catch(e){}
        try { if (alarmGain) alarmGain.disconnect(); } catch(e){}
        alarmSrc = null;
        alarmGain = null;
      }, 120);
    }

    // ---------- Notifications ----------
    function requestNotifyPermission(){

      try {
        if (!("Notification" in window)) return;
        if (Notification.permission === 'default') Notification.requestPermission().catch(()=>{});
      } catch(e){}
    }
    function vibrate(){
      try { if ('vibrate' in navigator) navigator.vibrate([200, 100, 200, 100, 400]); } catch(e){}
    }
    function sendNotification(t){
      try {
        if (!("Notification" in window)) return;
        if (Notification.permission !== 'granted') return;
        const title = 'Timer done';
        const body = String(t?.label || 'Timer');
        const n = new Notification(title, { body, tag: 'timers', renotify:true });
        // Clicking focuses the app
        n.onclick = () => { window.focus?.(); try { n.close(); } catch{} };
      } catch(e){}
    }

    // ---------- UI: Chip + Drawer + Done Bar ----------
    function openDrawer(){
      drawer.setAttribute('open','');
      renderList();
      unlockAudio();
      requestNotifyPermission();
    }
    function closeDrawer(){
      drawer.removeAttribute('open');
    }
    chip.addEventListener('click', openDrawer);
    drawerOverlay.addEventListener('click', closeDrawer);
    drawerClose.addEventListener('click', closeDrawer);

    function showDoneBar(t){
      if (!t) return;
      doneMsg.textContent = `⏰ Timer done: ${String(t.label||'Timer')}`;
      doneBar.classList.add('show');
    }
    function hideDoneBar(){ doneBar.classList.remove('show'); }

  // Delegated clicks so buttons work even if the bar is rebuilt/moved
  document.addEventListener('click', (ev) => {
    const t = ev.target;
    if (!t || !(t instanceof HTMLElement)) return;

    if (t.id === 'timerDoneAck') {
      // Acknowledge all currently-done timers, but keep the bar visible
      const arr = list();
      let mutated = false;
      for (const itm of arr) {
        if (itm && itm.isDone && !itm.isDoneAck) {
          itm.isDoneAck = true;
          mutated = true;
        }
      }
      if (mutated) writeStore(arr);
      // Stop the alarm sound, but do NOT hide the bar here
      stopAlarm();
    } else if (t.id === 'timerDoneOpen') {
      // Prefer the first unacknowledged done timer; fall back to any done timer
      const arr = list();
      const firstDone = arr.find(x => x.isDone && !x.isDoneAck) || arr.find(x => x.isDone);
      if (firstDone && firstDone.context) {
        try {
          if (typeof firstDone.context.goTo === 'function') {
            firstDone.context.goTo();
          } else if (firstDone.context.recipe && Array.isArray(firstDone.context.recipe.steps)) {
            cookMode.open(firstDone.context.recipe, Number(firstDone.context.stepIndex||0)|0);
          }
        } catch(e){}
      }
    }
  });



    // Render loop (throttled) — also promotes timers to "done" and fires alarm
    let rafId = 0, lastTick = 0;
    function tick(ts){
      if (!lastTick) lastTick = ts;
      const elapsed = ts - lastTick;
      if (elapsed >= 200) { // ~5 fps is enough for countdown text & progress
        // Promote completed timers to done
        const arr = list();
        let mutated = false;
        for (const t of arr) {
          if (!t.isDone && !t.isPaused && t.endsAt != null && (t.endsAt - now()) <= 0) {
            t.isDone = true;
            t.endsAt = now();      // clamp
            t.remainingMs = 0;
            mutated = true;
          }
        }
        if (mutated) writeStore(arr);

            const arrNow = list();
        const anyDone = arrNow.some(x => x.isDone);
        const firstUnacked = arrNow.find(x => x.isDone && !x.isDoneAck);
        const toShow = firstUnacked || arrNow.find(x => x.isDone);

        if (anyDone && toShow) {
          // Keep the bar visible if *any* done timer exists,
          // but only play/vibrate/notify for unacknowledged ones
          showDoneBar(toShow);
          if (firstUnacked) {
            playAlarm();
            vibrate();
            sendNotification(firstUnacked);
          }
        } else {
          // No done timers remaining — hide bar and ensure alarm is stopped
          hideDoneBar();
          stopAlarm();
        }



        renderChip();
        if (drawer.hasAttribute('open')) renderList();
        lastTick = ts;
      }
      rafId = requestAnimationFrame(tick);
    }
    rafId = requestAnimationFrame(tick);

    function fmt(ms){
      ms = Math.max(0, ms|0);
      const s = Math.floor(ms/1000);
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      return (hh>0? (String(hh).padStart(2,'0')+':'):'') + String(mm).padStart(2,'0')+':'+String(ss).padStart(2,'0');
    }

    function remainingFor(t){
      if (t.isDone) return 0;
      if (t.isPaused) return Math.max(0, t.remainingMs|0);
      if (t.endsAt == null) return 0;
      return Math.max(0, t.endsAt - now());
    }

    function progressFor(t){
      const total = (t.isPaused ? (t.remainingMs||t.durationMs) : t.durationMs);
      const rem = remainingFor(t);
      if (!total) return 0;
      const done = total - rem;
      return Math.max(0, Math.min(1, done/total));
    }

    function renderChip(){
      const arr = list();
      const active = arr.length;
      chipCount.textContent = String(active);
      chip.hidden = (active === 0);
    }

    function renderList(){
      const arr = list();
      if (arr.length === 0) {
        listEl.innerHTML = `<div style="opacity:.8; padding:10px 12px;">No active timers.</div>`;
        return;
      }
      listEl.innerHTML = arr.map(t => {
        const done = !!t.isDone;
        const rem = done ? 0 : remainingFor(t);
        const p = Math.round((done ? 100 : progressFor(t)*100));
        const ctx = (t.context && (t.context.recipeId || t.context.stepId)) ? `recipe:${t.context.recipeId||''} step:${t.context.stepId||''}` : '';
        const meta = done ? 'Done · 00:00' : (t.isPaused ? 'Paused' : 'Running') + ' · ' + fmt(rem) + (ctx ? ' · '+sanitizeHtml(ctx) : '');
        return `
          <div class="timerCard" data-id="${t.id}">
            <div class="timerMain">
              <div class="timerLabel">${sanitizeHtml(String(t.label||'Timer'))}</div>
              <div class="timerRow"><div class="timerMeta">${meta}</div></div>
              <div class="timerProgress"><div style="width:${p}%"></div></div>
            </div>
            <div class="timerRow">
              ${done
                ? `<button class="tbtn act-open" type="button">Open Step</button>
                  <button class="tbtn act-s1" type="button">+1m</button>
                  <button class="tbtn act-s3" type="button">+3m</button>
                  <button class="tbtn act-s5" type="button">+5m</button>
                  <button class="tbtn act-s10" type="button">+10m</button>
                  <button class="tbtn act-stop" type="button">Stop</button>`
                : (t.isPaused
                    ? `<button class="tbtn act-resume" type="button">Resume</button>`
                    : `<button class="tbtn act-pause" type="button">Pause</button>`)
              }
              ${done ? '' : `
                <div class="tbtn act-m10s" role="button">–10s</div>
                <div class="tbtn act-m1" role="button">–1m</div>
                <div class="tbtn act-s1" role="button">+1m</div>
                <div class="tbtn act-s3" role="button">+3m</div>
                <div class="tbtn act-s5" role="button">+5m</div>
                <div class="tbtn act-s10" role="button">+10m</div>
                <button class="tbtn act-open" type="button">Open Step</button>
                <button class="tbtn act-stop" type="button">Stop</button>
              `}
            </div>
          </div>
        `;
      }).join('');
    }


    // Delegated actions
    listEl.addEventListener('click', (ev) => {
      const card = ev.target.closest('.timerCard');
      if (!card) return;
      const id = card.getAttribute('data-id');
      if (!id) return;

      if (ev.target.classList.contains('act-pause')) {
        pause(id);
      } else if (ev.target.classList.contains('act-resume')) {
        resume(id);
      } else if (ev.target.classList.contains('act-s1')) {
        snooze(id, 1);
      } else if (ev.target.classList.contains('act-s3')) {
        snooze(id, 3);
      } else if (ev.target.classList.contains('act-s5')) {
        snooze(id, 5);
      } else if (ev.target.classList.contains('act-s10')) {
        snooze(id, 10);
      } else if (ev.target.classList.contains('act-m10s')) {
        // subtract 10 seconds
        if (typeof adjust === 'function') adjust(id, -10*1000);
      } else if (ev.target.classList.contains('act-m1')) {
        // subtract 1 minute
        if (typeof adjust === 'function') adjust(id, -60*1000);
      } else if (ev.target.classList.contains('act-stop')) {
        stop(id);
      } else if (ev.target.classList.contains('act-open')) {
        const t = getById(id);
        if (t && t.context && window.cookMode && typeof window.cookMode.setIndex === 'function' && typeof window.cookMode.open === 'function') {
          try {
            // Close the drawer so Cook Mode is visible
            closeDrawer();

            if (typeof t.context.goTo === 'function') {
              t.context.goTo();
            } else if (t.context.recipe && Array.isArray(t.context.recipe.steps)) {
              cookMode.open(t.context.recipe, Number(t.context.stepIndex||0)|0);
            } else if (Number.isFinite(t.context.stepIndex)) {
              cookMode.setIndex(Number(t.context.stepIndex)|0);
            }
          } catch(e){}
        }
      }

      renderList();
    });


    // First gesture anywhere can unlock audio (best-effort)
    window.addEventListener('pointerdown', unlockAudio, { once:true, passive:true });

  // Expose API
    window.timers = {
      create, pause, resume, stop, snooze, adjust, list, subscribe,
      unlockAudio, requestNotifyPermission
    };


  })();
  </script>


    
  </body>
  </html>


  

  
